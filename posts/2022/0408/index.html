<!doctype html><html lang=en><head><title>壊れた cf スタックのリストアと cdk の再同期 :: forest nook</title>
<meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="2時に寝て6時半に起きた。インフラエンジニアになったのでみんなが作業していない時間にインフラの保守作業をするようにしている。昼はアプリケーションエンジニア、夜はインフラエンジニアみたいな生活になっていてしんどい。
壊れた cf スタックの更新 テスト環境の cf スタックを手動で更新して壊れているのを cdk で管理できるように直した。壊れていたのは次の3つ。
rds をスナップショットからリストアしたので cf が管理している rds リソースが存在しない iam の acl 設定が異なる セキュリティグループのインバウンドルールが異なる aws 的にもそういった状況は認識していて cdk で同期できなくなった cf スタックを更新する手順を提供している。
AWS CloudFormation スタックを削除したときにリソースの一部を保持する方法を教えてください。 ざっくり手順をまとめると次になる。
対象のリソースに DeletetionPolicy=Retain にセットする テンプレートからリソースを削除して、スタックの更新を実行する テンプレート内のリソースの実際の状態を describe して、スタック内に既存のリソースをインポートする リソースの設定ぐらいなら既存のリソースからインポートしなくても cf のテンプレートを直接書き換えたものをアップロードしてスタックを更新するのでも大丈夫だったりする。しかし、cdk もそのテンプレートにあうように修正しないといけないため、cdk のコードとテンプレートのコードの両方をチェックしながら検証する必要がある。cdk でリソース管理ができるようになったからといって、それが変更前の既存のリソースの設定と同じかどうかは人間が目でみて検証しないといけない。これがあちこちで参照されているリソースだと追跡するのが面倒くさいといった手間暇がかかる。
cdk がよいものかどうか、私はまだ判断がつかないけど、cf を抽象化して便利になっているところは認めるものの、cf のスタックが壊れたときのトラブルシューティングが必要以上に複雑で厄介というのも事実ではある。一方で壊れた cf スタックを5時間ぐらいかけて直したのではまりポイントはいくつかも学ぶことができた。しんどかったけど。例えば、あるセキュリティグループのインバウンドルールに別のセキュリティグループを関連付けるとき、1つの設定ではうまくいかなくて次の2つの設定を追加した。これが適切かどうかわからないが、この設定で cdk でデプロイしたスタックの環境と既存リソースとの環境が整合した状態 (ドリフトが解消される) になった。こういうのが cdk の抽象化による訳のわからないところの1つ。
otherSecurityGroup.addIngressRule( ec2.SecurityGroup.fromSecurityGroupId(this, &amp;#39;my security group&amp;#39;, mySgId), ec2.Port.tcp(80), &amp;#34;my inboud rule&amp;#34;, ) otherSecurityGroup.addIngressRule( ec2.Peer.securityGroupId(mySgId), ec2.Port.tcp(80), &amp;#34;my inboud rule&amp;#34;, ) "><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=/diary/posts/2022/0408/><link rel=stylesheet href=/diary/styles.css><link rel=stylesheet href=/diary/style.css><link rel="shortcut icon" href=/diary/favicon.ico><meta name=twitter:card content="summary"><meta name=twitter:site content="t2y"><meta name=twitter:creator content><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="壊れた cf スタックのリストアと cdk の再同期"><meta property="og:description" content="2時に寝て6時半に起きた。インフラエンジニアになったのでみんなが作業していない時間にインフラの保守作業をするようにしている。昼はアプリケーションエンジニア、夜はインフラエンジニアみたいな生活になっていてしんどい。
壊れた cf スタックの更新 テスト環境の cf スタックを手動で更新して壊れているのを cdk で管理できるように直した。壊れていたのは次の3つ。
rds をスナップショットからリストアしたので cf が管理している rds リソースが存在しない iam の acl 設定が異なる セキュリティグループのインバウンドルールが異なる aws 的にもそういった状況は認識していて cdk で同期できなくなった cf スタックを更新する手順を提供している。
AWS CloudFormation スタックを削除したときにリソースの一部を保持する方法を教えてください。 ざっくり手順をまとめると次になる。
対象のリソースに DeletetionPolicy=Retain にセットする テンプレートからリソースを削除して、スタックの更新を実行する テンプレート内のリソースの実際の状態を describe して、スタック内に既存のリソースをインポートする リソースの設定ぐらいなら既存のリソースからインポートしなくても cf のテンプレートを直接書き換えたものをアップロードしてスタックを更新するのでも大丈夫だったりする。しかし、cdk もそのテンプレートにあうように修正しないといけないため、cdk のコードとテンプレートのコードの両方をチェックしながら検証する必要がある。cdk でリソース管理ができるようになったからといって、それが変更前の既存のリソースの設定と同じかどうかは人間が目でみて検証しないといけない。これがあちこちで参照されているリソースだと追跡するのが面倒くさいといった手間暇がかかる。
cdk がよいものかどうか、私はまだ判断がつかないけど、cf を抽象化して便利になっているところは認めるものの、cf のスタックが壊れたときのトラブルシューティングが必要以上に複雑で厄介というのも事実ではある。一方で壊れた cf スタックを5時間ぐらいかけて直したのではまりポイントはいくつかも学ぶことができた。しんどかったけど。例えば、あるセキュリティグループのインバウンドルールに別のセキュリティグループを関連付けるとき、1つの設定ではうまくいかなくて次の2つの設定を追加した。これが適切かどうかわからないが、この設定で cdk でデプロイしたスタックの環境と既存リソースとの環境が整合した状態 (ドリフトが解消される) になった。こういうのが cdk の抽象化による訳のわからないところの1つ。
otherSecurityGroup.addIngressRule( ec2.SecurityGroup.fromSecurityGroupId(this, &amp;#39;my security group&amp;#39;, mySgId), ec2.Port.tcp(80), &amp;#34;my inboud rule&amp;#34;, ) otherSecurityGroup.addIngressRule( ec2.Peer.securityGroupId(mySgId), ec2.Port.tcp(80), &amp;#34;my inboud rule&amp;#34;, ) "><meta property="og:url" content="/diary/posts/2022/0408/"><meta property="og:site_name" content="forest nook"><meta property="og:image" content="/diary/"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:published_time" content="2022-04-08 10:13:19 +0900 +0900"></head><body class=green><div class="container full headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/diary><div class=logo>forest nook</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/diary/about>自己紹介</a></li><li><a href=/diary/dates>月別一覧</a></li><li><a href=/diary/tags>タグ一覧</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/diary/about>自己紹介</a></li><li><a href=/diary/dates>月別一覧</a></li><li><a href=/diary/tags>タグ一覧</a></li></ul></nav></header><div class=content><article class=post><h1 class=post-title><a href=/diary/posts/2022/0408/>壊れた cf スタックのリストアと cdk の再同期</a></h1><div class=post-meta><time class=post-date>2022-04-08</time></div><span class=post-tags>#<a href=/diary/tags/cdk/>cdk</a>&nbsp;
#<a href=/diary/tags/infrastructure/>infrastructure</a>&nbsp;</span><div class=post-content><div><p>2時に寝て6時半に起きた。インフラエンジニアになったのでみんなが作業していない時間にインフラの保守作業をするようにしている。昼はアプリケーションエンジニア、夜はインフラエンジニアみたいな生活になっていてしんどい。</p><h2 id=壊れた-cf-スタックの更新>壊れた cf スタックの更新<a href=#壊れた-cf-スタックの更新 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>テスト環境の cf スタックを手動で更新して壊れているのを cdk で管理できるように直した。壊れていたのは次の3つ。</p><ul><li>rds をスナップショットからリストアしたので cf が管理している rds リソースが存在しない</li><li>iam の acl 設定が異なる</li><li>セキュリティグループのインバウンドルールが異なる</li></ul><p>aws 的にもそういった状況は認識していて cdk で同期できなくなった cf スタックを更新する手順を提供している。</p><ul><li><a href=https://aws.amazon.com/jp/premiumsupport/knowledge-center/delete-cf-stack-retain-resources/>AWS CloudFormation スタックを削除したときにリソースの一部を保持する方法を教えてください。</a></li></ul><p>ざっくり手順をまとめると次になる。</p><ol><li>対象のリソースに DeletetionPolicy=Retain にセットする</li><li>テンプレートからリソースを削除して、スタックの更新を実行する</li><li>テンプレート内のリソースの実際の状態を describe して、スタック内に既存のリソースをインポートする</li></ol><p>リソースの設定ぐらいなら既存のリソースからインポートしなくても cf のテンプレートを直接書き換えたものをアップロードしてスタックを更新するのでも大丈夫だったりする。しかし、cdk もそのテンプレートにあうように修正しないといけないため、cdk のコードとテンプレートのコードの両方をチェックしながら検証する必要がある。cdk でリソース管理ができるようになったからといって、それが変更前の既存のリソースの設定と同じかどうかは人間が目でみて検証しないといけない。これがあちこちで参照されているリソースだと追跡するのが面倒くさいといった手間暇がかかる。</p><p>cdk がよいものかどうか、私はまだ判断がつかないけど、cf を抽象化して便利になっているところは認めるものの、cf のスタックが壊れたときのトラブルシューティングが必要以上に複雑で厄介というのも事実ではある。一方で壊れた cf スタックを5時間ぐらいかけて直したのではまりポイントはいくつかも学ぶことができた。しんどかったけど。例えば、あるセキュリティグループのインバウンドルールに別のセキュリティグループを関連付けるとき、1つの設定ではうまくいかなくて次の2つの設定を追加した。これが適切かどうかわからないが、この設定で cdk でデプロイしたスタックの環境と既存リソースとの環境が整合した状態 (ドリフトが解消される) になった。こういうのが cdk の抽象化による訳のわからないところの1つ。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#a6e22e>otherSecurityGroup</span>.<span style=color:#a6e22e>addIngressRule</span>(
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>ec2</span>.<span style=color:#a6e22e>SecurityGroup</span>.<span style=color:#a6e22e>fromSecurityGroupId</span>(<span style=color:#66d9ef>this</span>, <span style=color:#e6db74>&#39;my security group&#39;</span>, <span style=color:#a6e22e>mySgId</span>),
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>ec2</span>.<span style=color:#a6e22e>Port</span>.<span style=color:#a6e22e>tcp</span>(<span style=color:#ae81ff>80</span>),
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;my inboud rule&#34;</span>,
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>otherSecurityGroup</span>.<span style=color:#a6e22e>addIngressRule</span>(
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>ec2</span>.<span style=color:#a6e22e>Peer</span>.<span style=color:#a6e22e>securityGroupId</span>(<span style=color:#a6e22e>mySgId</span>),
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>ec2</span>.<span style=color:#a6e22e>Port</span>.<span style=color:#a6e22e>tcp</span>(<span style=color:#ae81ff>80</span>),
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;my inboud rule&#34;</span>,
</span></span><span style=display:flex><span>)
</span></span></code></pre></div></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=/diary/posts/2022/0409/><span class=button__icon>←</span>
<span class=button__text>開発が遅れる空気</span>
</a></span><span class="button next"><a href=/diary/posts/2022/0407/><span class=button__text>cdk のメジャーバージョンのマイグレーション</span>
<span class=button__icon>→</span></a></span></div></div></article></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>© 2021 Tetsuya Morimoto</span>
<span>:: <a href=https://github.com/panr/hugo-theme-terminal target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/diary/bundle.min.js></script></div></body></html>