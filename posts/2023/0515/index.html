<!doctype html><html lang=en><head><title>goleak と context によるキャンセル制御 :: forest nook</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="0時に寝て何度か起きて7時に起きた。いつもなら日曜日は徹夜して翌日の早朝に出掛けるのが月曜日は行かなくて済むのでちょっと楽になった。
amqp091-go の context 制御 goroutine リークを検出するツールに uber-go/goleak がある。ずっと前から余裕のあるときに結合テストの導入しようという issue を作っていたものの、適当なタイミングがなかった。先週末に少し手が空いたので着手した。goleak は個別のテストメソッドにも TestMain にも両方に対応している。結合テストの TestMain に入れた方が保守コストが下がるのでそういった用途がよいのではないかと思う。
go の TestMain がこういうものかもしれないが、defer 文を使う終了処理があるとそのコードを直接 TestMain には実装できない。関数で wrap して m.Run() を実行した結果を返すようにしないといけない。そこに goleak を入れる場合、goleak.Cleanup を何もしない関数に置き換えて m.Run() の結果を返せばよいのではないかと思う。そして VerifyTestMain() は m.Run() を実行してからすぐに goroutine が動いていないかをチェックする。ここで結合テストを動かすための、環境構築のために http サーバーを goroutine で起動するとか、テストのための goroutine が動いているとそれも検出してしまうのでそれらの goroutine は無視できるよう、2つのオプションが用意されている。
IgnoreTopFunction: 明示的に無視してよい goroutine のトップ関数を指定する IgnoreCurrent: オプションを登録した時点で稼働している goroutine を無視する これらを踏まえて TestMain で goleak を使うと次のようなコードになった。しかし、おそらくこの使い方はあまりよくない。いくつか goroutine を無視する設定を追加したために、そこに意図しない goroutine リークが隠蔽されてしまう懸念がある。
func main(m *testing.M) int { defer myTearDown() var code int goleak."><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=/diary/posts/2023/0515/><link rel=stylesheet href=/diary/styles.css><link rel=stylesheet href=/diary/style.css><link rel="shortcut icon" href=/diary/favicon.ico><meta name=twitter:card content="summary"><meta name=twitter:site content="t2y"><meta name=twitter:creator content><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="goleak と context によるキャンセル制御"><meta property="og:description" content="0時に寝て何度か起きて7時に起きた。いつもなら日曜日は徹夜して翌日の早朝に出掛けるのが月曜日は行かなくて済むのでちょっと楽になった。
amqp091-go の context 制御 goroutine リークを検出するツールに uber-go/goleak がある。ずっと前から余裕のあるときに結合テストの導入しようという issue を作っていたものの、適当なタイミングがなかった。先週末に少し手が空いたので着手した。goleak は個別のテストメソッドにも TestMain にも両方に対応している。結合テストの TestMain に入れた方が保守コストが下がるのでそういった用途がよいのではないかと思う。
go の TestMain がこういうものかもしれないが、defer 文を使う終了処理があるとそのコードを直接 TestMain には実装できない。関数で wrap して m.Run() を実行した結果を返すようにしないといけない。そこに goleak を入れる場合、goleak.Cleanup を何もしない関数に置き換えて m.Run() の結果を返せばよいのではないかと思う。そして VerifyTestMain() は m.Run() を実行してからすぐに goroutine が動いていないかをチェックする。ここで結合テストを動かすための、環境構築のために http サーバーを goroutine で起動するとか、テストのための goroutine が動いているとそれも検出してしまうのでそれらの goroutine は無視できるよう、2つのオプションが用意されている。
IgnoreTopFunction: 明示的に無視してよい goroutine のトップ関数を指定する IgnoreCurrent: オプションを登録した時点で稼働している goroutine を無視する これらを踏まえて TestMain で goleak を使うと次のようなコードになった。しかし、おそらくこの使い方はあまりよくない。いくつか goroutine を無視する設定を追加したために、そこに意図しない goroutine リークが隠蔽されてしまう懸念がある。
func main(m *testing.M) int { defer myTearDown() var code int goleak."><meta property="og:url" content="/diary/posts/2023/0515/"><meta property="og:site_name" content="forest nook"><meta property="og:image" content="/diary"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:published_time" content="2023-05-15 09:38:03 +0900 +0900"></head><body class=green><div class="container full headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/diary><div class=logo>forest nook</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/diary/about>自己紹介</a></li><li><a href=/diary/dates>月別一覧</a></li><li><a href=/diary/tags>タグ一覧</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/diary/about>自己紹介</a></li><li><a href=/diary/dates>月別一覧</a></li><li><a href=/diary/tags>タグ一覧</a></li></ul></nav></header><div class=content><article class=post><h1 class=post-title><a href=/diary/posts/2023/0515/>goleak と context によるキャンセル制御</a></h1><div class=post-meta><time class=post-date>2023-05-15 ::</time></div><span class=post-tags>#<a href=/diary/tags/rabbitmq/>rabbitmq</a>&nbsp;
#<a href=/diary/tags/go/>go</a>&nbsp;</span><div class=post-content><div><p>0時に寝て何度か起きて7時に起きた。いつもなら日曜日は徹夜して翌日の早朝に出掛けるのが月曜日は行かなくて済むのでちょっと楽になった。</p><h2 id=amqp091-go-の-context-制御>amqp091-go の context 制御<a href=#amqp091-go-の-context-制御 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>goroutine リークを検出するツールに <a href=https://github.com/uber-go/goleak>uber-go/goleak</a> がある。ずっと前から余裕のあるときに結合テストの導入しようという issue を作っていたものの、適当なタイミングがなかった。先週末に少し手が空いたので着手した。goleak は個別のテストメソッドにも TestMain にも両方に対応している。結合テストの TestMain に入れた方が保守コストが下がるのでそういった用途がよいのではないかと思う。</p><p>go の TestMain がこういうものかもしれないが、defer 文を使う終了処理があるとそのコードを直接 TestMain には実装できない。関数で wrap して m.Run() を実行した結果を返すようにしないといけない。そこに goleak を入れる場合、goleak.Cleanup を何もしない関数に置き換えて m.Run() の結果を返せばよいのではないかと思う。そして VerifyTestMain() は m.Run() を実行してからすぐに goroutine が動いていないかをチェックする。ここで結合テストを動かすための、環境構築のために http サーバーを goroutine で起動するとか、テストのための goroutine が動いているとそれも検出してしまうのでそれらの goroutine は無視できるよう、2つのオプションが用意されている。</p><ul><li>IgnoreTopFunction: 明示的に無視してよい goroutine のトップ関数を指定する</li><li>IgnoreCurrent: オプションを登録した時点で稼働している goroutine を無視する</li></ul><p>これらを踏まえて TestMain で goleak を使うと次のようなコードになった。しかし、おそらくこの使い方はあまりよくない。いくつか goroutine を無視する設定を追加したために、そこに意図しない goroutine リークが隠蔽されてしまう懸念がある。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>(<span style=color:#a6e22e>m</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>M</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>myTearDown</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>code</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>goleak</span>.<span style=color:#a6e22e>VerifyTestMain</span>(
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>m</span>,
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>goleak</span>.<span style=color:#a6e22e>Cleanup</span>(<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>exitCode</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;skip goleak cleanup&#34;</span>, <span style=color:#a6e22e>exitCode</span>)
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>code</span> = <span style=color:#a6e22e>exitCode</span>
</span></span><span style=display:flex><span>		}),
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>goleak</span>.<span style=color:#a6e22e>IgnoreTopFunction</span>(<span style=color:#e6db74>&#34;net/http.(*persistConn).readLoop&#34;</span>),
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>goleak</span>.<span style=color:#a6e22e>IgnoreTopFunction</span>(<span style=color:#e6db74>&#34;net/http.(*persistConn).writeLoop&#34;</span>),
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>goleak</span>.<span style=color:#a6e22e>IgnoreTopFunction</span>(<span style=color:#e6db74>&#34;internal/poll.runtime_pollWait&#34;</span>),
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>goleak</span>.<span style=color:#a6e22e>IgnoreCurrent</span>(),
</span></span><span style=display:flex><span>	)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>code</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TestMain</span>(<span style=color:#a6e22e>m</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>M</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Exit</span>(<span style=color:#a6e22e>main</span>(<span style=color:#a6e22e>m</span>))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>さらにこの調査をしているときに amqp091-go の api も context 受け取った方がシンプルでいいんじゃない？と思って提案の pr を送ってみた。context 使わなくても自前でキャンセルする api は提供されているため、開発者の考え方によってこの提案を拒否するのも妥当な判断だと思える。次のメジャーバージョンとか、互換性を維持しなくてよいタイミングから取り入れようという考え方もあるかもしれない。</p><ul><li><a href=https://github.com/rabbitmq/amqp091-go/pull/192>Add Channel.ConsumeWithContext to be able to cancel delivering #192</a></li></ul></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button next"><a href=/diary/posts/2023/0514/><span class=button__text>出張前々日</span>
<span class=button__icon>→</span></a></span></div></div></article></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>© 2021 Tetsuya Morimoto</span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script type=text/javascript src=/diary/bundle.min.js></script></div></body></html>