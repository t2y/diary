<!doctype html><html lang=en><head><meta name=generator content="Hugo 0.101.0"><title>forest nook</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=/diary/><link rel=stylesheet href=/diary/assets/style.css><link rel=stylesheet href=/diary/assets/green.css><link rel=stylesheet href=/diary/style.css><link rel=apple-touch-icon href=/diary/img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=/diary/favicon.ico><meta name=twitter:card content="summary"><meta name=twitter:site content="t2y"><meta name=twitter:creator content="t2y"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:title" content="forest nook"><meta property="og:description" content><meta property="og:url" content="/diary/"><meta property="og:site_name" content="forest nook"><meta property="og:image" content="/diary/favicon.ico"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><link href=/diary/index.xml rel=alternate type=application/rss+xml title="forest nook"></head><body class=green><div class="container full headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/diary><div class=logo>forest nook</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/diary/about>自己紹介</a></li><li><a href=/diary/dates>月別一覧</a></li><li><a href=/diary/tags>タグ一覧</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/diary/about>自己紹介</a></li><li><a href=/diary/dates>月別一覧</a></li><li><a href=/diary/tags>タグ一覧</a></li></ul></nav></header><div class=content><div class=posts><div class="post on-list"><h1 class=post-title><a href=/diary/posts/2022/1112/>go の nil を学び直し</a></h1><div class=post-meta><span class=post-date>2022-11-12</span></div><span class=post-tags>#<a href=/diary/tags/life/>life</a>&nbsp;
#<a href=/diary/tags/book/>book</a>&nbsp;</span><div class=table-of-contents><h2>目次</h2><nav id=TableOfContents><ul><li><a href=#ストレッチ>ストレッチ</a></li><li><a href=#オンライン読書会>オンライン読書会</a></li></ul></nav></div><div class=post-content><p>3時半から起きていたせいか夕方に眠くなって19時過ぎから23時まで寝て、それからまたオフィス行って4時ぐらいまで作業してから戻って寝て8時半に起きた。生活がめちゃくちゃ。</p><h2 id=ストレッチ>ストレッチ</h2><p>今日の開脚幅は開始前154cmで、ストレッチ後158cmだった。生活が不規則になって体力的にバテているのもあって右股関節、右腰の張りが強かった。さらに加えてふくらはぎ、腕と全身的にいつもより張りがあるように感じた。トレーナーさんが言うには座っている時間がいつもの週より多かったならその分だけ筋肉が固まってしまう可能性はあるとのこと。先週の東京出張から帰ってきて、リモート環境の構築、macbook 環境でメモをとった内容の見直し、リモートワークでマネージャー業をやるための準備や足りない知識の習得とか、さらに2つの社外イベントにも参加していたので普段の週よりも長い時間を机に向かって作業していたのは正しい。新しいお仕事を受けると一時的に仕事量の負荷が増える。それ自体は悪いことではないけれど、2-3ヶ月は余裕のない生活になりそうな気がする。毎週ストレッチがあるとそういった過労の疲労軽減に役立ってくれているので助かっている。</p><h2 id=オンライン読書会>オンライン読書会</h2><p>ずっと参加しようと思いつつ、都合があわなくて参加できていなかった <a href=https://technical-book-reading-2.connpass.com/event/262819/>第4回『Go言語による分散サービス』オンライン読書会</a> に4回目にして初参加した。7.4 発見されたサービスにリクエストし、ログをレプリケーションする (130ページ) から 8.2.3 有限ステートマシーン (163ページ) まで読んだ。途中からなので過去の経緯はわからないものの、柴田さんが詳しく解説してくれるのでまったくついていけないということはならなかった。出てくるサンプルコードのスニペットからでも学ぶことは多々ある。effective java 読書会に参加してた人だと柴田さんに覚えていてもらっていて嬉しかった。おそらく参加者の記録を自前で管理されているようにみえた。</p><p>go でインターフェースを実装しているかを確認するイディオムとして次のような宣言がある。nil を任意の struct のポインタにキャストするのを試す。変数は _ を宣言しているので実際にはこのコードはなにも定義しない。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>_</span> <span style=color:#a6e22e>mypkg</span>.<span style=color:#a6e22e>MyInterface</span> = (<span style=color:#f92672>*</span><span style=color:#a6e22e>MyImplements</span>)(<span style=color:#66d9ef>nil</span>)
</span></span></code></pre></div><p>なぜこんなことができるのかは <a href=https://text.baldanders.info/golang/nil-is-nil/>nil は nil</a> という記事で解説されている。interface 型は型への参照と値への参照を属性にもつオブジェクトであり、そのゼロ値は nil である。interface 型の nil は型への参照をもっているから nil をキャストするといったコードを書ける。python や java のような言語で nil に相当する None や null といった primitive はキャストするといった概念はない。事実上のシングルトンと言ってよいはず。一方で go の nil は原則として型への参照 nil 且つ、値への参照も nil なものではあるが、interface 型のゼロ値を表すため、この例で言えば、型への参照として mypkg.MyInterface 且つ、値への参照が nil のオブジェクトを生成できる。シングルトンではない。つまり <code>(*MyImplements)(nil) != nil</code> となる。go の nil は他言語からみて特殊ということを知ってはいたんだけど、読書会に出てそのことを確認するサンプルコードをみつけたことで私の学び直しになった。感謝。</p><p>ソースコードはここに置いた。</p><ul><li><a href=https://gitlab.com/t2y/misc/-/tree/main/implements>https://gitlab.com/t2y/misc/-/tree/main/implements</a></li></ul></div></div><div class="post on-list"><h1 class=post-title><a href=/diary/posts/2022/1111/>ログおじさん</a></h1><div class=post-meta><span class=post-date>2022-11-11</span></div><span class=post-tags>#<a href=/diary/tags/infrastructure/>infrastructure</a>&nbsp;
#<a href=/diary/tags/mermaid/>mermaid</a>&nbsp;
#<a href=/diary/tags/go/>go</a>&nbsp;
#<a href=/diary/tags/logging/>logging</a>&nbsp;</span><div class=table-of-contents><h2>目次</h2><nav id=TableOfContents><ul><li><a href=#システム構成の検討>システム構成の検討</a></li><li><a href=#logger-の再実装>Logger の再実装</a></li></ul></nav></div><div class=post-content><p>23時に寝て3時半に起きて眠れそうになかったからそのまま5時からオフィスで作業してた。</p><h2 id=システム構成の検討>システム構成の検討</h2><p>コンサルタントから顧客要件のヒアリングを行い、プロダクトを提供するインフラのシステム概要を mermaid で書いた。オンプレとクラウド環境のそれぞれを同じコンテナアプリケーションで動かすための構成を検討した。クラウド環境の一例として aws の構成を考えていて、https と http のプロトコル変換のようなことをするには api gateway を経由しないといけないと考えていたら、alb に証明書を設定して api gateway なくてもいけるとはらさんに教えてもらった。昔からできたそうで、なぜか私が長い間ずっと勘違いしていた。また時間があるときに自分でもやってみようと思う。</p><ul><li><a href=https://dev.classmethod.jp/articles/for-begginer-ssl-communication-by-aws-certificate-manager/>AWS Certificate Managerを使用してインターネットからELBへの通信をHTTPS化してみた</a></li></ul><h2 id=logger-の再実装>Logger の再実装</h2><p>プロダクトのコアな部分の実装は私がみた方がよいだろうと考えていて、そのうちの1つ Logger の設計がよくなかったので私が作り直した。といっても <a href=https://github.com/cybozu-go/log>cybozu-go/log</a> を使った薄いラッパーを設けただけ。チームメンバーからどこでエラーが起きているか追跡しにくいという声があったのでログ出力したところのソースコードの情報を出力しようと考えた。ググればたくさん出てくる。スタックフレームにアクセスする標準パッケージとして runtime を使うとできる。<a href=https://pkg.go.dev/runtime#Caller>runtime.Caller</a> と runtime.Callers は似て非なる関数のようでファイル名と行番号だけでよければ Caller を使った方がシンプルになると思う。関数名もほしかったら Callers を使ったスタックフレーム自体から取得する必要がある。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Trace</span>(<span style=color:#a6e22e>skip</span> <span style=color:#66d9ef>int</span>) (<span style=color:#a6e22e>file</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>funcName</span> <span style=color:#66d9ef>string</span>) {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>pc</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>uintptr</span>, <span style=color:#ae81ff>15</span>)
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>Callers</span>(<span style=color:#a6e22e>skip</span>, <span style=color:#a6e22e>pc</span>)
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>frames</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>CallersFrames</span>(<span style=color:#a6e22e>pc</span>[:<span style=color:#a6e22e>n</span>])
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>frame</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>frames</span>.<span style=color:#a6e22e>Next</span>()
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>_file</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>frame</span>.<span style=color:#a6e22e>File</span>[<span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>Index</span>(<span style=color:#a6e22e>frame</span>.<span style=color:#a6e22e>File</span>, <span style=color:#a6e22e>sourceRepositoryPath</span>)<span style=color:#f92672>+</span><span style=color:#ae81ff>8</span>:]
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>file</span> = <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Sprintf</span>(<span style=color:#e6db74>&#34;%s:%d&#34;</span>, <span style=color:#a6e22e>_file</span>, <span style=color:#a6e22e>frame</span>.<span style=color:#a6e22e>Line</span>)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>file</span>, <span style=color:#a6e22e>frame</span>.<span style=color:#a6e22e>Function</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>この情報を cybozu-go/log の map に追加するようなログ関数を提供するようにした。cybozu-go/log は標準の log パッケージに足りないところだけを追加していて、そのシンプルさと拡張性の高さを私は気に入ってよく使っている。私が気に入っているのでもっと有名になってほしい。</p><p>前のお手伝いでもログ基盤を含めて Logger を作っていて、またいまも Logger を作り直していて、気付いたら私は Logger やログ出力に一家言あるような、ログおじさんになりつつある。</p></div></div><div class="post on-list"><h1 class=post-title><a href=/diary/posts/2022/1110/>よい go コードを書くためのガイド</a></h1><div class=post-meta><span class=post-date>2022-11-10</span></div><span class=post-tags>#<a href=/diary/tags/go/>go</a>&nbsp;
#<a href=/diary/tags/programming/>programming</a>&nbsp;</span><div class=table-of-contents><h2>目次</h2><nav id=TableOfContents><ul><li><a href=#go-code-review-comments-の学び直し>Go Code Review Comments の学び直し</a></li></ul></nav></div><div class=post-content><p>2時に寝て6時に起きて2度寝したら8時だった。生活リズムがおかしい。</p><h2 id=go-code-review-comments-の学び直し>Go Code Review Comments の学び直し</h2><p>私の周りでは <a href=https://github.com/golang/go/wiki/CodeReviewComments>Go Code Review Comments</a> というドキュメントが引用されているのをよくみかける。google 社での go のコードレビューのときによくある指摘をまとめたものである。pr/mr を送る前にこれぐらいは自分でチェックしようといったガイドになる。私自身、過去に何度か読んでいるとは思うが、久しぶりに go 開発をするので学び直しも兼ねて読み直すことにした。うちのチームは java 開発者が多いせいか、go のコードで go っぽくないところがいくつか散見されていた。チームメンバーにも共有する意図も含めて2回にわけて勉強会をしてみんなで読み合わせをする。その下調べとして既存のコードでこのガイドに準拠していないコードがあればそれはわかりやすい事例になるので探したりしていた。</p></div></div><div class="post on-list"><h1 class=post-title><a href=/diary/posts/2022/1109/>軽量のコンテナオーケストレーションツールは存在しない</a></h1><div class=post-meta><span class=post-date>2022-11-09</span></div><span class=post-tags>#<a href=/diary/tags/docker/>docker</a>&nbsp;
#<a href=/diary/tags/kubernetes/>kubernetes</a>&nbsp;
#<a href=/diary/tags/event/>event</a>&nbsp;</span><div class=table-of-contents><h2>目次</h2><nav id=TableOfContents><ul><li><a href=#docker-の-swarm-mode>docker の swarm mode</a></li><li><a href=#hannali-dao-雑談>hannali dao 雑談</a></li></ul></nav></div><div class=post-content><p>0時に寝て6時に起きた。冷蔵庫に飲みものなくて不安。</p><h2 id=docker-の-swarm-mode>docker の swarm mode</h2><p>昨日から docker の <a href=https://docs.docker.com/engine/swarm/>swarm mode</a> について調べていた。</p><p>オンプレにコンテナのアプリケーションをデプロイするにあたり、軽量のコンテナオーケストレーションツールはないかと調べ始めた。<a href=https://www.portainer.io/blog/orchestrator-wars-continue>Kubernetes vs Docker Swarm vs Nomad - the orchestrator wars continue?</a> を記事を読むと、軽量のオーケストレーションツールと言えるのは swarm mode か <a href=https://www.nomadproject.io/>Nomad</a> ぐらいしかない。docker に付属しているならまずはそれを調べるべきだろうと調査した。そして swarm mode の採用は見送った。現時点でこの機能が廃止されるというアナウンスはないが、あまり保守されておらず、docker 社も積極的に推進していない。近い将来、機能が廃止される可能性が高いと私は判断した。</p><p>docker のドキュメントをみながら3台の ec2 インスタンスでクラスターを構築してみて簡単であることは間違いない。コマンド2つで swarm クラスターを構築できる。一通り触ってみて数台のマシンを管理する軽量のコンテナオーケストレーションツールとしては十分だと私は思うけれど、残念ながらこのツールが求められる業務やビジネスは少ないのだろうと思う。みんな k8s に持ってかれたという感じかな。調べていて読んだ記事など。</p><ul><li><a href=https://dockerswarm.rocks/>Docker Swarm Rocks</a></li><li><a href=https://levelup.gitconnected.com/six-tips-for-running-swarm-cluster-in-production-e0f2ef367694>Six Tips For Running Swarm Cluster in Production</a></li><li><a href=https://www.reddit.com/r/docker/comments/936924/docker_swarm_in_production_anyone_using_it/>Docker swarm in production - Anyone using it?</a></li></ul><h2 id=hannali-dao-雑談>hannali dao 雑談</h2><p><a href=https://hannari-python.connpass.com/event/265098/>Hannali DAO #02</a> に参加した。</p><p>最初は dao とは何かをみんなで雑談してた。私はお仕事しながら軽く聞いているつもりだったのが、議論に口出しして熱中してた。技術的に私が理解できないことが出てくると、私の認識が誤っていたり新しい気付きがあったりする可能性があるので、ついつい詳細を聞いてみたくなる。hannali dao でトークンをばら撒く戦略をみんなで考えていて dao の宣伝をしたら貢献の1つとみなしてトークンをもらえる。私は twitter でいくつか hannali dao のツィートをしていて、1ツィートが 300 PROG とかで、合計で 1250 PROG のトークンをもらった。PROG というのは hannali dao でのみ使えるトークンね。</p><p>その後、ウォレットに名前を付けられる <a href=https://ens.domains/ja/>ENS (Ethereum Name Service)</a> というサービスがあるのを教えてもらった。ちょうどいくらか ethereum をもってたので metamask に送金して、metamask で ens の登録 (購入) をやってみた。初めて ethereum を使ってサービスの支払いをやってみた。これで私も web3 を完全に理解したよ。ens で名前を登録 (購入) するのに $22.58 、ドメイン名みたいなものでサブドメインも登録できる。サブドメインを付けるのに $2.96 かかり、その ens を metamask に紐付けるのに $7.49 がかかった。metamask に紐付けると <a href=https://etherscan.io/>https://etherscan.io/</a> などで検索したときにウォレットのアドレスではなく、ens で購入した名前が表示されるようになる。トランザクションの履歴に名前が付いてそれが誰なのかが他人にもわかってしまうことがどういった影響を及ぼすのか、プライバシー云々の他に私はまだわかっていない。web3 なので購入した名前は一般公開されているものだけど、その名前は知り合いにしかまだ教えていない。暗号資産のウォレットに名前を付けることの意味や体験などをこれから経験してみる。</p></div></div><div class="post on-list"><h1 class=post-title><a href=/diary/posts/2022/1108/>設計談義</a></h1><div class=post-meta><span class=post-date>2022-11-08</span></div><span class=post-tags>#<a href=/diary/tags/go/>go</a>&nbsp;
#<a href=/diary/tags/design/>design</a>&nbsp;</span><div class=table-of-contents><h2>目次</h2><nav id=TableOfContents><ul><li><a href=#go-の-interface-の考え方>go の interface の考え方</a></li></ul></nav></div><div class=post-content><p>0時に寝て6時に起きた。2時と3時ぐらいに起きたけど、まぁまぁ眠れた。</p><h2 id=go-の-interface-の考え方>go の interface の考え方</h2><p>メンバーと設計の議論をしていて interface の考え方の概念を誤解しているように感じたので <a href=https://github.com/golang/go/wiki/CodeReviewComments#interfaces>Go Code Review Comments の interfaces</a> で書いてあることの意図や背景などを解説した。メンバー全員を集めて30分ほどで説明した。既存のコードは過剰に interface を設計していて、特定のメソッドを呼び出すラッパー関数を設けて、そのシグネチャに interface を受け取って構造体のメソッドを呼び出すコードを書いている。こんな感じのコード。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>myBehavior</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>doSome</span>(<span style=color:#a6e22e>data</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>error</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>myObject</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>myBehavior</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>o</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>myObject</span>) <span style=color:#a6e22e>doSome</span>(<span style=color:#a6e22e>data</span> <span style=color:#66d9ef>string</span>) {
</span></span><span style=display:flex><span>  <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>handleSome</span>(<span style=color:#a6e22e>o</span> <span style=color:#a6e22e>myBehavior</span>, <span style=color:#a6e22e>data</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>error</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>o</span>.<span style=color:#a6e22e>doSome</span>(<span style=color:#a6e22e>data</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>handleSome のようなラッパー関数は不要だし、myObject の構造体に interface を埋め込む必要はないし、Go Code Review Comments では構造体を定義しているところで interface を提供しない方が保守コストが下がってよいよと提案している。これは java のような nominal subtyping と go の structural subtyping の違いで go らしい interface は構造体の提供側ではなく、呼び出し側で勝手に定義して任意の振る舞いを強制できるといった内容を java と go のコードを比較しながら説明した。そして、この話しが重要になるのはサードパーティのライブラリを利用するときに interface が変わると、それを使っている開発者に大きな影響を与えるので interface を提供するなら慎重に練ったものを公開しないといけないという java 開発から得られた知見などが影響しているのではないかという私見も話した。さらに自分たちが管理しているコードなら interface が変わろうが struct のメソッドが変わろうが、すべて自分たちが変更できる権限をもっているから設計時に厳密に interface やメソッドの振る舞いを詰めきれなかったとしても、後から必要ならいつでもいくらでも変えればいいだけと一緒に話した。開発のバランス感覚は経験からでないと身に付かないものだと思う。</p></div></div><div class="post on-list"><h1 class=post-title><a href=/diary/posts/2022/1107/>まずは定例会議から言語化する</a></h1><div class=post-meta><span class=post-date>2022-11-07</span></div><span class=post-tags>#<a href=/diary/tags/mermaid/>mermaid</a>&nbsp;
#<a href=/diary/tags/management/>management</a>&nbsp;</span><div class=table-of-contents><h2>目次</h2><nav id=TableOfContents><ul><li><a href=#mermaid-の-er-図>mermaid の er 図</a></li><li><a href=#定例会議の進め方>定例会議の進め方</a></li></ul></nav></div><div class=post-content><p>23時ぐらいに寝て2回ぐらい起きて7時に起きた。やっぱり家だとうまく眠れない。</p><h2 id=mermaid-の-er-図>mermaid の er 図</h2><p>メンバーが mermaid の <a href="https://mermaid-js.github.io/mermaid/#/entityRelationshipDiagram?id=entity-relationship-diagrams">Entity Relationship Diagrams</a> でデータモデルの図を書いてくれてレビューしてた。見た目もすっきりしていて、テキストも書きやすい方だと思うので印象はよかった。gitlab でもリポジトリや wiki で mermaid で書いた図を表示できた。</p><h2 id=定例会議の進め方>定例会議の進め方</h2><p>マネージャーっぽいお仕事の1つとして定例会議を週に1回行う。スクラムにあるデイリースクラムのような、毎日メンバー全員を集める会議するのが私は好みではない。そんなことしなくても定例会議が週1で 1on1 が週1回ならば5日のうち2回は話すし、あと個別の打ち合わせも1-2回やれば十分に話す機会を得られると考えている。定例会議の進め方というドキュメントを一通り書いてみた。私が忘れたときに見返したり、実際にやってみてよかったこと・わるかったことを振り返りながら改善するための、基準として設けた。基準があるから改善できる。最初の1-2ヶ月ぐらいはうまく成果がでなくて悩むことも想定しつつ、過去に書いたドキュメントがそういうときの拠り所になる場合もある。</p></div></div><div class="post on-list"><h1 class=post-title><a href=/diary/posts/2022/1106/>メンタリングの学び直し</a></h1><div class=post-meta><span class=post-date>2022-11-06</span></div><span class=post-tags>#<a href=/diary/tags/book/>book</a>&nbsp;
#<a href=/diary/tags/team-building/>team building</a>&nbsp;
#<a href=/diary/tags/life/>life</a>&nbsp;</span><div class=table-of-contents><h2>目次</h2><nav id=TableOfContents><ul><li><a href=#2-1-メンタリングで相手の思考をリファクタリング>2-1. メンタリングで相手の思考をリファクタリング</a></li><li><a href=#ストレッチ>ストレッチ</a></li></ul></nav></div><div class=post-content><p>5時過ぎに寝て10時に起きた。出張で生活のリズムが狂ったまま。</p><h2 id=2-1-メンタリングで相手の思考をリファクタリング>2-1. メンタリングで相手の思考をリファクタリング</h2><p><a href=https://gihyo.jp/book/2018/978-4-7741-9605-3>エンジニアリング組織論への招待</a> のメンタリングの技術の章を読み直すことにした。3年前ぐらいに読んだのであまり覚えてない。私は管理職ではなかったし、若い人に口であれこれ言うのもハラスメントになる懸念から私の働き方をみて役に立つところを盗んでもらえればよいと考えていた。これまでメンタリングには関心がなかった。しかし、いまマネージャーとしての役割で臨む以上は最低限の基礎は抑えた上で取り組む必要があると考え方を改めた。今日は「2-1. メンタリングで相手の思考をリファクタリング」を読んだ。節を簡潔に要約してみる。</p><blockquote><p>メンタリングとは、対話を通じて、思考の幅を広げ、その人の歪んだ認知を補正し、次の行動を促し、成長させる手法である。スキルなので誰でも習得できる。自ら問題を発見し解決することができる <strong>自立型人材</strong> を作るために、信頼関係の上に正のフィードバックループから <strong>自己効力感 (self-efficiency)</strong> を与えられるように働きかける。次の条件を満たさないとメンターの言葉でメンティの行動を自ら変えるようにはならない。</p><ul><li>謙虚: お互いに弱さをみせられる</li><li>経緯: お互いに敬意をもっている</li><li>信頼: お互いにメンティ (自身) の成長期待をもっている</li></ul><p>自らいままでわからなかったことを理解した状況を <strong>自己説得</strong> と呼ぶ。他人が質問で促し、体験を伴い、行動の変化が発生しやすい。メンティが自己説得できる状態になるようメンターは対話で気付きを与えないといけない。悩むと考えるは違う。悩んでいるときは思考がぐるぐると巡り、もやもやした状態。非常に苦しい上に生産的でもない。一方で考えているときはメモ帳やホワイトボードなどに課題を書き出し、分解したり、抽象化したり、具体化したり、、、何かしら行動をとっている状態。次にとるべき行動がはっきりしていれば悩むことはない。メンティが行動できているかどうかを観察し、悩んでいるようならその背景を聞き出して、気付きを与えて考えている状態へ変えていく必要がある。</p></blockquote><h2 id=ストレッチ>ストレッチ</h2><p>今日の開脚幅は開始前154cmで、ストレッチ後159cmだった。東京出張であちこちガタがきていて全身に張りがあったように思う。生活や睡眠が不規則になったことによる疲労もそのままストレッチの窮屈さにつながっているように感じた。毎週ストレッチの機会があって本当に助かっている。ストレッチをした後は体が軽くなって疲労を軽減できているように思う。これまでたまにマッサージへ行って対応していたのが、毎週チェックして手入れできていることの価値がこういうときによくわかるようになってきた。</p></div></div><div class=pagination><div class=pagination__buttons><span class="button previous"><a href=/diary/page/4/><span class=button__icon>←</span>
<span class=button__text>最近の日記</span></a></span>
<span class="button next"><a href=/diary/page/6/><span class=button__text>過去の日記</span>
<span class=button__icon>→</span></a></span></div></div></div></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>© 2021 Tetsuya Morimoto</span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script src=/diary/assets/main.js></script>
<script src=/diary/assets/prism.js></script></div></body></html>