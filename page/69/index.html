<!doctype html><html lang=en><head><meta name=generator content="Hugo 0.109.0"><title>forest nook</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=/diary/><link rel=stylesheet href=/diary/styles.css><link rel=stylesheet href=/diary/style.css><link rel="shortcut icon" href=/diary/favicon.ico><meta name=twitter:card content="summary"><meta name=twitter:site content="t2y"><meta name=twitter:creator content="t2y"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:title" content="forest nook"><meta property="og:description" content><meta property="og:url" content="/diary/"><meta property="og:site_name" content="forest nook"><meta property="og:image" content="/diary/favicon.ico"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><link href=/diary/index.xml rel=alternate type=application/rss+xml title="forest nook"></head><body class=green><div class="container full headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/diary><div class=logo>forest nook</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/diary/about>自己紹介</a></li><li><a href=/diary/dates>月別一覧</a></li><li><a href=/diary/tags>タグ一覧</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/diary/about>自己紹介</a></li><li><a href=/diary/dates>月別一覧</a></li><li><a href=/diary/tags>タグ一覧</a></li></ul></nav></header><div class=content><div class=posts><div class="post on-list"><h1 class=post-title><a href=/diary/posts/2022/0911/>スキルの定量化とお仕事探し</a></h1><div class=post-meta><span class=post-date>2022-09-11 (Sun.)</span></div><span class=post-tags>#<a href=/diary/tags/founding/>founding</a>&nbsp;
#<a href=/diary/tags/career/>career</a>&nbsp;
#<a href=/diary/tags/medium/>medium</a>&nbsp;
#<a href=/diary/tags/management/>management</a>&nbsp;</span><div class=table-of-contents><h2>目次</h2><nav id=TableOfContents><ul><li><a href=#お仕事探し>お仕事探し</a></li><li><a href=#google-の従業員が働いていないという発言の真意>google の従業員が働いていないという発言の真意</a></li></ul></nav></div><div class=post-content><p>0時に寝て7時に起きた。直近は日曜日はだらだらしてたんだけど、すんなり起きれた。</p><h2 id=お仕事探し>お仕事探し</h2><p><a href=/diary/posts/2022/0909/#カジュアル面談>offers さんのカジュアル面談</a> の雰囲気から企業に直接応募するプラットフォームの方が、私の経歴や実績の詳細を確認しやすいので面談に進みやすいのではないかとみている。そこで <a href=https://findy-code.io/>findy</a> と <a href=https://lapras.com/person>lapras</a> のプロフィールを作成してみた。これまで oss 活動やブログなどでアウトプットしていた資産がたくさんあるのでレベルはしょぼいにも関わらず、これらのプラットフォーム上ではそこそこよい数値がアルゴリズム的には算出される。プラットフォーム側としては転職やエンゲージメントを高めたいという意図があるから、ゴーストアカウントのようなものも含めて算出すると普通の人は高めの数字が算出されるのではないかと推測する。</p><blockquote class=twitter-tweet><p lang=ja dir=ltr>やってみた / 【スキル偏差値v2の診断結果】<br><br>エンジニア向けスキル偏差値の診断結果は、Total 81.0、Python 81.0、HTML 80.0、Java 78.0でした。あなたもスキル偏差値をチェックしよう！ <a href=https://t.co/4E4ibyevz0>https://t.co/4E4ibyevz0</a> <a href="https://twitter.com/hashtag/findy?src=hash&ref_src=twsrc%5Etfw">#findy</a> <a href="https://twitter.com/hashtag/%E3%82%B9%E3%82%AD%E3%83%AB%E5%81%8F%E5%B7%AE%E5%80%A4v2?src=hash&ref_src=twsrc%5Etfw">#スキル偏差値v2</a></p>&mdash; Tetsuya Morimoto (@t2y) <a href="https://twitter.com/t2y/status/1568809397673152512?ref_src=twsrc%5Etfw">September 11, 2022</a></blockquote><script async src=https://platform.twitter.com/widgets.js></script><p>findy さんのスキル偏差値によると、想定年収予測は1060-1160万円らしい。この数値は起業する前のサラリーマン時代の年収に近いのでそんなにずれてはいない。<a href=https://lapras.com/public/t2y>lapras さんの公開プロフィール</a> によると、技術力が4.01で約170万人中668位だというのは上位 0.04% に属することになってしまう。んな、あほなという思いはある。とはいえ、自己申告の経歴をいくらでも盛れる職務経歴書よりも、客観的なアルゴリズムで評価できる指標の方が絶対値が適切かは置いておいても、相対評価において他の候補者と比較できるのを好む採用担当者もいるだろう。<a href=/diary/posts/2022/0811/##リモートワーク前提のお仕事>匿名の一般的な職務経歴書を用いる remogu さんの選考</a> は書類選考でばんばん落ちまくる。それに比べたら、アルゴリズムで相対的によい数値が出ているプラットフォームの方が面談に進みやすいのではないかという話し。本当にそうかどうかの仮説はこれから検証する。</p><h2 id=google-の従業員が働いていないという発言の真意>google の従業員が働いていないという発言の真意</h2><p>昨日たまたま medium のダイジェストでみかけた記事を読んだらおもしろかったので、なるべく余裕のある日は medium の記事を1つ読むようにしてみようかと思う。言うても deepl を使って斜め読みして大意を掴む程度なので日本語の記事を読むのとそんなに時間が取られるわけではないと思う。今日は次の記事を読んだ。</p><ul><li><a href=https://levelup.gitconnected.com/why-google-employees-dont-work-f6a7521a6ed6>Why Google Employees Don’t Work</a></li></ul><p>プログラミングにおける生産性とはどういうものかを説明しつつ、google の ceo がいう生産性が十分ではないという発言の真意は、従業員が業務時間にさぼっているとか怠慢だとかいう意味ではなく、google のビジネス全体がこれまで達成してきたのと同じ業務時間では期待した成果を達成できなくなってきているのではないかと考察している。</p><blockquote><p>At some point, productivity measurement becomes Schrödinger’s cat.</p></blockquote><p>また著者の引用？では生産性の計測とはシュレディンガーの猫のようなものだという話題もおもしろい。どんな会社もある時点での生産性の測定はシュレディンガーの猫のようなものになる。セグメントを分割し過ぎると返ってストレスとなり、余計な混乱を招き、計測そのものが生産性を低下させる。生産性の測定はマクロレベルでやるのが理に適っていて、工場時代のマネジメントをもつ amazon は大量の人員削減をしつつも成し遂げた。google のようなワークカルチャーをもつ会社ならその気になればスマートにできるだろう。一方で google という会社はすでにリベラルな極みにある企業文化をもっているため、生産性を測るような試みは組織全体に大きな感情的ダメージを与えるだろう。その結果として amazon と同じような道を歩むのではないかと。</p><p>シュレディンガーの猫がどういう意味かもわからなくてそれも読んでた。</p><ul><li><a href=https://nazology.net/archives/107875>「シュレーディンガーの猫」って結局どういう話なの？モヤモヤする部分を解説！</a></li></ul></div></div><div class="post on-list"><h1 class=post-title><a href=/diary/posts/2022/0910/>キャリアは知識と経験の差分でわかる</a></h1><div class=post-meta><span class=post-date>2022-09-10 (Sat.)</span></div><span class=post-tags>#<a href=/diary/tags/life/>life</a>&nbsp;
#<a href=/diary/tags/medium/>medium</a>&nbsp;
#<a href=/diary/tags/programming/>programming</a>&nbsp;
#<a href=/diary/tags/information-exchange/>information exchange</a>&nbsp;</span><div class=table-of-contents><h2>目次</h2><nav id=TableOfContents><ul><li><a href=#ストレッチ>ストレッチ</a></li><li><a href=#知識と経験>知識と経験</a></li></ul></nav></div><div class=post-content><p>23時に寝て2時に起きてその後どうしていたかあまり覚えていないが気付いたら8時だった。</p><h2 id=ストレッチ>ストレッチ</h2><p>今日の開脚幅は開始前160cmで、ストレッチ後163cmだった。今週も全然ストレッチできなかったのになぜか数値はよくなっていた。ストレッチを受けていて調子の悪さも感じなかったので気候が過ごしやすくなってきて体調がよくなった結果として普段の生活における活動量や新陳代謝などにも影響を与えているのかもしれない。トレーナーさんからは涼しくなったのだから運動をしてくださいと言われた。ほんとその通り。</p><h2 id=知識と経験>知識と経験</h2><ul><li><a href=https://medium.com/vanguards-of-code/youre-not-a-senior-software-engineer-9056ef9ffb96>You’re Not a Senior Software Engineer</a></li></ul><p>たまたま目を通した medium のおすすめ記事に出ていて、タイトルにひかれて斜め読みしたらおもしろかったので後で deepl を使って精読した。最近は英語の記事を deepl で訳して読んでいる。まず deepl で全訳した後に文脈から訳文の意味をとれなかったり、明らかにおかしいところだけを手直しする。著作権的に機械翻訳を公開はできないため、その翻訳内容は課題管理システムのイシューで管理している。この記事だと手直し数回ぐらいで大意を読める。普段、英語の記事を日本語アカウントで紹介することはないんだけど、これは素晴らしい内容だったのでそのまま共有することにした。軽く所感も書いてあるが、課題管理システムのイシューにはさらに詳細な分析やコメントも残している。</p><blockquote class=twitter-tweet><p lang=ja dir=ltr>知識とはやり方を知っていることで、経験とはやってはいけないことを知っていること。素晴らしい記事だった。 / You’re Not a Senior Software Engineer by @repsofsunshine <a href=https://t.co/3qitFOFTJp>https://t.co/3qitFOFTJp</a></p>&mdash; Tetsuya Morimoto (@t2y) <a href="https://twitter.com/t2y/status/1568471581961388034?ref_src=twsrc%5Etfw">September 10, 2022</a></blockquote><script async src=https://platform.twitter.com/widgets.js></script><p>多くの若いチームでは課題管理の重要性を理解していない。その無理解の原因の1つとして、ものごとを検討したり判断したりした時点では正しかったことが未来のある時点で誤りになってしまう可能性を想像できないからだと私は考えている。記憶と忘却の仕組みから前日のことですら半分以上忘れてしまうので数ヶ月前の詳細など、ほとんどの人は覚えていない。にも関わらず、日々の小さい判断の積み重ねや意思決定の履歴を記録として残さないのはなぜだろうか？それはその詳細があとで重要になるかどうか、多くのケースでその発生時点ではわからないからだ。例えば、システムのアーキテクチャに関して言えば <a href=https://adr.github.io/>Architectural Decision Records (ADRs)</a> というドキュメントが提唱されている。アーキテクチャのような大きなものでさえ、明示的に残さないと経緯がわからなくなるのに、もっと小さい粒度である日々の開発や運用の誤りを、一般の (普通の) 開発者がその発生時点から数ヶ月や数年経ってふりかえって見直すことができるだろうか？いやできないというのが、多くのチームやメンバーをみてきた私の所感だ。多くのメンバーは過去のある時点の見逃しや判断ミスをなかったことにしようとする。それは無意識にしろ意識的にしろ起きやすい。客観的に詳細を確認できればなかったことになってしまうのは仕方のないことでもある。</p><p>私は課題管理システムのコメントに、こういう状況からこう判断したとか、誰それと相談してこういう事情でそうしたとか、自身の感覚からとくに意味もなく決めたとか、常々なぜに相当する内容を残している。そして、あるとき過去の経緯を見返して、そのときの判断は適切だったか、過去のある時点で気付けたはずのことを見逃してなかったか、見逃していたとすればどうすればその時に気付きを得られたか、というふりかえりを日常的なチケット整理の一環として実践している。件の medium の記事にはなぜそれが重要なのかの概念を書いてあるように私には受け取れた。課題管理 + 情報共有の需要な概念の1つだと認識して寝かせておこうと思う。</p></div></div><div class="post on-list"><h1 class=post-title><a href=/diary/posts/2022/0909/>若い会社とのエンゲージメントを図る</a></h1><div class=post-meta><span class=post-date>2022-09-09 (Fri.)</span></div><span class=post-tags>#<a href=/diary/tags/founding/>founding</a>&nbsp;
#<a href=/diary/tags/career/>career</a>&nbsp;</span><div class=table-of-contents><h2>目次</h2><nav id=TableOfContents><ul><li><a href=#カジュアル面談>カジュアル面談</a></li></ul></nav></div><div class=post-content><p>23時に寝て5時だと思って3時に起きてそのまま家事をやって5時から働いてた。早起きすると暇つぶしのように溜まっているタスクをこなし始めるので早起きは三文の得というのは本当だ。非稼働日だけど、午前中に次のタスクの要件のヒアリングだけやっといて、月曜日の朝一から作業できるように調整しておこうと考えたが、今日は開発リーダーが休みだったので何もしなかった。</p><h2 id=カジュアル面談>カジュアル面談</h2><p><a href=/diary/posts/2022/0901/#次のお仕事探し>Offers というサービス</a> でみつけた会社にカジュアル面談を申し込んでいた。エンジニアリングマネージャーを業務委託で募集しているのは珍しかったのでその背景などを聞いてた。面談してくれた方はテックリードと言っていたが、この人も副業で手伝っているらしい。雰囲気的に若い会社のようで正社員はほとんどいなくてチームのメンバーが10人ぐらいのうち正社員が1-2名だという。基本的に外部の寄せ集めメンバーがそれぞれ副業や業務委託で空き時間を使って開発しているといった話らしい。8時間/週といった契約のメンバーもいるとのこと。どんな人を採用するにしてもまず業務委託から始めるというのがその会社の方針らしい。信頼関係という視点からみると、このような経営者にとって都合がよい労使関係を嫌う人もいるのではないかと思う。一方で私は雇う側も働く側もお互いにマッチングしないときの不幸を防ぐには1-3ヶ月ぐらい働いてからお互いに望むときに採用するといったやり方の方がよいと考えている。実際にマッチングしない人の場合は1週間で見切りをつけるとかあるらしい。私自身、初めてお手伝いする会社は最初の3ヶ月とかは1ヶ月契約でも構わないと伝えることがよくある。その後、お互いにマッチングするなら3-6ヶ月の契約期間に延長したいと交渉する。20年働いてきて、過去に試用期間で解雇されたことや1ヶ月で即解約になったことはないので一定の自信もある。</p><p>テックリードが若かったので組織もチームもメンバーも若いのだろうという印象を受けた。業務的にはお互いにマッチングしているように私からは思えた。あとは単純にテックリードが話してみた感覚や相性で私のようなベテランを求めているかどうかで次の選考の有無が決まるのではないかと推測する。次があったら正社員の人とも話してみたい。</p></div></div><div class="post on-list"><h1 class=post-title><a href=/diary/posts/2022/0908/>v-data-table のカラムのソートがよくわからない</a></h1><div class=post-meta><span class=post-date>2022-09-08 (Thu.)</span></div><span class=post-tags>#<a href=/diary/tags/vue.js/>vue.js</a>&nbsp;</span><div class=table-of-contents><h2>目次</h2><nav id=TableOfContents><ul><li><a href=#画面周りのリファクタリング>画面周りのリファクタリング</a></li></ul></nav></div><div class=post-content><p>23時に寝て3時に起きて軽く apple イベントをみて寝て6時に起きた。</p><h2 id=画面周りのリファクタリング>画面周りのリファクタリング</h2><p>週明けに私が作った画面が本番環境にリリースされて運用を経てフィードバックが返ってきた。主には使い勝手の改善や要望だけど、何にしても実際に使ってもらってフォードバックがくるのは楽しい。丸1日リファクタリングしていて要望があったものはすべて改善できた。インフラ・バッチ処理、サーバーサイド、フロントエンドのすべてを担当しているから私が関わっているところなら適材適所にリファクタリングできる。システム全体を通してやりたいことを独力でできると楽しい。これは人間の独占欲や支配欲を刺激する。おそらくマズローの欲求でも高次の欲求に属するのだと思う。</p><p>v-data-table の <a href=https://vuetifyjs.com/en/api/v-data-table/#props-headers>props headers</a> でカラムの値に対してソートができる。ソート可能に設定すればあとは自動的にやってくれるのかと思いきや、自分で key function を実装しないとソートはされるけど正しい並び順にはならない。key functoin の返り値が number なので -1, 0, 1 の値でソートの入れ替えを実現しているようにみえる。javascript は true => 1, false => 0 と評価されるので単純な比較演算の結果からは意図したソートにならないからではないかと推測する。このやり方が正しい実装かはわからないけど、次のような key function を定義してあげることでソートを実行したときに意図した並び順になることを確認した。すべてのカラムにこんな実装書くの？というところに懸念はある。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>value</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;date&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>sortable</span>: <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>sort</span><span style=color:#f92672>:</span> (<span style=color:#a6e22e>x</span>: <span style=color:#66d9ef>Date</span>, <span style=color:#a6e22e>y</span>: <span style=color:#66d9ef>Date</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>y</span> <span style=color:#f92672>?</span> <span style=color:#f92672>-</span><span style=color:#a6e22e>1</span> : <span style=color:#66d9ef>1</span>;
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>},
</span></span></code></pre></div></div></div><div class="post on-list"><h1 class=post-title><a href=/diary/posts/2022/0907/>ドキュメントを書きながら思うこと</a></h1><div class=post-meta><span class=post-date>2022-09-07 (Wed.)</span></div><span class=post-tags>#<a href=/diary/tags/github/>github</a>&nbsp;
#<a href=/diary/tags/document/>document</a>&nbsp;</span><div class=table-of-contents><h2>目次</h2><nav id=TableOfContents><ul><li><a href=#github-リポジトリとシステム間連携>github リポジトリとシステム間連携</a></li></ul></nav></div><div class=post-content><p>3時に寝て7時に起きた。眠れない。</p><h2 id=github-リポジトリとシステム間連携>github リポジトリとシステム間連携</h2><p>社員さんが運用対応に忙しくてスプリントタスクがなくなって暇なのでドキュメントを書いてた。github に新規リポジトリを作成したときに行う初期設定の作業が増えてきた。大半は私が導入した仕組みや機能のための初期設定になるが、私はリポジトリの管理権限をもっていないので、社員さんにお願いして、この設定して、あの設定してとお願いして対応してきた。もうすぐ辞めるので引き継ぎできるようにやっていることのドキュメントを整理した。</p><ul><li>slack 連携</li><li>backlog 連携</li><li>github<ul><li>pull requests テンプレート</li><li>github actions<ul><li>github apps</li><li>github environments</li></ul></li></ul></li></ul><p>リポジトリと他システムとの連携を効率化しようとすればするほど設定や背景が煩雑になる。とくに認証や権限周りのセキュリティを考慮した仕組みはサービスとのトレードオフになるので設定が面倒になりがちではある。とくに github actions のワークフローは <a href=https://note.com/hoshino_technote/n/n6afff42aeee0>【登壇報告】JJUG CCC 2022 Spring で語りきれなかった技術的なお話</a> にあるように、世の中のプラクティスに依らず、私が設計して整備したものなので他メンバーにとって身近ではない。</p><p>backlog の wiki にプロジェクトのドキュメントを書いている。開発メンバーでドキュメントを定期的に書くのはほぼ私だけで、他メンバーはほとんど書かない。なぜそうなるのかな？と考えたときに思いつくことの1つとして、開発全般の業務としてやることを、誰でもできる汎用的な仕組みに落とし込むことを考慮して設計していないからではないかと思う。あるアプリケーションが内製／外部システム／外部ライブラリに関わらず、こういう機能や仕組みを使って、こんな課題を解決して、こんな機能を実現していますという構成にはなっていない。発生している問題に対して動けばいいといったレベルでしか開発していないから、本来どう在るべきなのか、どういった設計思想なのか、今後はどうやって保守していけばいいのかの指針を提供できない。これは私の言葉だと設計ができないということと同義だと思う。他に思いつくこととしては、既存アプリケーションにない新規の仕組みを定期的に設計しているのは私しかいないのかもしれない。言い換えれば、言われたことしかやらない人しかいない。</p></div></div><div class="post on-list"><h1 class=post-title><a href=/diary/posts/2022/0906/>スクラムやっている人たちと雑談</a></h1><div class=post-meta><span class=post-date>2022-09-06 (Tue.)</span></div><span class=post-tags>#<a href=/diary/tags/scrum/>scrum</a>&nbsp;
#<a href=/diary/tags/event/>event</a>&nbsp;</span><div class=table-of-contents><h2>目次</h2><nav id=TableOfContents><ul><li><a href=#スクラムイベント>スクラムイベント</a></li></ul></nav></div><div class=post-content><p>0時に寝て7時に起きた。あまりよく眠れない。新しい施設のサービスインで社員さんは忙しそうなので画面のバグ修正をしたりレビューの検証をしたりしていた。</p><h2 id=スクラムイベント>スクラムイベント</h2><p><a href=https://smn.connpass.com/event/258253/>Scrum Developers Night! Online #11</a> に参加した。過去にストーリーポイント運用がうまくいってないという話題を書いてきたけど、他の組織やチームだとうまくいっているのか、どんな感じなのかを聞いてみようという意図で参加した。他のスクラムやっている人たちの話しを聞いてみたかったんだけど、割とこっちのやり方や運用を聞かれるような展開になったのでこちら側の話しが主になってしまった。相談してわかったことなどをざっくりまとめる。</p><ul><li>ストーリーポイント運用の方法自体は間違っていない<ul><li>ストーリーポイント運用とは別のところに課題があるようにみえる</li></ul></li><li>スプリントで決めたことをできないのは問題<ul><li>1週間の見積もりすら合わないのだからそれ以上の期間の見積もりはあわないのは自明</li></ul></li><li>プランニングやリファイメントなどでタスク分割や見積もりの精度をあげないといけない<ul><li>大きな機能の見積もり後にタスクが増えるような精度が問題</li></ul></li><li>スプリントがある週の実稼働時間を考慮して見積もりしていないのは問題<ul><li>休みがあったり社内イベントがあったり実稼働時間によってベロシティはブレるはず</li></ul></li></ul><p>全体として総括すると、ストーリーポイント運用以前に、チームの問題が大きいのだろうと他の人たちと話していて実感した。スクラムの実践についての細かい改善点はあるものの、それ以上にチーム事情によるものや体制の問題の方が大きいということに気付いた。</p></div></div><div class="post on-list"><h1 class=post-title><a href=/diary/posts/2022/0905/>レンダリングの致命的なバグ</a></h1><div class=post-meta><span class=post-date>2022-09-05 (Mon.)</span></div><span class=post-tags>#<a href=/diary/tags/vue.js/>vue.js</a>&nbsp;</span><div class=table-of-contents><h2>目次</h2><nav id=TableOfContents><ul><li><a href=#vuejs-のライフサイクル>vuejs のライフサイクル</a></li></ul></nav></div><div class=post-content><p>0時に寝て6時に起きた。</p><h2 id=vuejs-のライフサイクル>vuejs のライフサイクル</h2><p>先日 vuejs で <a href=/diary/posts/2022/0831/#バッチ処理一覧と手動実行>画面作り</a> に挑戦して出来たと喜んでいたが、検索して一覧画面のデータを更新した際に、フォームも再レンダリングされないといけないところがそうなっておらず、データは置き換わっているが画面に表示される値は変わっていないという致命的なバグがあることに気付いた。普通に開発していたら気付きそうなものだが、ローカルの dev server で動かしているとコードを更新すると再レンダリングが実行されるので検索後に画面の一覧が更新されないということを見逃したんだと思う。<a href=https://v2.vuejs.org/v2/guide/instance.html#Lifecycle-Diagram>Lifecycle Diagram</a> もみながら適切なフックポイントの振る舞いを確認したりしていた。setup 後、初期化されてその後に <em>mounted</em> が動いて、その後パラメーターが更新されたときに watch して再更新をかけるといった次のコードでも意図した振る舞いになることは確認した。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span>  <span style=color:#a6e22e>setup</span>(<span style=color:#a6e22e>props</span>, <span style=color:#a6e22e>context</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>data</span><span style=color:#f92672>:</span> { [<span style=color:#a6e22e>key</span>: <span style=color:#66d9ef>string</span>]<span style=color:#f92672>:</span> <span style=color:#66d9ef>any</span> } <span style=color:#f92672>=</span> {};
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> { <span style=color:#a6e22e>_data</span>: <span style=color:#66d9ef>ref</span>(<span style=color:#a6e22e>data</span>), <span style=color:#a6e22e>loading</span>: <span style=color:#66d9ef>false</span> };
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>mounted() {</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>_data</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>JSON</span>.<span style=color:#a6e22e>parse</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>item</span>.<span style=color:#a6e22e>data</span>);
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>watch</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>item</span>(<span style=color:#a6e22e>value</span>: <span style=color:#66d9ef>any</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>_data</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>JSON</span>.<span style=color:#a6e22e>parse</span>(<span style=color:#a6e22e>value</span>.<span style=color:#a6e22e>data</span>);
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>  },
</span></span></code></pre></div><p>レビューしてもらったら、それよりもパラメーターをリアクティブにした方がよいのではないかと教えてもらって次のようにした。本当は setter は不要なんだけど、なぜか初期化のタイミングで setter が呼ばれるので設けた。私の作ったコンポーネントの設計が悪いせいかもしれない。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span>  <span style=color:#a6e22e>setup</span>(<span style=color:#a6e22e>props</span>, <span style=color:#a6e22e>context</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>_item</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>toRef</span>(<span style=color:#a6e22e>props</span>, <span style=color:#e6db74>&#39;item&#39;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> { <span style=color:#a6e22e>_item</span> };
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>computed</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>￼</span>   <span style=color:#a6e22e>_data</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>￼</span>     <span style=color:#66d9ef>get</span>()<span style=color:#f92672>:</span> { [<span style=color:#a6e22e>key</span>: <span style=color:#66d9ef>string</span>]<span style=color:#f92672>:</span> <span style=color:#66d9ef>any</span> } {
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>￼</span>       <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>JSON</span>.<span style=color:#a6e22e>parse</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>_item</span>.<span style=color:#a6e22e>data</span>);
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>￼</span>     },
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>￼</span>     <span style=color:#66d9ef>set</span>(<span style=color:#a6e22e>value</span>: <span style=color:#66d9ef>any</span>) {
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>￼</span>       <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>$emit</span>(<span style=color:#e6db74>&#39;update:_data&#39;</span>, <span style=color:#a6e22e>value</span>);
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>￼</span>     },
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>  },
</span></span></code></pre></div><p>これは vue2 の <strong>Options API</strong> と呼ばれる記法で、vue3 だと <strong>Composition API</strong> を使って次のような書き方ができるというのも教えてもらった。getter だけなら Composition API でもよさそうだけど、setter もあるとこのコードはまったく簡潔じゃないなと思って Options API を使うことにした。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span>  <span style=color:#a6e22e>setup</span>(<span style=color:#a6e22e>props</span>, <span style=color:#a6e22e>context</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>_item</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>toRef</span>(<span style=color:#a6e22e>props</span>, <span style=color:#e6db74>&#39;item&#39;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>_data</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>computed</span>({
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>get</span><span style=color:#f92672>:</span> () <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>JSON</span>.<span style=color:#a6e22e>parse</span>(<span style=color:#a6e22e>_item</span>.<span style=color:#a6e22e>value</span>.<span style=color:#a6e22e>data</span>),
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>set</span><span style=color:#f92672>:</span> (<span style=color:#a6e22e>value</span>: <span style=color:#66d9ef>any</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>$emit</span>(<span style=color:#e6db74>&#39;update:_data&#39;</span>, <span style=color:#a6e22e>value</span>),
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> { <span style=color:#a6e22e>_item</span>, <span style=color:#a6e22e>_data</span> };
</span></span><span style=display:flex><span>  },
</span></span></code></pre></div></div></div><div class=pagination><div class=pagination__buttons><a href=/diary/page/68/ class="button previous"><span class=button__icon>←</span>
<span class=button__text>最近の日記</span></a>
<a href=/diary/page/70/ class="button next"><span class=button__text>過去の日記</span>
<span class=button__icon>→</span></a></div></div></div></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>© 2021 Tetsuya Morimoto</span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script type=text/javascript src=/diary/bundle.min.js></script></div></body></html>