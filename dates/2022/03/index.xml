<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>2022/03 on forest nook</title><link>/diary/dates/2022/03/</link><description>Recent content in 2022/03 on forest nook</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><copyright>© 2021 Tetsuya Morimoto</copyright><atom:icon>/diary/favicon.ico</atom:icon><icon>/diary/favicon.ico</icon><atom:link href="/diary/dates/2022/03/index.xml" rel="self" type="application/rss+xml"/><item><title>リーン思考？</title><link>/diary/posts/2022/0309/</link><pubDate>Wed, 09 Mar 2022 07:43:01 +0900</pubDate><guid>/diary/posts/2022/0309/</guid><description>0時に寝て5時半頃に起きて6時半に起きた。
リーン思考 スクラムのふりかえりをしていて、スクラムマスターがふとスクラムっぽいものとスクラムとの違いの1つとしてリーン思考の有無をあげた。私がリーン思考というのを知らなかったので軽く調べてみた。
リーン思考とモジュラー化を実現するための3ステップ リーン思考とは？
リーンという考え方は、ムダを最小限に抑えつつ、顧客価値を最大化することです。そのためには、ムダを削除・削減させるような構造化された「働き方」と、それを継続的に改善し続けることが必要です。つまり、リーンな組織というのは顧客が何に価値を感じているのかを理解しており、継続的な価値向上に繋がるプロセスに注力するものです。繰り返しとなりますが、究極の目標は、ムダゼロな完璧なプロセスを通して、顧客に最大限の価値を提供することです。
引用しておいてなんだが、「リーン思考とは」と節を書いているのに直接な定義を最初に書かない文章は読みにくい。要約すると、リーンという概念を組織として理解していて実践していく考え方や心の動きをリーン思考と呼ぶのだろうか？スクラムマスターがリーン思考が足りないとか言っていたけど、あまりピンとこない。というのは、スクラムマスターは基本的に言うだけで実践はすべて現場に丸投げ。リーン思考が足りないというだけなら誰でも言えるが、日々の具体的な活動や実践にどう落とし込むのかを示さないので現場のメンバーにはあまり響かない。リーダーシップにもいろんなタイプがあると思うが、実践は実践力をみせつけてフォロワーがついてくる。とくに抽象的なよくわからない概念をビジョナリーが提唱するだけではなにも変わらない。
私自身がリーン思考を意識したことはないが、課題管理に関して開発のワークフローを最適化するというのはある種のリーン思考とも言える。チケットのワークフローが洗練すれば洗練するほど効率がよくなってイテレーションのサイクルが多くまわり、結果として価値が速くユーザーに届いたり、試行錯誤の改善が早くなる。キーワードとして一応は覚えておく。</description><content>&lt;p>0時に寝て5時半頃に起きて6時半に起きた。&lt;/p>
&lt;h2 id="リーン思考">リーン思考&lt;/h2>
&lt;p>スクラムのふりかえりをしていて、スクラムマスターがふとスクラムっぽいものとスクラムとの違いの1つとしてリーン思考の有無をあげた。私がリーン思考というのを知らなかったので軽く調べてみた。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.modularmanagement.com/ja/blog/%E3%83%AA%E3%83%BC%E3%83%B3%E6%80%9D%E8%80%83%E3%81%A8%E3%83%A2%E3%82%B8%E3%83%A5%E3%83%A9%E3%83%BC%E5%8C%96%E3%82%92%E3%81%99%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AE3%E3%82%B9%E3%83%86%E3%83%83%E3%83%97">リーン思考とモジュラー化を実現するための3ステップ&lt;/a>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>リーン思考とは？&lt;/p>
&lt;p>リーンという考え方は、ムダを最小限に抑えつつ、顧客価値を最大化することです。そのためには、ムダを削除・削減させるような構造化された「働き方」と、それを継続的に改善し続けることが必要です。つまり、リーンな組織というのは顧客が何に価値を感じているのかを理解しており、継続的な価値向上に繋がるプロセスに注力するものです。繰り返しとなりますが、究極の目標は、ムダゼロな完璧なプロセスを通して、顧客に最大限の価値を提供することです。&lt;/p>
&lt;/blockquote>
&lt;p>引用しておいてなんだが、「リーン思考とは」と節を書いているのに直接な定義を最初に書かない文章は読みにくい。要約すると、リーンという概念を組織として理解していて実践していく考え方や心の動きをリーン思考と呼ぶのだろうか？スクラムマスターがリーン思考が足りないとか言っていたけど、あまりピンとこない。というのは、スクラムマスターは基本的に言うだけで実践はすべて現場に丸投げ。リーン思考が足りないというだけなら誰でも言えるが、日々の具体的な活動や実践にどう落とし込むのかを示さないので現場のメンバーにはあまり響かない。リーダーシップにもいろんなタイプがあると思うが、実践は実践力をみせつけてフォロワーがついてくる。とくに抽象的なよくわからない概念をビジョナリーが提唱するだけではなにも変わらない。&lt;/p>
&lt;p>私自身がリーン思考を意識したことはないが、課題管理に関して開発のワークフローを最適化するというのはある種のリーン思考とも言える。チケットのワークフローが洗練すれば洗練するほど効率がよくなってイテレーションのサイクルが多くまわり、結果として価値が速くユーザーに届いたり、試行錯誤の改善が早くなる。キーワードとして一応は覚えておく。&lt;/p></content></item><item><title>デプロイ改善の成果まとめ</title><link>/diary/posts/2022/0308/</link><pubDate>Tue, 08 Mar 2022 06:24:20 +0900</pubDate><guid>/diary/posts/2022/0308/</guid><description>23時に寝て5時過ぎに起きた。何度か途中で起きたけど、久しぶりによく寝た。前日あまり寝てなかったから19時過ぎには帰ってきてだらだらしてた。
もてなしだけではもう食えない 業界研究を兼ねて もてなしだけではもう食えない -ホテル経営学の本質と実践- を読み始めた。同じ出版社の週刊ホテルレストランという雑誌の連載を書籍化したものらしい。著者は立教大学で社会人向けビジネススクールでホテルマネジメントとホテルインベストメントを教えているらしい。ビジネスの堅い話しを小説調にすれば読みやすいんじゃないかみたいな取り組みなのかな？よくわかてないけど、小説仕立てで業界研究ができるような書籍になっているらしい。第1章プロローグと第2章腐りやすい在庫を読んだ。実際の現場でこんな仕事できない人が改革チームのリーダーなんかになったりしないなと思いながら読んでた。そこは本題じゃない！コンサルティングでありそうな経営の話しが出てくるのでうちの会社の経営の勉強にもなるかもしれない。少しずつ読んでいく。
デプロイ改善の成果 水曜日がすくらむのふりかえりイベントがあるのでそれに間に合わせて簡単にまとめの資料を作った。3スプリント (3週間) もかけて抜本的に開発のワークフローからビルド/デプロイの ci/cd を見直したので開発全般に影響を与えた。
本番環境デプロイ: 実行時間を約72%の短縮 テスト環境デプロイ: 実行時間を約51%の短縮 hotfix デプロイ: 実行時間を約64%の短縮 そもそも従来のやり方では hotfix を出していないので机上の時間ではあるが 単純に github actions の実行時間だけ比較しても速くなっているのだけど、それ以上にブランチ戦略を大きく変えた。従来は3つのブランチで運用していた。
develop test main これを1つのブランチのみで運用できるように開発のワークフローを刷新した。ブランチが1つしかないので ci/cd の戦略もシンプルになって、変則的な運用 (hotfix を出したいとか) をしても、開発全体に影響を与えない。「誰か勝手にブランチを作ってデプロイして」で終わる。従来のやり方は3つのブランチが開発ワークフローと ci/cd に密接であったために本番環境のリリースするときは開発すべてが止まってしまう状態だった。週1回のリリースだったので本番リリース前の1-2日は PR のレビューやマージを止めているという運用になっていた。それは開発速度に大きな影響を与えていた。ブランチ戦略を見直したことでいつでも本番環境にデプロイできるようになって、継続的デリバリーっぽいことがやりたかったらできるよという話しをした。</description><content>&lt;p>23時に寝て5時過ぎに起きた。何度か途中で起きたけど、久しぶりによく寝た。前日あまり寝てなかったから19時過ぎには帰ってきてだらだらしてた。&lt;/p>
&lt;h2 id="もてなしだけではもう食えない">もてなしだけではもう食えない&lt;/h2>
&lt;p>業界研究を兼ねて &lt;a href="https://ec.hoteresonline.com/products/detail.php?product_id=262">もてなしだけではもう食えない -ホテル経営学の本質と実践-&lt;/a> を読み始めた。同じ出版社の週刊ホテルレストランという雑誌の連載を書籍化したものらしい。著者は立教大学で社会人向けビジネススクールでホテルマネジメントとホテルインベストメントを教えているらしい。ビジネスの堅い話しを小説調にすれば読みやすいんじゃないかみたいな取り組みなのかな？よくわかてないけど、小説仕立てで業界研究ができるような書籍になっているらしい。第1章プロローグと第2章腐りやすい在庫を読んだ。実際の現場でこんな仕事できない人が改革チームのリーダーなんかになったりしないなと思いながら読んでた。そこは本題じゃない！コンサルティングでありそうな経営の話しが出てくるのでうちの会社の経営の勉強にもなるかもしれない。少しずつ読んでいく。&lt;/p>
&lt;h2 id="デプロイ改善の成果">デプロイ改善の成果&lt;/h2>
&lt;p>水曜日がすくらむのふりかえりイベントがあるのでそれに間に合わせて簡単にまとめの資料を作った。3スプリント (3週間) もかけて抜本的に開発のワークフローからビルド/デプロイの ci/cd を見直したので開発全般に影響を与えた。&lt;/p>
&lt;ul>
&lt;li>本番環境デプロイ: 実行時間を約72%の短縮&lt;/li>
&lt;li>テスト環境デプロイ: 実行時間を約51%の短縮&lt;/li>
&lt;li>hotfix デプロイ: 実行時間を約64%の短縮
&lt;ul>
&lt;li>そもそも従来のやり方では hotfix を出していないので机上の時間ではあるが&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>単純に github actions の実行時間だけ比較しても速くなっているのだけど、それ以上にブランチ戦略を大きく変えた。従来は3つのブランチで運用していた。&lt;/p>
&lt;ul>
&lt;li>develop&lt;/li>
&lt;li>test&lt;/li>
&lt;li>main&lt;/li>
&lt;/ul>
&lt;p>これを1つのブランチのみで運用できるように開発のワークフローを刷新した。ブランチが1つしかないので ci/cd の戦略もシンプルになって、変則的な運用 (hotfix を出したいとか) をしても、開発全体に影響を与えない。「誰か勝手にブランチを作ってデプロイして」で終わる。従来のやり方は3つのブランチが開発ワークフローと ci/cd に密接であったために本番環境のリリースするときは開発すべてが止まってしまう状態だった。週1回のリリースだったので本番リリース前の1-2日は PR のレビューやマージを止めているという運用になっていた。それは開発速度に大きな影響を与えていた。ブランチ戦略を見直したことでいつでも本番環境にデプロイできるようになって、継続的デリバリーっぽいことがやりたかったらできるよという話しをした。&lt;/p></content></item><item><title>ワークフローの移行説明</title><link>/diary/posts/2022/0307/</link><pubDate>Mon, 07 Mar 2022 08:11:25 +0900</pubDate><guid>/diary/posts/2022/0307/</guid><description>3時に寝て6時半に起きた。朝起きたら github actions のリソース上限に達しているという連絡が slack に書き込まれていて週末に移行作業して1500分ぐらいは浪費しましたと事後報告した。
ワークフロー移行後の説明 週末に移行した新しい ci/cd の仕組みを開発者に説明した。開発のワークフローも大きく変わる。いくつか要望をもらいつつ、とくに混乱も誤解もなく受け入れられた。github actions の管理画面からボタンでデプロイ実行できるため、本番環境にデプロイできるユーザーは制限したいと言われて次のようなステップを追加した。
- name: デプロイユーザーを確認 if: ${{ env.DEPLOYMENT_ENV == &amp;#39;prod&amp;#39; }} run: |[[ &amp;#34;${{ contains(fromJSON(env.DEPLOYABLE_USERS), github.actor) }}&amp;#34; == &amp;#34;true&amp;#34; ]] &amp;amp;&amp;amp; exit 0 echo &amp;#34;デプロイ権限のあるユーザーではありません&amp;#34; exit 1 env: DEPLOYABLE_USERS: &amp;#39;[&amp;#34;user1&amp;#34;, &amp;#34;user2&amp;#34;, &amp;#34;app-bot&amp;#34;]&amp;#39; expressions の Functions に組み込みの関数がいくつか紹介されている。それらを組み合わせるとうまくいきそうと思って書いてみた。たしかにちょっと楽に実装はできるけど、github actions の expression とシェルの文字列との境界が、yaml のコード上では曖昧なため、真偽値などはとくにわかりにくい。例えば、次のコード。
[[ &amp;#34;${{ contains(fromJSON(env.DEPLOYABLE_USERS), github.actor) }}&amp;#34; == &amp;#34;true&amp;#34; ]] ${{ ... }} で囲まれたところは github の expression なので boolean として評価できるが、それをシェルにもってくると文字列になってしまうので文字列で比較しないといけない。普通にコードを書いていて気づきにくいので実行して振る舞いを検証しないと間違うみたいな話し。</description><content>&lt;p>3時に寝て6時半に起きた。朝起きたら github actions のリソース上限に達しているという連絡が slack に書き込まれていて週末に移行作業して1500分ぐらいは浪費しましたと事後報告した。&lt;/p>
&lt;h2 id="ワークフロー移行後の説明">ワークフロー移行後の説明&lt;/h2>
&lt;p>週末に移行した新しい ci/cd の仕組みを開発者に説明した。開発のワークフローも大きく変わる。いくつか要望をもらいつつ、とくに混乱も誤解もなく受け入れられた。github actions の管理画面からボタンでデプロイ実行できるため、本番環境にデプロイできるユーザーは制限したいと言われて次のようなステップを追加した。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yml" data-lang="yml">- &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">デプロイユーザーを確認&lt;/span>
&lt;span style="color:#f92672">if&lt;/span>: &lt;span style="color:#ae81ff">${{ env.DEPLOYMENT_ENV == &amp;#39;prod&amp;#39; }}&lt;/span>
&lt;span style="color:#f92672">run&lt;/span>: |&lt;span style="color:#e6db74">
&lt;/span>&lt;span style="color:#e6db74"> [[ &amp;#34;${{ contains(fromJSON(env.DEPLOYABLE_USERS), github.actor) }}&amp;#34; == &amp;#34;true&amp;#34; ]] &amp;amp;&amp;amp; exit 0
&lt;/span>&lt;span style="color:#e6db74"> echo &amp;#34;デプロイ権限のあるユーザーではありません&amp;#34;
&lt;/span>&lt;span style="color:#e6db74"> exit 1&lt;/span>
&lt;span style="color:#f92672">env&lt;/span>:
&lt;span style="color:#f92672">DEPLOYABLE_USERS&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;[&amp;#34;user1&amp;#34;, &amp;#34;user2&amp;#34;, &amp;#34;app-bot&amp;#34;]&amp;#39;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>expressions の &lt;a href="https://docs.github.com/en/actions/learn-github-actions/expressions#functions">Functions&lt;/a> に組み込みの関数がいくつか紹介されている。それらを組み合わせるとうまくいきそうと思って書いてみた。たしかにちょっと楽に実装はできるけど、github actions の expression とシェルの文字列との境界が、yaml のコード上では曖昧なため、真偽値などはとくにわかりにくい。例えば、次のコード。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#f92672">[[&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>{ contains(fromJSON(env.DEPLOYABLE_USERS), github.actor) &lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">}&amp;#34;&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#34;true&amp;#34;&lt;/span> &lt;span style="color:#f92672">]]&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>${{ ... }}&lt;/code> で囲まれたところは github の expression なので boolean として評価できるが、それをシェルにもってくると文字列になってしまうので文字列で比較しないといけない。普通にコードを書いていて気づきにくいので実行して振る舞いを検証しないと間違うみたいな話し。&lt;/p></content></item><item><title>もっとさいきょうのでぷろい</title><link>/diary/posts/2022/0306/</link><pubDate>Sun, 06 Mar 2022 02:58:35 +0900</pubDate><guid>/diary/posts/2022/0306/</guid><description>ぼくのかんがえたもっとさいきょうのでぷろい 昨日 ぼくのかんがえたさいきょうのでぷろい を実装したんだけど、その後、残っていた残課題に対応しているうちにもっと最強のデプロイ方法があることに気付いた。結論から言って GitHub Deployments を使う必要がなかった。GitHub Deployments で過去のリビジョンを指定したときは次のような 409 エラーが発生する。
gh: Conflict merging main into f0cff65c94c4a242efebc79c8fb1e31d58d2f592. (HTTP 409) これを回避するためにどんな手段があるかなと workflow dispatch event をみていて inputs というパラメーターがあることに気付いた。あれ？workflow dispatch ってパラメーターを受け取ることができたんだっけ？と調べたら2020年7月ぐらいからできるようになってた。
GitHub Actions: Manual triggers with workflow_dispatch GitHub Actions: Input types for manual workflows github actions の web ui とも連動していて画面からもパラメーターを渡せるようになっていた。jenkins で言うところのパラメーター付きビルドと呼ばれる機能。カスタムアクションの inputs と同じような使い勝手で利用できる。workflow dispatch がパラメーターを受け取れるなら GitHub Deployments を使うメリットって何があるっけ？と思ったら何もなかった。GitHub Deployments を使うことで無駄にリソースを浪費してパイプライン処理を複雑化させるデメリットしかなかった。inputs に渡す型に environment を指定すると、環境の制限や権限、protected branch などにも応用できるらしい。但し、この environment は public リポジトリか、github enterprise でしか高度な設定はできないみたい。GitHub Deployments 経由でリソースの作成自体はできる。</description><content>&lt;h2 id="ぼくのかんがえたもっとさいきょうのでぷろい">ぼくのかんがえたもっとさいきょうのでぷろい&lt;/h2>
&lt;p>昨日 &lt;a href="/diary/diary/posts/2022/0305/#ぼくのかんがえたさいきょうのでぷろい">ぼくのかんがえたさいきょうのでぷろい&lt;/a> を実装したんだけど、その後、残っていた残課題に対応しているうちにもっと最強のデプロイ方法があることに気付いた。結論から言って &lt;a href="https://docs.github.com/en/rest/reference/deployments">GitHub Deployments&lt;/a> を使う必要がなかった。GitHub Deployments で過去のリビジョンを指定したときは次のような 409 エラーが発生する。&lt;/p>
&lt;pre tabindex="0">&lt;code>gh: Conflict merging main into f0cff65c94c4a242efebc79c8fb1e31d58d2f592. (HTTP 409)
&lt;/code>&lt;/pre>&lt;p>これを回避するためにどんな手段があるかなと &lt;a href="https://docs.github.com/en/rest/reference/actions#create-a-workflow-dispatch-event">workflow dispatch event&lt;/a> をみていて &lt;code>inputs&lt;/code> というパラメーターがあることに気付いた。あれ？workflow dispatch ってパラメーターを受け取ることができたんだっけ？と調べたら2020年7月ぐらいからできるようになってた。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.blog/changelog/2020-07-06-github-actions-manual-triggers-with-workflow_dispatch/">GitHub Actions: Manual triggers with workflow_dispatch&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.blog/changelog/2021-11-10-github-actions-input-types-for-manual-workflows/">GitHub Actions: Input types for manual workflows&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>github actions の web ui とも連動していて画面からもパラメーターを渡せるようになっていた。jenkins で言うところのパラメーター付きビルドと呼ばれる機能。カスタムアクションの &lt;a href="https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions#inputs">inputs&lt;/a> と同じような使い勝手で利用できる。workflow dispatch がパラメーターを受け取れるなら GitHub Deployments を使うメリットって何があるっけ？と思ったら何もなかった。GitHub Deployments を使うことで無駄にリソースを浪費してパイプライン処理を複雑化させるデメリットしかなかった。inputs に渡す型に &lt;a href="https://docs.github.com/en/actions/deployment/targeting-different-environments/using-environments-for-deployment">environment&lt;/a> を指定すると、環境の制限や権限、protected branch などにも応用できるらしい。但し、この environment は public リポジトリか、github enterprise でしか高度な設定はできないみたい。GitHub Deployments 経由でリソースの作成自体はできる。&lt;/p>
&lt;figure>&lt;img src="/diary/diary/img/2022/0306_workflow-dispatch.png"/>
&lt;/figure></content></item><item><title>週末は休出</title><link>/diary/posts/2022/0305/</link><pubDate>Sat, 05 Mar 2022 18:55:18 +0900</pubDate><guid>/diary/posts/2022/0305/</guid><description>2時に寝て8時頃に起きた。前日に深夜まで開発してたせいか、朝起きたら頭痛かった。
ストレッチ お仕事に集中していて今週は1回しかストレッチができなかった。今日の開脚幅は開始前164cmで、ストレッチ後165cmだった。先週と同じぐらいかな。それでも毎週予定が入っているので必ず週に1回はちゃんとしたストレッチを受けられる。もう1年以上続けているのだけど、以前より体調のよい状態をずっと継続できている。私はなにかに集中すると他のことをしばらく放置してそればっかりやってしまう傾向があるから毎週の予約があることが継続的な体調管理に大きく役立っている。太ももの後ろの筋肉と腰のストレッチの2つを楽しみにしている。デスクワークをする人は基本的にこの2つに疲労が蓄積するので疲労が溜まるのは自然と言える。その度合いがどのぐらいかでその週の疲労感や調子がよくわかる。今日は先週よりもその2つはましになっていた。
ぼくのかんがえたさいきょうのでぷろい ここ2週間ほど、ビルドとデプロイの分離のための作業をしている。具体的には GitHub Deployments と GitHub Actions を組み合わせて、新たな開発のワークフローを作るといったもの。main, test, develop と3つのブランチで開発/運用しているのを main ブランチ1つに統合し、ビルドもデプロイも最小限に留めて継続的デリバリーを目指すというもの。移行時は開発を止めてしまうのでこの土日で作業する予定だった。準備は十分にやっていたので問題なく移行を完了させた。今日は単体リポジトリのテスト環境へのデプロイができるところまでできた。あとはデプロイツールや github actions の処理を洗練させていくだけ。テンションが上がっているのでこのまま明日も休出してできるだけ品質をあげていく。</description><content>&lt;p>2時に寝て8時頃に起きた。前日に深夜まで開発してたせいか、朝起きたら頭痛かった。&lt;/p>
&lt;h2 id="ストレッチ">ストレッチ&lt;/h2>
&lt;p>お仕事に集中していて今週は1回しかストレッチができなかった。今日の開脚幅は開始前164cmで、ストレッチ後165cmだった。先週と同じぐらいかな。それでも毎週予定が入っているので必ず週に1回はちゃんとしたストレッチを受けられる。もう1年以上続けているのだけど、以前より体調のよい状態をずっと継続できている。私はなにかに集中すると他のことをしばらく放置してそればっかりやってしまう傾向があるから毎週の予約があることが継続的な体調管理に大きく役立っている。太ももの後ろの筋肉と腰のストレッチの2つを楽しみにしている。デスクワークをする人は基本的にこの2つに疲労が蓄積するので疲労が溜まるのは自然と言える。その度合いがどのぐらいかでその週の疲労感や調子がよくわかる。今日は先週よりもその2つはましになっていた。&lt;/p>
&lt;h2 id="ぼくのかんがえたさいきょうのでぷろい">ぼくのかんがえたさいきょうのでぷろい&lt;/h2>
&lt;p>ここ2週間ほど、ビルドとデプロイの分離のための作業をしている。具体的には &lt;a href="https://docs.github.com/en/rest/reference/deployments">GitHub Deployments&lt;/a> と &lt;a href="https://docs.github.com/en/actions">GitHub Actions&lt;/a> を組み合わせて、新たな開発のワークフローを作るといったもの。main, test, develop と3つのブランチで開発/運用しているのを main ブランチ1つに統合し、ビルドもデプロイも最小限に留めて継続的デリバリーを目指すというもの。移行時は開発を止めてしまうのでこの土日で作業する予定だった。準備は十分にやっていたので問題なく移行を完了させた。今日は単体リポジトリのテスト環境へのデプロイができるところまでできた。あとはデプロイツールや github actions の処理を洗練させていくだけ。テンションが上がっているのでこのまま明日も休出してできるだけ品質をあげていく。&lt;/p></content></item><item><title>組織系のイベントにはもう参加しない</title><link>/diary/posts/2022/0304/</link><pubDate>Fri, 04 Mar 2022 08:11:33 +0900</pubDate><guid>/diary/posts/2022/0304/</guid><description>0時に寝て3時40分に起きてそれからの記憶があまりないけど、6時半には起きてた。昼間は久しぶりにシェルスクリプトに熱中してて夜にイベントがあって、それを聞きながらも日付が変わるぐらいまではずっとシェルスクリプトを書いていた。
よくわからないイベント参加 【デブサミ再演】10年後もエンジニアが成長し続けるためにできることを、20年続く組織の中から考える に参加した。なにかの機会でたまたまみかけて中堅社員のキャリア論かなと思って参加したけど、なんかいまいちだった。シェルスクリプトを書きながら聞いてたから大事な話しもしていたかもしれないけど、miro でプレゼン資料が作られていて、参加者が付箋などに書いたコメントをみながら主催者が回答したりもしつつ、スライドで説明したりもしつつ、発表と雑談が混ざった進行で私からはコミュニティの内輪感にみえたし、何が言いたいのかよくわからないイベントだった。コミュニティのメンバー数をみるとそこそこ大きいようにもみえるので、単純に私がコミュニティの対象とする参加者ではなかったんだと思う。パワーポイントなどのスライド資料でプレゼンするのではなく、miro でプレゼンするというスタイルが新鮮で私からはそれがもっとも参考になった点だった。
組織論やキャリアの悩みは私の中では決着がついてしまったのかもしれない。変なことは言っていないし、5年前ぐらいの自分なら関心をもって聞いていたかもしれないけど、自分で会社を作ってみて、組織の論理に振り回されることがなくなって、自分のやりたいことに集中できるようになったからかもしれない。</description><content>&lt;p>0時に寝て3時40分に起きてそれからの記憶があまりないけど、6時半には起きてた。昼間は久しぶりにシェルスクリプトに熱中してて夜にイベントがあって、それを聞きながらも日付が変わるぐらいまではずっとシェルスクリプトを書いていた。&lt;/p>
&lt;h2 id="よくわからないイベント参加">よくわからないイベント参加&lt;/h2>
&lt;p>&lt;a href="https://retrospective.connpass.com/event/240185/">【デブサミ再演】10年後もエンジニアが成長し続けるためにできることを、20年続く組織の中から考える&lt;/a> に参加した。なにかの機会でたまたまみかけて中堅社員のキャリア論かなと思って参加したけど、なんかいまいちだった。シェルスクリプトを書きながら聞いてたから大事な話しもしていたかもしれないけど、miro でプレゼン資料が作られていて、参加者が付箋などに書いたコメントをみながら主催者が回答したりもしつつ、スライドで説明したりもしつつ、発表と雑談が混ざった進行で私からはコミュニティの内輪感にみえたし、何が言いたいのかよくわからないイベントだった。コミュニティのメンバー数をみるとそこそこ大きいようにもみえるので、単純に私がコミュニティの対象とする参加者ではなかったんだと思う。パワーポイントなどのスライド資料でプレゼンするのではなく、miro でプレゼンするというスタイルが新鮮で私からはそれがもっとも参考になった点だった。&lt;/p>
&lt;p>組織論やキャリアの悩みは私の中では決着がついてしまったのかもしれない。変なことは言っていないし、5年前ぐらいの自分なら関心をもって聞いていたかもしれないけど、自分で会社を作ってみて、組織の論理に振り回されることがなくなって、自分のやりたいことに集中できるようになったからかもしれない。&lt;/p></content></item><item><title>裁判の結審</title><link>/diary/posts/2022/0303/</link><pubDate>Thu, 03 Mar 2022 07:57:41 +0900</pubDate><guid>/diary/posts/2022/0303/</guid><description>0時に寝て3時40分に起きて気付いたら6時半だった。
交通事故の裁判 父の交通事故の裁判で保険会社と和解が成立した。交通事故の後、症状固定という、医師の視点からは治療は完了したという診断書をもって加害者の保険会社から任意保険の保険金が支払われる。相手の保険会社の審査のようなものが滞っていて症状固定診断から1年以上経っても支払われないので裁判を起こしていた。弁護士さん曰く、保険会社も多忙なので保険金支払いの裁判を起こすのはよくあることだと当時聞いた。基本的に私は弁護士さんとメールでやり取りしているだけだったが、裁判の傍聴 も1度だけした。10月にもう少しで終わりそうと見積もっていて、実際に結審したのが3月なので5ヶ月ぐらいかかっている。裁判は1-3ヶ月に1回ぐらいの頻度でしか開かれないのでそういう時系列になる。裁判を始めたのが2021年6月頃なので和解という形で結審するまで1年半ぐらいかかったことになる。父が交通事故にあってから約5年が経過していた。保険金は父の財産であり、成年後見人の弁護士さんが管理するもの。保険金支払いは父も含めて家族の生活に変化をもたらすものではない。私が弁護士さんとやり取りする必要がなくなるので自由時間が増えるというぐらいの変化。</description><content>&lt;p>0時に寝て3時40分に起きて気付いたら6時半だった。&lt;/p>
&lt;h2 id="交通事故の裁判">交通事故の裁判&lt;/h2>
&lt;p>父の交通事故の裁判で保険会社と和解が成立した。交通事故の後、症状固定という、医師の視点からは治療は完了したという診断書をもって加害者の保険会社から任意保険の保険金が支払われる。相手の保険会社の審査のようなものが滞っていて症状固定診断から1年以上経っても支払われないので裁判を起こしていた。弁護士さん曰く、保険会社も多忙なので保険金支払いの裁判を起こすのはよくあることだと当時聞いた。基本的に私は弁護士さんとメールでやり取りしているだけだったが、&lt;a href="/diary/diary/posts/2021/1007/#裁判の傍聴">裁判の傍聴&lt;/a> も1度だけした。10月にもう少しで終わりそうと見積もっていて、実際に結審したのが3月なので5ヶ月ぐらいかかっている。裁判は1-3ヶ月に1回ぐらいの頻度でしか開かれないのでそういう時系列になる。裁判を始めたのが2021年6月頃なので和解という形で結審するまで1年半ぐらいかかったことになる。父が交通事故にあってから約5年が経過していた。保険金は父の財産であり、成年後見人の弁護士さんが管理するもの。保険金支払いは父も含めて家族の生活に変化をもたらすものではない。私が弁護士さんとやり取りする必要がなくなるので自由時間が増えるというぐらいの変化。&lt;/p></content></item><item><title>シェルスクリプトも進化する</title><link>/diary/posts/2022/0302/</link><pubDate>Wed, 02 Mar 2022 13:28:44 +0900</pubDate><guid>/diary/posts/2022/0302/</guid><description>23時に寝て2時に起きて6時に起きた。
シェルスクリプト再考 久しぶりにシュルスクリプトを書いていて、ユーティリティ関数をうまいこと実装できないかを調べていたら nameref という仕組みが bash 4.3 以降で使えるらしい。私の bash 環境は 5.0.17 なので、bash 5 以上という制約にしてしまってもよいだろうと思う。例えば、こんなことができる。シェルスクリプトで split を実装するの面倒よね。
function split() { local -n arr=&amp;#34;$1&amp;#34; local values=&amp;#34;$2&amp;#34; local sep=&amp;#34;${3:-,}&amp;#34; IFS=&amp;#34;${sep}&amp;#34; read -a arr &amp;lt;&amp;lt;&amp;lt; $(echo &amp;#34;$values&amp;#34; | tr -d &amp;#39;[:space:]&amp;#39;) } function test() { split mylist &amp;#34;a, b, c&amp;#34; echo &amp;#34;&amp;#39;${mylist[0]}&amp;#39;&amp;#34; echo &amp;#34;&amp;#39;${mylist[1]}&amp;#39;&amp;#34; echo &amp;#34;&amp;#39;${mylist[2]}&amp;#39;&amp;#34; } 実行結果。ちょっと感動した。
$ test &amp;#39;a&amp;#39; &amp;#39;b&amp;#39; &amp;#39;c&amp;#39; How to return an array in bash without using globals? 3.</description><content>&lt;p>23時に寝て2時に起きて6時に起きた。&lt;/p>
&lt;h2 id="シェルスクリプト再考">シェルスクリプト再考&lt;/h2>
&lt;p>久しぶりにシュルスクリプトを書いていて、ユーティリティ関数をうまいこと実装できないかを調べていたら &lt;strong>nameref&lt;/strong> という仕組みが bash 4.3 以降で使えるらしい。私の bash 環境は 5.0.17 なので、bash 5 以上という制約にしてしまってもよいだろうと思う。例えば、こんなことができる。シェルスクリプトで split を実装するの面倒よね。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#66d9ef">function&lt;/span> split&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
local -n arr&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>$1&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
local values&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>$2&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
local sep&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>3&lt;span style="color:#66d9ef">:-&lt;/span>,&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
IFS&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>sep&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
read -a arr &lt;span style="color:#f92672">&amp;lt;&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#66d9ef">$(&lt;/span>echo &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$values&lt;span style="color:#e6db74">&amp;#34;&lt;/span> | tr -d &lt;span style="color:#e6db74">&amp;#39;[:space:]&amp;#39;&lt;/span>&lt;span style="color:#66d9ef">)&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">function&lt;/span> test&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
split mylist &lt;span style="color:#e6db74">&amp;#34;a, b, c&amp;#34;&lt;/span>
echo &lt;span style="color:#e6db74">&amp;#34;&amp;#39;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>mylist[0]&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#34;&lt;/span>
echo &lt;span style="color:#e6db74">&amp;#34;&amp;#39;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>mylist[1]&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#34;&lt;/span>
echo &lt;span style="color:#e6db74">&amp;#34;&amp;#39;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>mylist[2]&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#34;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>実行結果。ちょっと感動した。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">$ test
&lt;span style="color:#e6db74">&amp;#39;a&amp;#39;&lt;/span>
&lt;span style="color:#e6db74">&amp;#39;b&amp;#39;&lt;/span>
&lt;span style="color:#e6db74">&amp;#39;c&amp;#39;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;a href="https://stackoverflow.com/questions/10582763/how-to-return-an-array-in-bash-without-using-globals">How to return an array in bash without using globals?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.gnu.org/software/bash/manual/html_node/Shell-Parameters.html">3.4 Shell Parameters&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="bizpy-勉強会">bizpy 勉強会&lt;/h2>
&lt;p>&lt;a href="https://bizpy.connpass.com/event/239471/">Python で機械学習の前処理をやってみる勉強会&lt;/a> を開催した。今回も講師をわたなべさんにお願いした。私が余裕なくて全くなにもできていない。運営が2人いるとすごく助かる。今回は機械学習の前処理に着目して pandas や scikit-learn を使って実際にどういったプログラミングをするかを解説してもらった。&lt;a href="https://colab.research.google.com/">Colab&lt;/a> を使ってデモするのがいまどきのやり方なのかな？私は全く触ったことがないけど、そういうやり方の違いも含めて関心をもてた。Colab 上で普通に git コマンドも使えるのでリポジトリのクローンなんかもできる。次回は私もなにかしら発表をしたいなとは思う。いまのお仕事が一段落ついたら。&lt;/p></content></item><item><title>github apps を調べた</title><link>/diary/posts/2022/0301/</link><pubDate>Tue, 01 Mar 2022 07:56:36 +0900</pubDate><guid>/diary/posts/2022/0301/</guid><description>23時に寝て5時半に起きた。何度か夜中にも起きた。起きてからドラクエタクトやってた。
oauth apps と github apps いまお仕事で ci/cd の改善をやっていて、その一環としてリポジトリをまたがったパイプライン処理を検討している。 ci/cd で使うような認可の仕組みとして github には oauth apps と github apps の2種類がある。
Building OAuth Apps Building GitHub Apps 私はどちらも全く関わったことがなかったので、仕組みがイメージできる oauth apps を使えばよいのだろうと調べ始めた。しかし、一通り調べてみて会社の開発における ci/cd に使うなら github apps の方が適していることがわかった。両者がどう違うのかもドキュメントに記載されている。最初にこのドキュメントを読めば oauth apps を調査する必要はなかった。
Differences between GitHub Apps and OAuth Apps 具体的には、oauth apps は user の権限を認可する仕組みで、github apps は organization の権限を認可する仕組みと言える。github apps も oauth によるユーザー認証もできる上にアプリ自身の認証もできる。さらにアクセスできるリポジトリも制限できることから github actions などで、特定のリポジトリに対してのみアクセス可能なトークンを取得するには github apps の方が向くというわけだ。oauth でユーザーが認可するときに scope を指定するが、その scope を organization が設定できるといったところが github apps と oauth との違いにみえる。取得できる token の有効期限にもその考え方の違いが出ている。</description><content>&lt;p>23時に寝て5時半に起きた。何度か夜中にも起きた。起きてからドラクエタクトやってた。&lt;/p>
&lt;h2 id="oauth-apps-と-github-apps">oauth apps と github apps&lt;/h2>
&lt;p>いまお仕事で ci/cd の改善をやっていて、その一環としてリポジトリをまたがったパイプライン処理を検討している。
ci/cd で使うような認可の仕組みとして github には oauth apps と github apps の2種類がある。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.github.com/en/developers/apps/building-oauth-apps">Building OAuth Apps&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.github.com/en/developers/apps/building-github-apps">Building GitHub Apps&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>私はどちらも全く関わったことがなかったので、仕組みがイメージできる oauth apps を使えばよいのだろうと調べ始めた。しかし、一通り調べてみて会社の開発における ci/cd に使うなら github apps の方が適していることがわかった。両者がどう違うのかもドキュメントに記載されている。最初にこのドキュメントを読めば oauth apps を調査する必要はなかった。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.github.com/en/developers/apps/getting-started-with-apps/differences-between-github-apps-and-oauth-apps">Differences between GitHub Apps and OAuth Apps&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>具体的には、oauth apps は user の権限を認可する仕組みで、github apps は organization の権限を認可する仕組みと言える。github apps も oauth によるユーザー認証もできる上にアプリ自身の認証もできる。さらにアクセスできるリポジトリも制限できることから github actions などで、特定のリポジトリに対してのみアクセス可能なトークンを取得するには github apps の方が向くというわけだ。oauth でユーザーが認可するときに scope を指定するが、その scope を organization が設定できるといったところが github apps と oauth との違いにみえる。取得できる token の有効期限にもその考え方の違いが出ている。&lt;/p>
&lt;ul>
&lt;li>oauth apps
&lt;ul>
&lt;li>ユーザー/デバイス認証
&lt;ul>
&lt;li>認可コード: 15分&lt;/li>
&lt;li>アクセストークン: 無期限&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>github apps
&lt;ul>
&lt;li>installation 認証
&lt;ul>
&lt;li>認可jwt: 10分&lt;/li>
&lt;li>installation トークン: 1時間&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ユーザー/デバイス認証
&lt;ul>
&lt;li>認可コード: 15分&lt;/li>
&lt;li>アクセストークン: 8時間&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></content></item></channel></rss>