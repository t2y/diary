---
title: "go の処理系も驚く sdk のコード生成"
date: "2023-08-28T08:05:42+09:00"
dates: [2023/08]
cover: ""
tags: [go, design, openapi, ci/cd]
showFullContent: true
---

0時に寝て何度か起きて6時に起きた。そのまま7時過ぎまでだらだらしてた。しんどい。

## msgraph-sdk-go のサイズ問題

先週 [msgraph-sdk-go を使った開発]({{< ref "posts/2023/0825.md#msgraph-sdk-go-を使った開発" >}}) を終えてデプロイする段階になってライブラリのサイズが大きくて、コンパイル速度が遅くなったり、バイナリサイズが大きくなったりする弊害があることに気付いた。コンパイル速度は2-3倍遅くなり (3分が7-10分ぐらい)、バイナリサイズも2-3倍大きくなる (30 MiB が 100 MiB とか) 。たまたまこのリポジトリは他のツール類からも依存パッケージとして使われるものなので想定よりも影響が大きいことに気付いた。

朝からチームのメンバーとミーティングして、本来は qa に入ったこの時期にこんな変更をすべきではないが、これは放置するデメリットが大きいのでリポジトリ分割 (モジュール分割) しようと提案して了承を得た。私がやれば作業は1日もあれば完了するだろうと見積もって、見積もり通り、夕方には分割したモジュールをテスト環境にデプロイして当面の解決を得た。アプリケーションのモジュール構造をちゃんとレイヤー化して作ってあるから、今回みたいに急遽、モジュール分割が必要になってもほぼ変更する必要はなかった (たった1箇所だけ) 。

この本質的な問題は次の issue のコメントで説明されている。

* [Issue with the size of the API surface of the models package #129](https://github.com/microsoftgraph/msgraph-sdk-go/issues/129#issuecomment-1098028043)

ざっと機械翻訳してみる。

> **コンテキスト**
> 
> この SDK は [kiota](https://github.com/microsoft/kiota) を使用してメタデータから自動的に生成されます。オリジナルのメタデータは、Microsoft Graph の配下にあるすべてのサービスチーム（v1用とベータ用）によって入力された CSDL です。この CSDL は最終的に OpenAPI のフォーマットに変換されますが、これは非常に大きなものです（1k 以上のエンドポイント、1.5k のモデル ...）。API のサイズが大きいため、完全な API surface の SDK を手作りすることは実現不可能でしょう。
> 
> 私たちは、SDK を複数のサブモジュール（ファイル用、メール用など）に "スライス" して、人々が関心のあるものだけを簡単に入手できるようにすることをしばらく考えてきました。実際、私たちは PowerShell でこれを実現しました。しかし、"グラフ" の性質（すべてのモデルは互いにある程度関連している）と構築されるアプリケーションの多様性により、スライスは誰にとっても "正しい" ものにはならない（大きすぎたり、小さすぎたり、モデルの重複につながったり...）。
> 
> そのような理由から、私たちは「完全なSDK」を提供することにしました。すべての人にとって理想的とは言えないかもしれませんが、Go開発者の中には「アプリケーションを作るためのSDKが欲しいだけ」という人もいると感じています（以下で説明する2つ目のオプションとは対照的です）。

> **Go の欠点**
> 
> Go の探求を通して、いくつかの欠点に気づいた。現時点では、私たちのプロジェクトやパッケージが適切にセットアップされていないせいなのか、Go や大規模プロジェクトの制限のせいなのかはわからない：
> 
> go build は、変更されておらず、依存関係も変更されていないサブパッケージをリビルドすることが多い。go build が直前に実行されていても、go test がリビルドすることがよくあります。なぜある種のキャッシュに頼らないのでしょうか？同じ問題が go lint にもある。<br />
> 私には、たくさんのサブパッケージがある大きなプロジェクトをビルドするコストは、依存関係が更新されたり、キャッシュが削除されたり、コードが変更されたりしない限り、「セッションごとに一度」だけ支払われるべきだと感じます。
> 
> 私たちのプロジェクト構成／構造において、そのような状況を改善するための最適化について、自由に概説してください。また、Goコミュニティ（Goコンパイラを開発している人たちなど）と関わって、そのようなフィードバックを提供する方法があれば、喜んでそうします。私たちのプロジェクトは、その規模の大きさから、世の中にあるほとんどのGoパッケージと比べると、ちょっと変わり者だとわかっています。

> **適切なサイズの SDK**
> 
> 最後に、すべてのエンドポイントを備えた完全な SDK を持つことは、様々な理由からすべての人に適しているわけではないことを認識しています。私たちは新しい "適切なサイズのセルフサービスSDKエクスペリエンス" を可能にするために取り組んでいます。そこでは、APIユーザーは誰でも、この SDK と同じように見え、同じように感じる SDK を生成することができますが、完全な API サーフェスの代わりに、彼らのアプリケーションのために彼らが気にするエンドポイント/モデルのみが含まれています。
私たちは今、そのような取り組みに本当に早くから取り組んでいますが、それでもフィードバックをいただけるとうれしいです。大まかな手順はこんな感じだ：
> 
> 1. 新しいgoプロジェクトを作成するか、既存のプロジェクトを特定する。
> 1. kiotaの依存関係を追加するか、msgraph-sdk-go-coreを追加します（これはKiotaの依存関係をプルし、いくつか追加します）。
> 1. グラフエクスプローラで必要なリソースを選択（左パネル、2番目のタブ、...、"コレクションに追加"）。
> 1. コレクションをプレビューをクリックし、postmanコレクションとしてエクスポートします。
> 1. hidi を postmanコレクションと先ほど共有したOpenAPIの完全な説明文と一緒に使って、"フィルタリングされた" OpenAPI フォーマットを生成する。
> 1. kiotaを使って、プロジェクトにMicrosoft Graph用のGoクライアントを生成する。
> 1. APIの呼び出しを開始する。
> 
> この時点で、私たちはこれらのステップをすべて文書化し、効率化するために取り組んでいます（おそらくステップ4～5を圧縮しています）。このアプローチの素晴らしいところは、ステップ5から7までが、Microsoft Graphだけでなく、呼び出したいOpenAPIで記述されたAPIで動作することだ。<br />
> 繰り返しますが、この最後の提案はまだ初期段階です。自由に試して、様々な場所でフィードバックを提供してください。
> 
> この長い投稿で、私たちがどこに向かっているのかが明らかになり、Goコミュニティからこれらの側面すべてについてさらにフィードバックが得られると本当に助かる！

簡単に言えば、ms graph api の体系が巨大過ぎて、その定義は [openapi.yaml](https://raw.githubusercontent.com/microsoftgraph/msgraph-metadata/master/openapi/v1.0/openapi.yaml) にあるが、この定義からすべてコード生成すると巨大なモデル定義をもつ sdk が出来上がってしまったという話しである。後半に書いてあるワークアラウンドとして kiota で必要なモデルだけを選択して専用 sdk を生成すればサイズを小さくできるとある。しかし、それはそれで [graph explorer](https://developer.microsoft.com/en-us/graph/graph-explorer) で選択しないといけなかったりして面倒そうではある。次のドキュメントでもその手順について書いてある。

* [Create a smaller and tailored Microsoft Graph Go client library](https://devblogs.microsoft.com/microsoft365dev/building-go-applications-with-the-microsoft-graph-go-sdk/#create-a-smaller-and-tailored-microsoft-graph-go-client-library)

うちの用途ではモジュール分割により、局所化したのでひとまずこの問題は大きな影響をもたないようになった。また余裕があるときにモデルを選択して専用 sdk を自動的に生成する仕組みを構築できるならそれに挑戦してもよいかもしれない。
