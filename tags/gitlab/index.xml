<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>gitlab on forest nook</title><link>/diary/tags/gitlab/</link><description>Recent content in gitlab on forest nook</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><copyright>© 2021 Tetsuya Morimoto</copyright><lastBuildDate>Mon, 18 Dec 2023 19:14:44 +0900</lastBuildDate><atom:icon>/diary/favicon.ico</atom:icon><icon>/diary/favicon.ico</icon><atom:link href="/diary/tags/gitlab/index.xml" rel="self" type="application/rss+xml"/><item><title>gitlab ci/cd のローカルデバッグ</title><link>/diary/posts/2023/1218/</link><pubDate>Mon, 18 Dec 2023 19:14:44 +0900</pubDate><guid>/diary/posts/2023/1218/</guid><description>23時頃から寝始めて3時に起きて5時半に起きて8時過ぎに起きた。久しぶりに寝坊した。
gitlab-runner のデバッグ mongodb のレプリカセット対応して、ローカルでは結合テストが動くものの、gitlab ci/cd 環境では動かなくなった。gitlab ci/cd は GitLab Runner によって提供されている。そのデバッグのため、ローカルに gitlab-runner をインストールして調査した。
GitLab Runner のインストール ドキュメントにそれぞれの OS 向けのドキュメントがある。Debian/Ubuntu/Mint 向けのインストール手順を行う。
$ curl -L &amp;#34;https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh&amp;#34; | sudo bash $ sudo apt-get install gitlab-runner $ gitlab-runner --version Version: 16.6.1 Git revision: f5da3c5a Git branch: 16-6-stable GO version: go1.20.10 Built: 2023-11-24T21:11:36+0000 OS/Arch: linux/amd64 .gitlab-ci.yml があるディレクトリへ移動して、ジョブを指定して実行する。ローカルでの変更内容を検証するときはブランチにコミットしないといけない。コミットしていないと次のワーニングが表示される。
WARNING: You most probably have uncommitted changes. WARNING: These changes will not be tested. dind なジョブを実行するときは --docker-privileged で特権を付けて実行する。環境変数は --env KEY=VALUE で渡せるが、CI_JOB_TOKEN のような組み込みの環境変数は上書きできない。</description><content>&lt;p>23時頃から寝始めて3時に起きて5時半に起きて8時過ぎに起きた。久しぶりに寝坊した。&lt;/p>
&lt;h2 id="gitlab-runner-のデバッグ">gitlab-runner のデバッグ&lt;/h2>
&lt;p>mongodb のレプリカセット対応して、ローカルでは結合テストが動くものの、gitlab ci/cd 環境では動かなくなった。gitlab ci/cd は &lt;a href="https://docs.gitlab.com/runner/">GitLab Runner&lt;/a> によって提供されている。そのデバッグのため、ローカルに gitlab-runner をインストールして調査した。&lt;/p>
&lt;p>&lt;a href="https://docs.gitlab.com/runner/install/">GitLab Runner のインストール&lt;/a> ドキュメントにそれぞれの OS 向けのドキュメントがある。Debian/Ubuntu/Mint 向けのインストール手順を行う。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ curl -L &lt;span style="color:#e6db74">&amp;#34;https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh&amp;#34;&lt;/span> | sudo bash
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ sudo apt-get install gitlab-runner
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ gitlab-runner --version
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Version: 16.6.1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Git revision: f5da3c5a
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Git branch: 16-6-stable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>GO version: go1.20.10
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Built: 2023-11-24T21:11:36+0000
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>OS/Arch: linux/amd64
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>.gitlab-ci.yml があるディレクトリへ移動して、ジョブを指定して実行する。ローカルでの変更内容を検証するときはブランチにコミットしないといけない。コミットしていないと次のワーニングが表示される。&lt;/p>
&lt;pre tabindex="0">&lt;code>WARNING: You most probably have uncommitted changes.
WARNING: These changes will not be tested.
&lt;/code>&lt;/pre>&lt;p>dind なジョブを実行するときは &lt;code>--docker-privileged&lt;/code> で特権を付けて実行する。環境変数は &lt;code>--env KEY=VALUE&lt;/code> で渡せるが、&lt;code>CI_JOB_TOKEN&lt;/code> のような組み込みの環境変数は上書きできない。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ cd path/to/repo
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ gitlab-runner exec docker --docker-privileged &lt;span style="color:#e6db74">${&lt;/span>ジョブ名&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></content></item><item><title>資料作りの一日</title><link>/diary/posts/2023/0914/</link><pubDate>Thu, 14 Sep 2023 20:35:21 +0900</pubDate><guid>/diary/posts/2023/0914/</guid><description>23時に寝て何度か起きて6時に起きた。疲労も溜まっているのでなるべく早く寝るように努めている。旅行中ずっと早起きしていたから早起きするのは苦にならない。
今開発の大きなふりかえりの資料作り ふりかえりのために課題管理システムの issue 情報から統計的な数値を取得する。
gitlab の cli ツールを使って issue 情報を取得して mongodb にインポートする。
$ glab api --paginate &amp;#34;groups/product%2Funicorncidm/issues?milestone=2023-09-05&amp;amp;not[labels]=Duplicate,Invalid,Wontfix&amp;#34; | jq -c &amp;#39;.[]&amp;#39; &amp;gt; 2023-09-05-issues.json $ mongoimport --authenticationDatabase=admin --uri &amp;#34;mongodb://root:secret@localhost:27017&amp;#34; --db gitlab --collection issues 2023-09-05-issues.json mongodb で aggregation (sql で言うところの group by 句に相当する) するときはパイプライン処理を実装する。例えば、最初にデータをフィルターして、次にグルーピングして、最後にソートするのは次のようなパラメーターになる。
$ mongosh --username root --password secret test&amp;gt; use gitlab gitlab&amp;gt; db.issues.aggregate([ { $match: { $or: [ { &amp;#34;milestone.title&amp;#34;: &amp;#34;2023-09-05&amp;#34; },{ &amp;#34;milestone.title&amp;#34;: &amp;#34;2023-09-19&amp;#34; } ] } }, { $group: { &amp;#34;_id&amp;#34;: { milestone: &amp;#34;$milestone.</description><content>&lt;p>23時に寝て何度か起きて6時に起きた。疲労も溜まっているのでなるべく早く寝るように努めている。旅行中ずっと早起きしていたから早起きするのは苦にならない。&lt;/p>
&lt;h2 id="今開発の大きなふりかえりの資料作り">今開発の大きなふりかえりの資料作り&lt;/h2>
&lt;p>ふりかえりのために課題管理システムの issue 情報から統計的な数値を取得する。&lt;/p>
&lt;p>gitlab の &lt;a href="https://gitlab.com/gitlab-org/cli">cli&lt;/a> ツールを使って issue 情報を取得して mongodb にインポートする。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ glab api --paginate &lt;span style="color:#e6db74">&amp;#34;groups/product%2Funicorncidm/issues?milestone=2023-09-05&amp;amp;not[labels]=Duplicate,Invalid,Wontfix&amp;#34;&lt;/span> | jq -c &lt;span style="color:#e6db74">&amp;#39;.[]&amp;#39;&lt;/span> &amp;gt; 2023-09-05-issues.json
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ mongoimport --authenticationDatabase&lt;span style="color:#f92672">=&lt;/span>admin --uri &lt;span style="color:#e6db74">&amp;#34;mongodb://root:secret@localhost:27017&amp;#34;&lt;/span> --db gitlab --collection issues 2023-09-05-issues.json
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>mongodb で aggregation (sql で言うところの group by 句に相当する) するときはパイプライン処理を実装する。例えば、最初にデータをフィルターして、次にグルーピングして、最後にソートするのは次のようなパラメーターになる。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ mongosh --username root --password secret
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>test&amp;gt; use gitlab
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>gitlab&amp;gt; db.issues.aggregate&lt;span style="color:#f92672">([&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">{&lt;/span> $match: &lt;span style="color:#f92672">{&lt;/span> $or: &lt;span style="color:#f92672">[&lt;/span> &lt;span style="color:#f92672">{&lt;/span> &lt;span style="color:#e6db74">&amp;#34;milestone.title&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;2023-09-05&amp;#34;&lt;/span> &lt;span style="color:#f92672">}&lt;/span>,&lt;span style="color:#f92672">{&lt;/span> &lt;span style="color:#e6db74">&amp;#34;milestone.title&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;2023-09-19&amp;#34;&lt;/span> &lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#f92672">}&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">{&lt;/span> $group: &lt;span style="color:#f92672">{&lt;/span> &lt;span style="color:#e6db74">&amp;#34;_id&amp;#34;&lt;/span>: &lt;span style="color:#f92672">{&lt;/span> milestone: &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$milestone&lt;span style="color:#e6db74">.title&amp;#34;&lt;/span> , author: &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$author&lt;span style="color:#e6db74">.username&amp;#34;&lt;/span> &lt;span style="color:#f92672">}&lt;/span>, councount: &lt;span style="color:#f92672">{&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$sum&lt;span style="color:#e6db74">&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#f92672">}&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">{&lt;/span> $sort: &lt;span style="color:#f92672">{&lt;/span> _id: &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">])&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これで前回の開発のときに取得した数値と今回の開発の数値を比較してみると、いろいろわかることもあって、メンバーが成長していることも伺えて、課題管理をしながら開発を進めることのメリットを実感できる開発になったのではないかと思う。gitlab のアクティビティ図 (草生え図) をみても前回の開発よりも草がたくさん生えているので課題管理に習熟している様子が伺える。これをあと2-3年ぐらいすれば、課題管理を使いこなせる一般の開発者になるのではないかと思う。課題管理 + イテレーション開発でチームビルディングしていくところの、地盤のようなものはできたようにみえる。&lt;/p>
&lt;p>この草生え図を匿名化して利用許可をもらって、うちの会社でいうところの課題管理ができるようになると、メンバーの働き方はこうなるというサンプルとして紹介させてもらうつもり。また来週メンバーにもその許諾を取ろうと思う。&lt;/p>
&lt;h2 id="次開発の要件打ち合わせの資料作り">次開発の要件打ち合わせの資料作り&lt;/h2>
&lt;p>今開発を始めるときに洗い出した要件の未対応のものと、今開発でやり残した非機能要件の開発課題を資料にまとめてたたき台とした。それだけでも3-4ヶ月分の開発課題になりそうだし、アーキテクチャとして大きな意思決定も1つある。私自身、7割型は決まっているが、考え方や要件によってはもう1つの案でいくのもよいかもしれない。機能要件は実際にお客さん先へ導入するときにもいくつか出てくるだろうけれど、非機能要件の運用に影響を与える懸念のところはなるべく早く改善しておきたい。次の開発期間にそこだけ対応すれば、一定の安心をもってお客さんへ提供できるようになると思う。&lt;/p></content></item><item><title>gitlab issues と mongodb による分析</title><link>/diary/posts/2023/0511/</link><pubDate>Thu, 11 May 2023 09:06:56 +0900</pubDate><guid>/diary/posts/2023/0511/</guid><description>0時に寝て何度か起きて7時に起きた。今日も一日資料作りをしていた。
gitlab issues の解析 ふりかえりの資料を作っていて gitlab issues の解析を始めた。gitlab にも分析系機能は提供されているが、大半が有償機能で free では使えない。実質 free で役に立ちそうなレポートを私はみつけられなかった。
Analyze GitLab usage gitlab は glab cli というツールを提供している。試しに glab を使って issues の解析ができないかとやってみたが、グループ単位ではなくプロジェクト単位でしか操作できないようにみえた。そこで rest api を呼び出すための便利ツールとして使うことにした。要は rest api で任意のデータを取得してそれを使ってローカルで解析することにした。例えば、次のようにして特定ラベルを除外した特定グループのマイルストーンごとの issues をすべて取得できる。
$ mygrpid=&amp;#34;xxx&amp;#34; $ milestones=&amp;#34;2022-11 2022-12 2023-01 2023-02 2023-03 2023-04&amp;#34; $ for i in $milestones; do echo $i; glab api --paginate &amp;#34;groups/${mygrpid}/issues?milestone=${i}&amp;amp;not[labels]=Duplicate,Invalid,Wontfix&amp;#34; | jq -c &amp;#39;.[]&amp;#39; &amp;gt; &amp;#34;${i}-issues.json&amp;#34;; done あとはこの json データをそのまま分析のためのデータベースに取り込む。今回は mongodb にインポートしてみた。mongodb だとスキーマを定義しなくても json データをそのままインポートできてアドホックな分析に便利そうに思えた。オブジェクトの入れ子構造をもつ json データのようなものを rdbms にインポートするのはひと工夫必要なことから json データをそのままインポートできるドキュメントデータベースの有効性を理解できた。インポートしたら MongoDB Shell を使うとてっとり早い。例えば、マイルストーンごとの issues の件数などは次のようにして集計できる。</description><content>&lt;p>0時に寝て何度か起きて7時に起きた。今日も一日資料作りをしていた。&lt;/p>
&lt;h2 id="gitlab-issues-の解析">gitlab issues の解析&lt;/h2>
&lt;p>ふりかえりの資料を作っていて gitlab issues の解析を始めた。gitlab にも分析系機能は提供されているが、大半が有償機能で free では使えない。実質 free で役に立ちそうなレポートを私はみつけられなかった。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.gitlab.com/ee/user/analytics/">Analyze GitLab usage&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>gitlab は &lt;a href="https://gitlab.com/gitlab-org/cli">glab cli&lt;/a> というツールを提供している。試しに glab を使って issues の解析ができないかとやってみたが、グループ単位ではなくプロジェクト単位でしか操作できないようにみえた。そこで rest api を呼び出すための便利ツールとして使うことにした。要は rest api で任意のデータを取得してそれを使ってローカルで解析することにした。例えば、次のようにして特定ラベルを除外した特定グループのマイルストーンごとの issues をすべて取得できる。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ mygrpid&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;xxx&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ milestones&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;2022-11 2022-12 2023-01 2023-02 2023-03 2023-04&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ &lt;span style="color:#66d9ef">for&lt;/span> i in $milestones; &lt;span style="color:#66d9ef">do&lt;/span> echo $i; glab api --paginate &lt;span style="color:#e6db74">&amp;#34;groups/&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>mygrpid&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/issues?milestone=&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>i&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;amp;not[labels]=Duplicate,Invalid,Wontfix&amp;#34;&lt;/span> | jq -c &lt;span style="color:#e6db74">&amp;#39;.[]&amp;#39;&lt;/span> &amp;gt; &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>i&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">-issues.json&amp;#34;&lt;/span>; &lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>あとはこの json データをそのまま分析のためのデータベースに取り込む。今回は mongodb にインポートしてみた。mongodb だとスキーマを定義しなくても json データをそのままインポートできてアドホックな分析に便利そうに思えた。オブジェクトの入れ子構造をもつ json データのようなものを rdbms にインポートするのはひと工夫必要なことから json データをそのままインポートできるドキュメントデータベースの有効性を理解できた。インポートしたら &lt;a href="https://www.mongodb.com/products/shell">MongoDB Shell&lt;/a> を使うとてっとり早い。例えば、マイルストーンごとの issues の件数などは次のようにして集計できる。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>gitlab&amp;gt; db.issues.aggregate&lt;span style="color:#f92672">([{&lt;/span> $group: &lt;span style="color:#f92672">{&lt;/span> &lt;span style="color:#e6db74">&amp;#34;_id&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$milestone&lt;span style="color:#e6db74">.title&amp;#34;&lt;/span>, count: &lt;span style="color:#f92672">{&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$sum&lt;span style="color:#e6db74">&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#f92672">}&lt;/span>, &lt;span style="color:#f92672">{&lt;/span> $sort: &lt;span style="color:#f92672">{&lt;/span> _id: &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">}}])&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">{&lt;/span> _id: &lt;span style="color:#e6db74">&amp;#39;2022-11&amp;#39;&lt;/span>, count: &lt;span style="color:#ae81ff">348&lt;/span> &lt;span style="color:#f92672">}&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">{&lt;/span> _id: &lt;span style="color:#e6db74">&amp;#39;2022-12&amp;#39;&lt;/span>, count: &lt;span style="color:#ae81ff">346&lt;/span> &lt;span style="color:#f92672">}&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">{&lt;/span> _id: &lt;span style="color:#e6db74">&amp;#39;2023-01&amp;#39;&lt;/span>, count: &lt;span style="color:#ae81ff">338&lt;/span> &lt;span style="color:#f92672">}&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">{&lt;/span> _id: &lt;span style="color:#e6db74">&amp;#39;2023-02&amp;#39;&lt;/span>, count: &lt;span style="color:#ae81ff">357&lt;/span> &lt;span style="color:#f92672">}&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">{&lt;/span> _id: &lt;span style="color:#e6db74">&amp;#39;2023-03&amp;#39;&lt;/span>, count: &lt;span style="color:#ae81ff">347&lt;/span> &lt;span style="color:#f92672">}&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">{&lt;/span> _id: &lt;span style="color:#e6db74">&amp;#39;2023-04&amp;#39;&lt;/span>, count: &lt;span style="color:#ae81ff">336&lt;/span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>担当者別に &lt;code>Enhance&lt;/code> ラベルが付いた issues の件数を数えるときには次のようになる。sql を使えないというデメリットを json データをそのままインポートできるメリットの方が上回るときは mongodb のクエリを学ぶ機会になる。私も mongodb の aggregation の実行方法をドキュメントみながらやってた。全然わからないので慣れが必要になる。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>gitlab&amp;gt; db.issues.aggregate&lt;span style="color:#f92672">([{&lt;/span> $group: &lt;span style="color:#f92672">{&lt;/span> &lt;span style="color:#e6db74">&amp;#34;_id&amp;#34;&lt;/span>: &lt;span style="color:#f92672">{&lt;/span> assignee: &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$assignee&lt;span style="color:#e6db74">.username&amp;#34;&lt;/span>, enhance: &lt;span style="color:#f92672">{&lt;/span>$in: &lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Enhance&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$labels&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#f92672">]}&lt;/span> &lt;span style="color:#f92672">}&lt;/span>, count: &lt;span style="color:#f92672">{&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$sum&lt;span style="color:#e6db74">&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#f92672">}&lt;/span>, &lt;span style="color:#f92672">{&lt;/span>$match: &lt;span style="color:#f92672">{&lt;/span>&lt;span style="color:#e6db74">&amp;#34;_id.enhance&amp;#34;&lt;/span>: true&lt;span style="color:#f92672">}}&lt;/span>, &lt;span style="color:#f92672">{&lt;/span> $sort: &lt;span style="color:#f92672">{&lt;/span> _id: &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">}}])&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">{&lt;/span> _id: &lt;span style="color:#f92672">{&lt;/span> assignee: &lt;span style="color:#e6db74">&amp;#39;bob&amp;#39;&lt;/span>, enhance: true &lt;span style="color:#f92672">}&lt;/span>, count: &lt;span style="color:#ae81ff">84&lt;/span> &lt;span style="color:#f92672">}&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">{&lt;/span> _id: &lt;span style="color:#f92672">{&lt;/span> assignee: &lt;span style="color:#e6db74">&amp;#39;john&amp;#39;&lt;/span>, enhance: true &lt;span style="color:#f92672">}&lt;/span>, count: &lt;span style="color:#ae81ff">143&lt;/span> &lt;span style="color:#f92672">}&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">{&lt;/span> _id: &lt;span style="color:#f92672">{&lt;/span> assignee: &lt;span style="color:#e6db74">&amp;#39;mary&amp;#39;&lt;/span>, enhance: true &lt;span style="color:#f92672">}&lt;/span>, count: &lt;span style="color:#ae81ff">53&lt;/span> &lt;span style="color:#f92672">}&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">{&lt;/span> _id: &lt;span style="color:#f92672">{&lt;/span> assignee: &lt;span style="color:#e6db74">&amp;#39;parks&amp;#39;&lt;/span>, enhance: true &lt;span style="color:#f92672">}&lt;/span>, count: &lt;span style="color:#ae81ff">78&lt;/span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></content></item><item><title>gitlab packages api の使い方</title><link>/diary/posts/2023/0329/</link><pubDate>Wed, 29 Mar 2023 07:32:25 +0900</pubDate><guid>/diary/posts/2023/0329/</guid><description>0時に寝て何度か起きて6時半に起きた。先週より少し早く起きれるようになってきた。
gitlab ci/cd で別プロジェクト (リポジトリ) の成果物を取得する gitlab では複数のパッケージリポジトリに対応しているが、それらに当てはまらない汎用の成果物向けに GitLab Generic Packages Repository というものがある。zip でもバイナリファイルでも何でも置くためのリポジトリと言える。但し、同じパッケージ名でバージョン管理するといった作りにはなっていなくて、同じパッケージ名でアップロードしても別のパッケージ id が割り当てられて管理される。他バージョンとの紐付け自体はできているので、おそらく歴史的経緯でそういう仕様なのだと思う。そのために、あるパッケージの最新のバージョンを取得したいときは作成日の降順でソートして最初のパッケージを取得するといったコードを書かないといけない。それは Packages API を駆使して簡単なスクリプトを書くことになる。
もう1つ分からないことにトークンの使い分けがある。なるべく ci/cd での処理は GitLab CI/CD job token を使いたいところだが、どうも Packages API の呼び出しはできなくて別途プロジェクトでアクセストークンを作成して呼び出すようにしている。これはもしかしたら別の設定で CI/CD job token でも呼び出しできるかもしれない。rest api への呼び出し権限そのものがないのかもしれない。
最終的には次のようなスクリプトで任意のプロジェクトの generic リポジトリの最新の成果物を取得できた。
rm -rf ${TARGET_DIR} mkdir -p ${TARGET_DIR} for project in $PROJECTS do prj=$(echo &amp;#34;$project&amp;#34; | jq -Rr @uri) base=&amp;#34;${CI_API_V4_URL}/projects/${prj}&amp;#34; pkg=$(curl -s -H &amp;#34;PRIVATE-TOKEN: $PROJECT_ACCESS_TOKEN&amp;#34; &amp;#34;${base}/packages?order_by=created_at&amp;amp;sort=desc&amp;amp;per_page=1&amp;#34; | jq &amp;#39;.[0]&amp;#39;) pkg_id=$(echo $pkg | jq -r .</description><content>&lt;p>0時に寝て何度か起きて6時半に起きた。先週より少し早く起きれるようになってきた。&lt;/p>
&lt;h2 id="gitlab-cicd-で別プロジェクト-リポジトリ-の成果物を取得する">gitlab ci/cd で別プロジェクト (リポジトリ) の成果物を取得する&lt;/h2>
&lt;p>gitlab では複数のパッケージリポジトリに対応しているが、それらに当てはまらない汎用の成果物向けに &lt;a href="https://docs.gitlab.com/ee/user/packages/generic_packages/">GitLab Generic Packages Repository&lt;/a> というものがある。zip でもバイナリファイルでも何でも置くためのリポジトリと言える。但し、同じパッケージ名でバージョン管理するといった作りにはなっていなくて、同じパッケージ名でアップロードしても別のパッケージ id が割り当てられて管理される。他バージョンとの紐付け自体はできているので、おそらく歴史的経緯でそういう仕様なのだと思う。そのために、あるパッケージの最新のバージョンを取得したいときは作成日の降順でソートして最初のパッケージを取得するといったコードを書かないといけない。それは &lt;a href="https://docs.gitlab.com/ee/api/packages.html">Packages API&lt;/a> を駆使して簡単なスクリプトを書くことになる。&lt;/p>
&lt;p>もう1つ分からないことにトークンの使い分けがある。なるべく ci/cd での処理は &lt;a href="https://docs.gitlab.com/ee/ci/jobs/ci_job_token.html">GitLab CI/CD job token&lt;/a> を使いたいところだが、どうも Packages API の呼び出しはできなくて別途プロジェクトでアクセストークンを作成して呼び出すようにしている。これはもしかしたら別の設定で CI/CD job token でも呼び出しできるかもしれない。rest api への呼び出し権限そのものがないのかもしれない。&lt;/p>
&lt;p>最終的には次のようなスクリプトで任意のプロジェクトの generic リポジトリの最新の成果物を取得できた。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>rm -rf &lt;span style="color:#e6db74">${&lt;/span>TARGET_DIR&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mkdir -p &lt;span style="color:#e6db74">${&lt;/span>TARGET_DIR&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> project in $PROJECTS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> prj&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>echo &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$project&lt;span style="color:#e6db74">&amp;#34;&lt;/span> | jq -Rr @uri&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> base&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>CI_API_V4_URL&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/projects/&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>prj&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pkg&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>curl -s -H &lt;span style="color:#e6db74">&amp;#34;PRIVATE-TOKEN: &lt;/span>$PROJECT_ACCESS_TOKEN&lt;span style="color:#e6db74">&amp;#34;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>base&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/packages?order_by=created_at&amp;amp;sort=desc&amp;amp;per_page=1&amp;#34;&lt;/span> | jq &lt;span style="color:#e6db74">&amp;#39;.[0]&amp;#39;&lt;/span>&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pkg_id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>echo $pkg | jq -r .id&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pkg_name&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>echo $pkg | jq -r .name&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pkg_version&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>echo $pkg | jq -r .version&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> file_names&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>curl -s -H &lt;span style="color:#e6db74">&amp;#34;PRIVATE-TOKEN: &lt;/span>$PROJECT_ACCESS_TOKEN&lt;span style="color:#e6db74">&amp;#34;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>base&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/packages/&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>pkg_id&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/package_files&amp;#34;&lt;/span> | jq -r &lt;span style="color:#e6db74">&amp;#39;.[].file_name&amp;#39;&lt;/span>&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> file_name in $file_names
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dw_endpoint&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>base&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/packages/generic/&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>pkg_name&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>pkg_version&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>file_name&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> curl -s -H &lt;span style="color:#e6db74">&amp;#34;PRIVATE-TOKEN: &lt;/span>$PROJECT_ACCESS_TOKEN&lt;span style="color:#e6db74">&amp;#34;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>dw_endpoint&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> -o &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>TARGET_DIR&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>file_name&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>find &lt;span style="color:#e6db74">${&lt;/span>TARGET_DIR&lt;span style="color:#e6db74">}&lt;/span> -type f
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></content></item><item><title>集中のち寝不足</title><link>/diary/posts/2023/0206/</link><pubDate>Mon, 06 Feb 2023 09:21:43 +0900</pubDate><guid>/diary/posts/2023/0206/</guid><description>1時に帰ってきてそのまま寝ないで6時10分の新幹線に乗ってから2時間半ほど寝た。これはこれで時間の使い方が有意義な気がする。午前中は翌日の定例会議の準備を着々と進めて、ci/cd 環境の改善、午後からリファクタリングなどをやっていた。15時をまわると眠くなってきて散歩したりして気分転換しつつも体調悪いなと思って17時半にお仕事を終えてホテルへ戻って2-3時間ほど寝てた。その後、晩ご飯食べるかなと出掛けたものの、あまり食欲もなくて、2時間ほど付近を散歩して運動していた。たまにはそういうのもいいか。飲食店が多い地域なので外から眺めているだけでもわりと楽しい。
ssh 経由のデプロイ これまで ci/cd でテストして docker イメージをビルドしてコンテナレジストリに登録するところまでやっていた。実際にテスト環境にデプロイするときは、テスト環境にログインして更新用のスクリプトを私が手動実行していた。そんなに頻繁にテスト環境を更新する必要がなかったのでそれでも十分ではあるものの、ci/cd の完成形を目指すなら自動化すべきという考え方もあってデプロイの部分を作ることにした。
もっとも簡単な方法として Using SSH keys with GitLab CI/CD をみながら、ssh でテスト環境にデプロイすることにした。すでに更新用のスクリプトがあって、テスト環境にログインして実行すればできる状態なので ssh さえ使えればすぐに移行できるという話しでもある。openssh-client を使うためにベースイメージを alpine から ubuntu にしてパッケージをインストールしないといけない。実行時間がややかかるというコスト以外には気にならないかな。ssh の秘密鍵を file 種別でもつのか通常の環境変数でもつのかで扱いが異なって、それに少しはまったぐらいですぐできた。今後は docker イメージのビルド単位に自動的にデプロイされるようになる。
interface{} の型エイリアスとしての any go のコードをリファクタリングしていて json.Marshal の引数が any となっていることに気付いた。
func Marshal(v any) ([]byte, error) { ... } go 1.18 以降で interface{} の型エイリアスとして any が定義されているらしい。任意の型を扱えるシグネチャとして、メソッドの振る舞いのみを規定する interface{} を使うというのは型システムとしては正しい。他言語でいえば object に相当するものが go はオブジェクト指向言語ではないのでそれがない。そういう間違っていないけど、わかりにくいなと思っていたものに any という名前の型エイリアスが導入されてとてもしっくりきた。プログラミングしていて、実務的にどうかというところをちゃんと改善していくところがみえるのは楽しい。
type any = interface{} Go 1.18 で interface{} の代わりに any が使えるようになる話</description><content>&lt;p>1時に帰ってきてそのまま寝ないで6時10分の新幹線に乗ってから2時間半ほど寝た。これはこれで時間の使い方が有意義な気がする。午前中は翌日の定例会議の準備を着々と進めて、ci/cd 環境の改善、午後からリファクタリングなどをやっていた。15時をまわると眠くなってきて散歩したりして気分転換しつつも体調悪いなと思って17時半にお仕事を終えてホテルへ戻って2-3時間ほど寝てた。その後、晩ご飯食べるかなと出掛けたものの、あまり食欲もなくて、2時間ほど付近を散歩して運動していた。たまにはそういうのもいいか。飲食店が多い地域なので外から眺めているだけでもわりと楽しい。&lt;/p>
&lt;h2 id="ssh-経由のデプロイ">ssh 経由のデプロイ&lt;/h2>
&lt;p>これまで ci/cd でテストして docker イメージをビルドしてコンテナレジストリに登録するところまでやっていた。実際にテスト環境にデプロイするときは、テスト環境にログインして更新用のスクリプトを私が手動実行していた。そんなに頻繁にテスト環境を更新する必要がなかったのでそれでも十分ではあるものの、ci/cd の完成形を目指すなら自動化すべきという考え方もあってデプロイの部分を作ることにした。&lt;/p>
&lt;p>もっとも簡単な方法として &lt;a href="https://docs.gitlab.com/ee/ci/ssh_keys/">Using SSH keys with GitLab CI/CD&lt;/a> をみながら、ssh でテスト環境にデプロイすることにした。すでに更新用のスクリプトがあって、テスト環境にログインして実行すればできる状態なので ssh さえ使えればすぐに移行できるという話しでもある。openssh-client を使うためにベースイメージを alpine から ubuntu にしてパッケージをインストールしないといけない。実行時間がややかかるというコスト以外には気にならないかな。ssh の秘密鍵を &lt;code>file&lt;/code> 種別でもつのか通常の環境変数でもつのかで扱いが異なって、それに少しはまったぐらいですぐできた。今後は docker イメージのビルド単位に自動的にデプロイされるようになる。&lt;/p>
&lt;h2 id="interface-の型エイリアスとしての-any">interface{} の型エイリアスとしての any&lt;/h2>
&lt;p>go のコードをリファクタリングしていて json.Marshal の引数が &lt;code>any&lt;/code> となっていることに気付いた。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">Marshal&lt;/span>(&lt;span style="color:#a6e22e">v&lt;/span> &lt;span style="color:#a6e22e">any&lt;/span>) ([]&lt;span style="color:#66d9ef">byte&lt;/span>, &lt;span style="color:#66d9ef">error&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>go 1.18 以降で &lt;code>interface{}&lt;/code> の型エイリアスとして &lt;code>any&lt;/code> が定義されているらしい。任意の型を扱えるシグネチャとして、メソッドの振る舞いのみを規定する &lt;code>interface{}&lt;/code> を使うというのは型システムとしては正しい。他言語でいえば object に相当するものが go はオブジェクト指向言語ではないのでそれがない。そういう間違っていないけど、わかりにくいなと思っていたものに &lt;code>any&lt;/code> という名前の型エイリアスが導入されてとてもしっくりきた。プログラミングしていて、実務的にどうかというところをちゃんと改善していくところがみえるのは楽しい。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">any&lt;/span> = &lt;span style="color:#66d9ef">interface&lt;/span>{}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;a href="https://zenn.dev/syumai/articles/c6q5un1j0msim0aj0ca0">Go 1.18 で interface{} の代わりに any が使えるようになる話&lt;/a>&lt;/li>
&lt;/ul></content></item><item><title>dind をやってみた</title><link>/diary/posts/2022/1219/</link><pubDate>Mon, 19 Dec 2022 11:28:33 +0900</pubDate><guid>/diary/posts/2022/1219/</guid><description>3時に寝て7時半に起きた。最後なのでワールドカップの決勝戦をみてた。接戦で試合もおもしろかったしよかったと思う。
gitlab ci/cd で docker in docker ミドルウェアを伴う結合テストは dockertest というツールを使って docker でミドルウェアを起動して実行している。デフォルトで作成した gitlab runner で docker を使おうとすると失敗する。これは gitlab runner が ci/cd ジョブを docker で動かすため docker in docker (これを dind と呼ぶらしい) のための設定が必要になる。大雑把に言えば gitlab runner にそのための権限を設定する必要がある。gitlab の次のドキュメントに詳細が書いてある。
Use Docker-in-Docker gitlab runner に権限を設定したら次のような job が動けば docker in docker は成功と言える。
hello-dind: stage: test image: docker:20.10.21 variables: DOCKER_HOST: tcp://docker:2375 DOCKER_TLS_CERTDIR: &amp;#34;&amp;#34; services: - docker:20.10.21-dind allow_failure: true before_script: - docker info script: - docker run hello-world あとになって気付いたことだけど、dockertest の README にも Running dockertest in Gitlab CI としていくつか tips が紹介されている。dockertest で作成したリソースからホスト名とポート番号を取得するには次のようなユーティリティを使う必要がある。</description><content>&lt;p>3時に寝て7時半に起きた。最後なのでワールドカップの決勝戦をみてた。接戦で試合もおもしろかったしよかったと思う。&lt;/p>
&lt;h2 id="gitlab-cicd-で-docker-in-docker">gitlab ci/cd で docker in docker&lt;/h2>
&lt;p>ミドルウェアを伴う結合テストは &lt;a href="https://github.com/ory/dockertest">dockertest&lt;/a> というツールを使って docker でミドルウェアを起動して実行している。デフォルトで作成した gitlab runner で docker を使おうとすると失敗する。これは gitlab runner が ci/cd ジョブを docker で動かすため docker in docker (これを &lt;em>dind&lt;/em> と呼ぶらしい) のための設定が必要になる。大雑把に言えば gitlab runner にそのための権限を設定する必要がある。gitlab の次のドキュメントに詳細が書いてある。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.gitlab.com/ee/ci/docker/using_docker_build.html#use-docker-in-docker">Use Docker-in-Docker&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>gitlab runner に権限を設定したら次のような job が動けば docker in docker は成功と言える。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yml" data-lang="yml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">hello-dind&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">stage&lt;/span>: &lt;span style="color:#ae81ff">test&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">image&lt;/span>: &lt;span style="color:#ae81ff">docker:20.10.21&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">variables&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">DOCKER_HOST&lt;/span>: &lt;span style="color:#ae81ff">tcp://docker:2375&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">DOCKER_TLS_CERTDIR&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">services&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">docker:20.10.21-dind&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">allow_failure&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">before_script&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">docker info&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">script&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">docker run hello-world&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>あとになって気付いたことだけど、dockertest の README にも &lt;a href="https://github.com/ory/dockertest#running-dockertest-in-gitlab-ci">Running dockertest in Gitlab CI&lt;/a> としていくつか tips が紹介されている。dockertest で作成したリソースからホスト名とポート番号を取得するには次のようなユーティリティを使う必要がある。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">getHostPort&lt;/span>(&lt;span style="color:#a6e22e">resource&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">dockertest&lt;/span>.&lt;span style="color:#a6e22e">Resource&lt;/span>, &lt;span style="color:#a6e22e">id&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>) &lt;span style="color:#66d9ef">string&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">dockerURL&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">os&lt;/span>.&lt;span style="color:#a6e22e">Getenv&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;DOCKER_HOST&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">dockerURL&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">resource&lt;/span>.&lt;span style="color:#a6e22e">GetHostPort&lt;/span>(&lt;span style="color:#a6e22e">id&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">u&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">url&lt;/span>.&lt;span style="color:#a6e22e">Parse&lt;/span>(&lt;span style="color:#a6e22e">dockerURL&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> panic(&lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">u&lt;/span>.&lt;span style="color:#a6e22e">Hostname&lt;/span>() &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;:&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">resource&lt;/span>.&lt;span style="color:#a6e22e">GetPort&lt;/span>(&lt;span style="color:#a6e22e">id&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></content></item><item><title>docker compose に期待しない</title><link>/diary/posts/2022/1212/</link><pubDate>Mon, 12 Dec 2022 12:52:27 +0900</pubDate><guid>/diary/posts/2022/1212/</guid><description>0時に寝て5時に起きて7時に起きた。起きたら冷やしたのかお腹痛かったが、まぁまぁ眠れたと思う。
テスト環境の構築 GitLab CI/CD にだいぶ慣れてきてジョブを追加したり改善したりしながらようやくアプリケーションの docker image もコンテナレジストリに push されるようになった。それを pull してきて、テスト環境を docker compose で構築する。Use Compose in production とドキュメントでは威勢がよいが、これが全然イケてない。複数の compose.yml で項目によっては変更したいところを置き換えるといった振る舞いになっていない。例えば、ポート番号などを dev と prod で置き換えたいといった運用の要件を考える。
dev.yml services: myapp: ports: - 18080:8080 prod.yml services: myapp: ports: - 8080:8080 これを次のように指定すると、
$ docker compose -f dev.yml -f prod.yml up -d 実際のサービスは次のように振る舞う。全然あかん。
services: myapp: ports: - 18080:8080 - 8080:8080 他にもそれぞれの yml ファイルで読み込む environment file のマージなどもよくわからない振る舞いをしていて複数の compose.yml で制御するのは断念した。dry の原則に反して設定は重複するけど、それぞれの環境を個別に compose.yml として管理した方が保守コストは小さくなると私は判断した。複数の compose.yml の使い分けのデバッグを1-2日やった後に諦めてテスト環境の構築は完了した。
年金事務所の住所変更手続き 先週 法務局で法人登記の変更申請 をしていて、そのときに問題がなければ今日から登記事項証明書を取得できると案内をもらっていた。決定書が漏れていて再提出というトラブルはあったものの、最小限の損失で留めたせいか、問題なく登記事項証明書を発行できた。住所の変更だけわかればよいので履歴事項証明書ではなく現在事項証明書を発行してみた。この書類もおもしろくて1つ前の住所といまの住所の2つを確認できる。法務局へ行った帰りに年金事務所へ立ち寄って社会保険の住所変更の手続きを行った。次の3つの書類をもって窓口へ。</description><content>&lt;p>0時に寝て5時に起きて7時に起きた。起きたら冷やしたのかお腹痛かったが、まぁまぁ眠れたと思う。&lt;/p>
&lt;h2 id="テスト環境の構築">テスト環境の構築&lt;/h2>
&lt;p>&lt;a href="https://docs.gitlab.com/ee/ci/">GitLab CI/CD&lt;/a> にだいぶ慣れてきてジョブを追加したり改善したりしながらようやくアプリケーションの docker image もコンテナレジストリに push されるようになった。それを pull してきて、テスト環境を &lt;a href="https://docs.docker.com/compose/">docker compose&lt;/a> で構築する。&lt;a href="https://docs.docker.com/compose/production/">Use Compose in production&lt;/a> とドキュメントでは威勢がよいが、これが全然イケてない。複数の compose.yml で項目によっては変更したいところを置き換えるといった振る舞いになっていない。例えば、ポート番号などを dev と prod で置き換えたいといった運用の要件を考える。&lt;/p>
&lt;ul>
&lt;li>dev.yml&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yml" data-lang="yml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">services&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">myapp&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">ports&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">18080&lt;/span>:&lt;span style="color:#ae81ff">8080&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>prod.yml&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yml" data-lang="yml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">services&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">myapp&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">ports&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">8080&lt;/span>:&lt;span style="color:#ae81ff">8080&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これを次のように指定すると、&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ docker compose -f dev.yml -f prod.yml up -d
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>実際のサービスは次のように振る舞う。全然あかん。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yml" data-lang="yml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">services&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">myapp&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">ports&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">18080&lt;/span>:&lt;span style="color:#ae81ff">8080&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">8080&lt;/span>:&lt;span style="color:#ae81ff">8080&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>他にもそれぞれの yml ファイルで読み込む environment file のマージなどもよくわからない振る舞いをしていて複数の compose.yml で制御するのは断念した。dry の原則に反して設定は重複するけど、それぞれの環境を個別に compose.yml として管理した方が保守コストは小さくなると私は判断した。複数の compose.yml の使い分けのデバッグを1-2日やった後に諦めてテスト環境の構築は完了した。&lt;/p>
&lt;h2 id="年金事務所の住所変更手続き">年金事務所の住所変更手続き&lt;/h2>
&lt;p>先週 &lt;a href="/diary/diary/posts/2022/1205/#法務局で法人登記の変更申請">法務局で法人登記の変更申請&lt;/a> をしていて、そのときに問題がなければ今日から登記事項証明書を取得できると案内をもらっていた。決定書が漏れていて再提出というトラブルはあったものの、最小限の損失で留めたせいか、問題なく登記事項証明書を発行できた。住所の変更だけわかればよいので履歴事項証明書ではなく現在事項証明書を発行してみた。この書類もおもしろくて1つ前の住所といまの住所の2つを確認できる。法務局へ行った帰りに年金事務所へ立ち寄って社会保険の住所変更の手続きを行った。次の3つの書類をもって窓口へ。&lt;/p>
&lt;ul>
&lt;li>登記事項証明書: 番地まで記載されている&lt;/li>
&lt;li>オフィスの一時使用契約書: ビル名はあるがこのビル名は来月に改名&lt;/li>
&lt;li>ビル名変更の証明書類: ビル名の変更のみが記載されている&lt;/li>
&lt;/ul>
&lt;p>この3つの書類で完全に指定された住所 (Fully Qualified Address: 造語) を丁寧に説明したところ担当者に納得してもらえて事なきを得た。&lt;/p></content></item><item><title>openapi-ext-tools をまた使う日がきた</title><link>/diary/posts/2022/1210/</link><pubDate>Sat, 10 Dec 2022 12:03:13 +0900</pubDate><guid>/diary/posts/2022/1210/</guid><description>0時に寝て4時に起きて7時に起きた。わりとよく眠れた。
ストレッチ トレーナーさんと月曜日の日本対クロアチア戦の感想を話したりしていた。今日の開脚幅は開始前153cmで、ストレッチ後156cmだった。先週は疲弊と疲労で散々な数値になっていたものが復調してきつつある。今週も毎日8-22時はオフィスで缶詰め状態だった。たくさん座っている (同じ体勢でいる) 時間が増えると筋肉にはよくない。まだまだ右腰と右太もも周りの張りは強く復調にはもう少し時間がかかるようにみえる。一方で忙しさのピークを越したと思うので今週以降は少しペースダウンしながら体作りをしていく。いまお手伝いしている開発は12月にすべての集中力を費やしてもよいと考えている。残りは期間はメンバーに委譲するような体制になるとベストかもしれない。そのための体力づくりは重要。
openapi-ext-tools 再び github pages ならぬ gitlab pages がある。ふと web api のドキュメントを作るために openapi のスキーマを定義したら gitlab の ci/cd と連携できていいんじゃないかと思い付いた。スキーマがあればフロントエンドのクライアント生成や e2e テストコードの自動生成などに使えるかもしれないし。過去に作った openapi-ext-tools を oss にしておいたからいまも使える。oss 万歳。先のことはわからない。redoc を使ってちゃっちゃと実装した。
pages: only: changes: - schema/* stage: deploy image: alpine:latest before_script: - apk --no-cache add python3 nodejs npm - python --version - python -m ensurepip - pip3 --version - node --version - npm --version - npm install --global redoc-cli - redoc-cli --version - pip3 install openapi-ext-tools - pip3 freeze openapi-ext-tools | grep openapi script: - openapi-spec-cli --spec-path schema/openapi.</description><content>&lt;p>0時に寝て4時に起きて7時に起きた。わりとよく眠れた。&lt;/p>
&lt;h2 id="ストレッチ">ストレッチ&lt;/h2>
&lt;p>トレーナーさんと月曜日の日本対クロアチア戦の感想を話したりしていた。今日の開脚幅は開始前153cmで、ストレッチ後156cmだった。先週は疲弊と疲労で散々な数値になっていたものが復調してきつつある。今週も毎日8-22時はオフィスで缶詰め状態だった。たくさん座っている (同じ体勢でいる) 時間が増えると筋肉にはよくない。まだまだ右腰と右太もも周りの張りは強く復調にはもう少し時間がかかるようにみえる。一方で忙しさのピークを越したと思うので今週以降は少しペースダウンしながら体作りをしていく。いまお手伝いしている開発は12月にすべての集中力を費やしてもよいと考えている。残りは期間はメンバーに委譲するような体制になるとベストかもしれない。そのための体力づくりは重要。&lt;/p>
&lt;h2 id="openapi-ext-tools-再び">openapi-ext-tools 再び&lt;/h2>
&lt;p>github pages ならぬ &lt;a href="https://docs.gitlab.com/ee/user/project/pages/">gitlab pages&lt;/a> がある。ふと web api のドキュメントを作るために openapi のスキーマを定義したら gitlab の ci/cd と連携できていいんじゃないかと思い付いた。スキーマがあればフロントエンドのクライアント生成や e2e テストコードの自動生成などに使えるかもしれないし。過去に作った &lt;a href="https://pypi.org/project/openapi-ext-tools/">openapi-ext-tools&lt;/a> を oss にしておいたからいまも使える。oss 万歳。先のことはわからない。&lt;a href="https://github.com/Redocly/redoc">redoc&lt;/a> を使ってちゃっちゃと実装した。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yml" data-lang="yml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">pages&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">only&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">changes&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">schema/*&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">stage&lt;/span>: &lt;span style="color:#ae81ff">deploy&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">image&lt;/span>: &lt;span style="color:#ae81ff">alpine:latest&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">before_script&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">apk --no-cache add python3 nodejs npm&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">python --version&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">python -m ensurepip&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">pip3 --version&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">node --version&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">npm --version&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">npm install --global redoc-cli&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">redoc-cli --version&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">pip3 install openapi-ext-tools&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">pip3 freeze openapi-ext-tools | grep openapi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">script&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">openapi-spec-cli --spec-path schema/openapi.yml&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - |+&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> redoc-cli bundle bundled_openapi.yaml \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> --output index.html \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> --options.expandResponses=all \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> --options.requiredPropsFirst=true \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> --options.jsonSampleExpandLevel=10 \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> --options.hideLoading=true \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> --options.pathInMiddlePanel=true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">mkdir -p public&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">mv index.html public/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">artifacts&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">paths&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">public&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>久しぶりに触ったら openapi-ext-tools が依存ライブラリの変更で動かなくなっていたので直した。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/t2y/openapi-ext-tools/issues/1">cannot import name &amp;lsquo;ValidationError&amp;rsquo; from &amp;lsquo;openapi_spec_validator.exceptions&amp;rsquo; #1&lt;/a>&lt;/li>
&lt;/ul></content></item><item><title>gitlab の ci/cd 入門</title><link>/diary/posts/2022/1207/</link><pubDate>Wed, 07 Dec 2022 19:52:19 +0900</pubDate><guid>/diary/posts/2022/1207/</guid><description>0時に寝て3時に起きてそのまま眠れずにいたら6時になって7時過ぎから準備してオフィス行ってお仕事を始めた。
gitlab の ci/cd の調査 初めて GitLab CI/CD を触っている。まだ触り始めたばかりだが、感覚的には github actions 相当の機能はあるようにみえる。ソースコードリポジトリやパッケージリポジトリ／コンテナレジストリと ci/cd がセットになっているととても便利だ。これはすごいことだと最近思うようになってきた。もはやソースコードリポジトリのみのホスティングビジネスは成り立たない。なぜなら github や gitlab のような ci/cd が当たり前になってしまうと、その機能がない場合、デメリットを上回るメリットがないとそんなソースコードリポジトリを選択しない。
docker image をビルドして push する仕組みは既にメンバーが作ってくれていたのでその後始末の処理を作った。Container Registry API を使うと、不要な docker image を削除できる。
Delete registry repository tags in bulk 削除向けに便利な api 設計になっている。こういう細かい配慮は嬉しい。keep_n で最低限残すイメージ数を指定して older_than で過去何日より古いイメージを削除対象とするといったよくある運用の設定ができる。
curl -s -H &amp;#34;PRIVATE-TOKEN: $PROJECT_ACCESS_TOKEN&amp;#34; -X DELETE &amp;#34;${endpoint}&amp;#34; \ --data &amp;#34;name_regex_delete=.*&amp;#34; \ --data &amp;#34;keep_n=${KEEP_N}&amp;#34; \ --data &amp;#34;older_than=${OLDER_THAN}&amp;#34; あとは認証のトークンを指定する方法として私が調べた限りだと2通りある。
(ci_job_token_scope の feature flag を有効にして) $CI_JOB_TOKEN を使う こっちの方が一時トークンなのでよりセキュアなはず この場合はヘッダーに JOB-TOKEN を指定する プロジェクトレベルのアクセストークン を発行して ci/cd の variables に登録する トークンが漏洩したときにプロジェクトレベルで被害が発生する この場合はヘッダーに PRIVATE-TOKEN を指定する 使うトークンによってヘッダーが変わるというのがちょっと変な認証の設計にもみえるけど、まぁそれぐらいしか気にはならない。</description><content>&lt;p>0時に寝て3時に起きてそのまま眠れずにいたら6時になって7時過ぎから準備してオフィス行ってお仕事を始めた。&lt;/p>
&lt;h2 id="gitlab-の-cicd-の調査">gitlab の ci/cd の調査&lt;/h2>
&lt;p>初めて &lt;a href="https://docs.gitlab.com/ee/ci/">GitLab CI/CD&lt;/a> を触っている。まだ触り始めたばかりだが、感覚的には github actions 相当の機能はあるようにみえる。ソースコードリポジトリやパッケージリポジトリ／コンテナレジストリと ci/cd がセットになっているととても便利だ。これはすごいことだと最近思うようになってきた。もはやソースコードリポジトリのみのホスティングビジネスは成り立たない。なぜなら github や gitlab のような ci/cd が当たり前になってしまうと、その機能がない場合、デメリットを上回るメリットがないとそんなソースコードリポジトリを選択しない。&lt;/p>
&lt;p>docker image をビルドして push する仕組みは既にメンバーが作ってくれていたのでその後始末の処理を作った。&lt;a href="https://docs.gitlab.com/ee/api/container_registry.html">Container Registry API&lt;/a> を使うと、不要な docker image を削除できる。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.gitlab.com/ee/api/container_registry.html#delete-registry-repository-tags-in-bulk">Delete registry repository tags in bulk&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>削除向けに便利な api 設計になっている。こういう細かい配慮は嬉しい。&lt;code>keep_n&lt;/code> で最低限残すイメージ数を指定して &lt;code>older_than&lt;/code> で過去何日より古いイメージを削除対象とするといったよくある運用の設定ができる。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>curl -s -H &lt;span style="color:#e6db74">&amp;#34;PRIVATE-TOKEN: &lt;/span>$PROJECT_ACCESS_TOKEN&lt;span style="color:#e6db74">&amp;#34;&lt;/span> -X DELETE &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>endpoint&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --data &lt;span style="color:#e6db74">&amp;#34;name_regex_delete=.*&amp;#34;&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --data &lt;span style="color:#e6db74">&amp;#34;keep_n=&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>KEEP_N&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --data &lt;span style="color:#e6db74">&amp;#34;older_than=&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>OLDER_THAN&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>あとは認証のトークンを指定する方法として私が調べた限りだと2通りある。&lt;/p>
&lt;ul>
&lt;li>(&lt;code>ci_job_token_scope&lt;/code> の feature flag を有効にして) &lt;code>$CI_JOB_TOKEN&lt;/code> を使う
&lt;ul>
&lt;li>こっちの方が一時トークンなのでよりセキュアなはず&lt;/li>
&lt;li>この場合はヘッダーに JOB-TOKEN を指定する&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://docs.gitlab.com/ee/user/project/settings/project_access_tokens.html">プロジェクトレベルのアクセストークン&lt;/a> を発行して ci/cd の variables に登録する
&lt;ul>
&lt;li>トークンが漏洩したときにプロジェクトレベルで被害が発生する&lt;/li>
&lt;li>この場合はヘッダーに PRIVATE-TOKEN を指定する&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>使うトークンによってヘッダーが変わるというのがちょっと変な認証の設計にもみえるけど、まぁそれぐらいしか気にはならない。&lt;/p></content></item><item><title>gitlab を使う開発のお仕事</title><link>/diary/posts/2022/1006/</link><pubDate>Thu, 06 Oct 2022 16:39:10 +0900</pubDate><guid>/diary/posts/2022/1006/</guid><description>0時に寝て何度か起きて、なぜか寝坊して9時に起きた。おそらく休日以外で9時まで寝ていたことはこの日記を書き始めて初めてだと思う。
次のお仕事の意識合わせ 来月から新しい取引先のお仕事を手伝う。先方と業務内容の確認のための打ち合わせを行った。先方はパッケージベンダーになる。私の大先輩にあたる方々が働いている会社だし、当社が目指すパッケージベンダーとしてのお手本のような会社でもある。大いに学ぶところがある業務になるだろうと想定している。私はここ数年 web 業界で働いてきたせいか、やり取りをしていても勝手の違いを少し感じる。それは web 業界が緩過ぎるからだと思う。気を付けないと先方からみて失礼になってしまうかもしれない。契約や初期のオンボーディングも兼ねて10月31日から1週間ほど東京出張する予定になる。
またリポジトリに gitlab を使っている。課題管理や ci/cd も基本的には gitlab で行うことになる。私のもっている github のドメイン知識はまったく活かせないが、gitlab の機能を学ぶよい機会でもある。gitlab と聞くと私は一番先に Remote Manifesto を思い浮かべる。
Hiring and working from all over the world (instead of from a central location). Flexible working hours (over set working hours). Writing down and recording knowledge (over verbal explanations). Written processes (over on-the-job training). Public sharing of information (over need-to-know access). Opening up documents for editing by anyone (over top-down control of documents).</description><content>&lt;p>0時に寝て何度か起きて、なぜか寝坊して9時に起きた。おそらく休日以外で9時まで寝ていたことはこの日記を書き始めて初めてだと思う。&lt;/p>
&lt;h2 id="次のお仕事の意識合わせ">次のお仕事の意識合わせ&lt;/h2>
&lt;p>来月から新しい取引先のお仕事を手伝う。先方と業務内容の確認のための打ち合わせを行った。先方はパッケージベンダーになる。私の大先輩にあたる方々が働いている会社だし、当社が目指すパッケージベンダーとしてのお手本のような会社でもある。大いに学ぶところがある業務になるだろうと想定している。私はここ数年 web 業界で働いてきたせいか、やり取りをしていても勝手の違いを少し感じる。それは web 業界が緩過ぎるからだと思う。気を付けないと先方からみて失礼になってしまうかもしれない。契約や初期のオンボーディングも兼ねて10月31日から1週間ほど東京出張する予定になる。&lt;/p>
&lt;p>またリポジトリに &lt;a href="https://gitlab.com/">gitlab&lt;/a> を使っている。課題管理や ci/cd も基本的には gitlab で行うことになる。私のもっている github のドメイン知識はまったく活かせないが、gitlab の機能を学ぶよい機会でもある。gitlab と聞くと私は一番先に Remote Manifesto を思い浮かべる。&lt;/p>
&lt;blockquote>
&lt;ol>
&lt;li>Hiring and working from all over the world (instead of from a central location).&lt;/li>
&lt;li>Flexible working hours (over set working hours).&lt;/li>
&lt;li>Writing down and recording knowledge (over verbal explanations).&lt;/li>
&lt;li>Written processes (over on-the-job training).&lt;/li>
&lt;li>Public sharing of information (over need-to-know access).&lt;/li>
&lt;li>Opening up documents for editing by anyone (over top-down control of documents).&lt;/li>
&lt;li>Asynchronous communication (over synchronous communication).&lt;/li>
&lt;li>The results of work (over the hours put in).&lt;/li>
&lt;li>Formal communication channels (over informal communication channels).&lt;/li>
&lt;/ol>
&lt;p>&lt;a href="https://about.gitlab.com/company/culture/all-remote/guide/">https://about.gitlab.com/company/culture/all-remote/guide/&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>私の考える課題管理とも相性がよく、時間よりも成果、書くことや非同期コミュニケーションの重要性、組織の透明性を簡潔に表現したマニフェストとなっている。うちの会社はまだ社員採用できる状況ではないが、社員を採用する時期になったらこういったマニフェスト的なものを自社でも作りたいと思う。そのときの最も参考になるものだと思う。&lt;/p></content></item></channel></rss>