<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ci/cd on forest nook</title><link>/diary/tags/ci/cd/</link><description>Recent content in ci/cd on forest nook</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><copyright>© 2021 Tetsuya Morimoto</copyright><atom:icon>/diary/favicon.ico</atom:icon><icon>/diary/favicon.ico</icon><atom:link href="/diary/tags/ci/cd/index.xml" rel="self" type="application/rss+xml"/><item><title>平穏な一日</title><link>/diary/posts/2022/0314/</link><pubDate>Mon, 14 Mar 2022 07:54:52 +0900</pubDate><guid>/diary/posts/2022/0314/</guid><description>0時に寝て5時半に起きた。一仕事を終えて淡々と前の作業の続きのリファクタリングなどをしていた。
デプロイ改善のタスク完了報告 週末にパイプライン処理の検証やロールバック処理の実装を行った。ドキュメントも一通り書いた。チームの開発者にそれらを説明して3スプリント(3週間)に渡った改善が完了したことを報告した。チケットにすると26、そのうち私が担当したのが22なので、私がイニシアティブをとって完遂させた。github actions を始めとする、github のサービスの理解が深まってそれなりに学びがあった。自分でもいくつかカスタム action を作ってみようと思う。</description><content>&lt;p>0時に寝て5時半に起きた。一仕事を終えて淡々と前の作業の続きのリファクタリングなどをしていた。&lt;/p>
&lt;h2 id="デプロイ改善のタスク完了報告">デプロイ改善のタスク完了報告&lt;/h2>
&lt;p>週末にパイプライン処理の検証やロールバック処理の実装を行った。ドキュメントも一通り書いた。チームの開発者にそれらを説明して3スプリント(3週間)に渡った改善が完了したことを報告した。チケットにすると26、そのうち私が担当したのが22なので、私がイニシアティブをとって完遂させた。github actions を始めとする、github のサービスの理解が深まってそれなりに学びがあった。自分でもいくつかカスタム action を作ってみようと思う。&lt;/p></content></item><item><title>デプロイ改善の残作業</title><link>/diary/posts/2022/0312/</link><pubDate>Sat, 12 Mar 2022 09:49:06 +0900</pubDate><guid>/diary/posts/2022/0312/</guid><description>23時に寝て2時に起きて4時ぐらいまでだらだらして寝て6時に起きた。
ストレッチ これまで11時からストレッチを受けていたが、今週から dr.stretch さんの土日の開店時間が10時になったのにあわせる形で時間変更した。朝に予定が入っているとその時間にあわせて起きて身支度して1日が始まるので家で中途半端にだらだらしなくてよい。いつもは11時にあわせて家を出掛けるのが、10時にあわせて出掛けるようになったのでいつもより1時間早く活動できるようになった。私はなんか予定がないとだらだらしてしまって怠惰に過ごしてしまう。そういう怠ける自分の性格もわかっているので適度に予定を入れて怠けないように注意している。
今日の開脚幅は開始前163cmで、ストレッチ後165cmだった。先週とほぼ同じ。今週もお仕事が忙しくて全くできなかったので現状維持といったところ。
デプロイのパイプライン処理 github deployment から workflow dispatch に移行したおかげでせっかく deployments ベースで作ったパイプライン処理のツールを workflow dispatch 向けに移行する必要があった。言うても基本的に同じパラメーターを処理するだけなので大半は再利用できる。ツールのちょっとしたリファクタリングをやってパイプライン処理が動くかどうかの検証をして、ドキュメントを wiki にまとめた。あとはロールバックを自動化するための仕組みを作るだけ。基本的には k8s の kubectl を実行するワークフローを作るだけという想定。</description><content>&lt;p>23時に寝て2時に起きて4時ぐらいまでだらだらして寝て6時に起きた。&lt;/p>
&lt;h2 id="ストレッチ">ストレッチ&lt;/h2>
&lt;p>これまで11時からストレッチを受けていたが、今週から dr.stretch さんの土日の開店時間が10時になったのにあわせる形で時間変更した。朝に予定が入っているとその時間にあわせて起きて身支度して1日が始まるので家で中途半端にだらだらしなくてよい。いつもは11時にあわせて家を出掛けるのが、10時にあわせて出掛けるようになったのでいつもより1時間早く活動できるようになった。私はなんか予定がないとだらだらしてしまって怠惰に過ごしてしまう。そういう怠ける自分の性格もわかっているので適度に予定を入れて怠けないように注意している。&lt;/p>
&lt;p>今日の開脚幅は開始前163cmで、ストレッチ後165cmだった。先週とほぼ同じ。今週もお仕事が忙しくて全くできなかったので現状維持といったところ。&lt;/p>
&lt;h2 id="デプロイのパイプライン処理">デプロイのパイプライン処理&lt;/h2>
&lt;p>github deployment から workflow dispatch に移行したおかげでせっかく deployments ベースで作ったパイプライン処理のツールを workflow dispatch 向けに移行する必要があった。言うても基本的に同じパラメーターを処理するだけなので大半は再利用できる。ツールのちょっとしたリファクタリングをやってパイプライン処理が動くかどうかの検証をして、ドキュメントを wiki にまとめた。あとはロールバックを自動化するための仕組みを作るだけ。基本的には k8s の kubectl を実行するワークフローを作るだけという想定。&lt;/p></content></item><item><title>デプロイ改善の成果まとめ</title><link>/diary/posts/2022/0308/</link><pubDate>Tue, 08 Mar 2022 06:24:20 +0900</pubDate><guid>/diary/posts/2022/0308/</guid><description>23時に寝て5時過ぎに起きた。何度か途中で起きたけど、久しぶりによく寝た。前日あまり寝てなかったから19時過ぎには帰ってきてだらだらしてた。
もてなしだけではもう食えない 業界研究を兼ねて もてなしだけではもう食えない -ホテル経営学の本質と実践- を読み始めた。同じ出版社の週刊ホテルレストランという雑誌の連載を書籍化したものらしい。著者は立教大学で社会人向けビジネススクールでホテルマネジメントとホテルインベストメントを教えているらしい。ビジネスの堅い話しを小説調にすれば読みやすいんじゃないかみたいな取り組みなのかな？よくわかてないけど、小説仕立てで業界研究ができるような書籍になっているらしい。第1章プロローグと第2章腐りやすい在庫を読んだ。実際の現場でこんな仕事できない人が改革チームのリーダーなんかになったりしないなと思いながら読んでた。そこは本題じゃない！コンサルティングでありそうな経営の話しが出てくるのでうちの会社の経営の勉強にもなるかもしれない。少しずつ読んでいく。
デプロイ改善の成果 水曜日がすくらむのふりかえりイベントがあるのでそれに間に合わせて簡単にまとめの資料を作った。3スプリント (3週間) もかけて抜本的に開発のワークフローからビルド/デプロイの ci/cd を見直したので開発全般に影響を与えた。
本番環境デプロイ: 実行時間を約72%の短縮 テスト環境デプロイ: 実行時間を約51%の短縮 hotfix デプロイ: 実行時間を約64%の短縮 そもそも従来のやり方では hotfix を出していないので机上の時間ではあるが 単純に github actions の実行時間だけ比較しても速くなっているのだけど、それ以上にブランチ戦略を大きく変えた。従来は3つのブランチで運用していた。
develop test main これを1つのブランチのみで運用できるように開発のワークフローを刷新した。ブランチが1つしかないので ci/cd の戦略もシンプルになって、変則的な運用 (hotfix を出したいとか) をしても、開発全体に影響を与えない。「誰か勝手にブランチを作ってデプロイして」で終わる。従来のやり方は3つのブランチが開発ワークフローと ci/cd に密接であったために本番環境のリリースするときは開発すべてが止まってしまう状態だった。週1回のリリースだったので本番リリース前の1-2日は PR のレビューやマージを止めているという運用になっていた。それは開発速度に大きな影響を与えていた。ブランチ戦略を見直したことでいつでも本番環境にデプロイできるようになって、継続的デリバリーっぽいことがやりたかったらできるよという話しをした。</description><content>&lt;p>23時に寝て5時過ぎに起きた。何度か途中で起きたけど、久しぶりによく寝た。前日あまり寝てなかったから19時過ぎには帰ってきてだらだらしてた。&lt;/p>
&lt;h2 id="もてなしだけではもう食えない">もてなしだけではもう食えない&lt;/h2>
&lt;p>業界研究を兼ねて &lt;a href="https://ec.hoteresonline.com/products/detail.php?product_id=262">もてなしだけではもう食えない -ホテル経営学の本質と実践-&lt;/a> を読み始めた。同じ出版社の週刊ホテルレストランという雑誌の連載を書籍化したものらしい。著者は立教大学で社会人向けビジネススクールでホテルマネジメントとホテルインベストメントを教えているらしい。ビジネスの堅い話しを小説調にすれば読みやすいんじゃないかみたいな取り組みなのかな？よくわかてないけど、小説仕立てで業界研究ができるような書籍になっているらしい。第1章プロローグと第2章腐りやすい在庫を読んだ。実際の現場でこんな仕事できない人が改革チームのリーダーなんかになったりしないなと思いながら読んでた。そこは本題じゃない！コンサルティングでありそうな経営の話しが出てくるのでうちの会社の経営の勉強にもなるかもしれない。少しずつ読んでいく。&lt;/p>
&lt;h2 id="デプロイ改善の成果">デプロイ改善の成果&lt;/h2>
&lt;p>水曜日がすくらむのふりかえりイベントがあるのでそれに間に合わせて簡単にまとめの資料を作った。3スプリント (3週間) もかけて抜本的に開発のワークフローからビルド/デプロイの ci/cd を見直したので開発全般に影響を与えた。&lt;/p>
&lt;ul>
&lt;li>本番環境デプロイ: 実行時間を約72%の短縮&lt;/li>
&lt;li>テスト環境デプロイ: 実行時間を約51%の短縮&lt;/li>
&lt;li>hotfix デプロイ: 実行時間を約64%の短縮
&lt;ul>
&lt;li>そもそも従来のやり方では hotfix を出していないので机上の時間ではあるが&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>単純に github actions の実行時間だけ比較しても速くなっているのだけど、それ以上にブランチ戦略を大きく変えた。従来は3つのブランチで運用していた。&lt;/p>
&lt;ul>
&lt;li>develop&lt;/li>
&lt;li>test&lt;/li>
&lt;li>main&lt;/li>
&lt;/ul>
&lt;p>これを1つのブランチのみで運用できるように開発のワークフローを刷新した。ブランチが1つしかないので ci/cd の戦略もシンプルになって、変則的な運用 (hotfix を出したいとか) をしても、開発全体に影響を与えない。「誰か勝手にブランチを作ってデプロイして」で終わる。従来のやり方は3つのブランチが開発ワークフローと ci/cd に密接であったために本番環境のリリースするときは開発すべてが止まってしまう状態だった。週1回のリリースだったので本番リリース前の1-2日は PR のレビューやマージを止めているという運用になっていた。それは開発速度に大きな影響を与えていた。ブランチ戦略を見直したことでいつでも本番環境にデプロイできるようになって、継続的デリバリーっぽいことがやりたかったらできるよという話しをした。&lt;/p></content></item><item><title>ワークフローの移行説明</title><link>/diary/posts/2022/0307/</link><pubDate>Mon, 07 Mar 2022 08:11:25 +0900</pubDate><guid>/diary/posts/2022/0307/</guid><description>3時に寝て6時半に起きた。朝起きたら github actions のリソース上限に達しているという連絡が slack に書き込まれていて週末に移行作業して1500分ぐらいは浪費しましたと事後報告した。
ワークフロー移行後の説明 週末に移行した新しい ci/cd の仕組みを開発者に説明した。開発のワークフローも大きく変わる。いくつか要望をもらいつつ、とくに混乱も誤解もなく受け入れられた。github actions の管理画面からボタンでデプロイ実行できるため、本番環境にデプロイできるユーザーは制限したいと言われて次のようなステップを追加した。
- name: デプロイユーザーを確認 if: ${{ env.DEPLOYMENT_ENV == &amp;#39;prod&amp;#39; }} run: |[[ &amp;#34;${{ contains(fromJSON(env.DEPLOYABLE_USERS), github.actor) }}&amp;#34; == &amp;#34;true&amp;#34; ]] &amp;amp;&amp;amp; exit 0 echo &amp;#34;デプロイ権限のあるユーザーではありません&amp;#34; exit 1 env: DEPLOYABLE_USERS: &amp;#39;[&amp;#34;user1&amp;#34;, &amp;#34;user2&amp;#34;, &amp;#34;app-bot&amp;#34;]&amp;#39; expressions の Functions に組み込みの関数がいくつか紹介されている。それらを組み合わせるとうまくいきそうと思って書いてみた。たしかにちょっと楽に実装はできるけど、github actions の expression とシェルの文字列との境界が、yaml のコード上では曖昧なため、真偽値などはとくにわかりにくい。例えば、次のコード。
[[ &amp;#34;${{ contains(fromJSON(env.DEPLOYABLE_USERS), github.actor) }}&amp;#34; == &amp;#34;true&amp;#34; ]] ${{ ... }} で囲まれたところは github の expression なので boolean として評価できるが、それをシェルにもってくると文字列になってしまうので文字列で比較しないといけない。普通にコードを書いていて気づきにくいので実行して振る舞いを検証しないと間違うみたいな話し。</description><content>&lt;p>3時に寝て6時半に起きた。朝起きたら github actions のリソース上限に達しているという連絡が slack に書き込まれていて週末に移行作業して1500分ぐらいは浪費しましたと事後報告した。&lt;/p>
&lt;h2 id="ワークフロー移行後の説明">ワークフロー移行後の説明&lt;/h2>
&lt;p>週末に移行した新しい ci/cd の仕組みを開発者に説明した。開発のワークフローも大きく変わる。いくつか要望をもらいつつ、とくに混乱も誤解もなく受け入れられた。github actions の管理画面からボタンでデプロイ実行できるため、本番環境にデプロイできるユーザーは制限したいと言われて次のようなステップを追加した。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yml" data-lang="yml">- &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">デプロイユーザーを確認&lt;/span>
&lt;span style="color:#f92672">if&lt;/span>: &lt;span style="color:#ae81ff">${{ env.DEPLOYMENT_ENV == &amp;#39;prod&amp;#39; }}&lt;/span>
&lt;span style="color:#f92672">run&lt;/span>: |&lt;span style="color:#e6db74">
&lt;/span>&lt;span style="color:#e6db74"> [[ &amp;#34;${{ contains(fromJSON(env.DEPLOYABLE_USERS), github.actor) }}&amp;#34; == &amp;#34;true&amp;#34; ]] &amp;amp;&amp;amp; exit 0
&lt;/span>&lt;span style="color:#e6db74"> echo &amp;#34;デプロイ権限のあるユーザーではありません&amp;#34;
&lt;/span>&lt;span style="color:#e6db74"> exit 1&lt;/span>
&lt;span style="color:#f92672">env&lt;/span>:
&lt;span style="color:#f92672">DEPLOYABLE_USERS&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;[&amp;#34;user1&amp;#34;, &amp;#34;user2&amp;#34;, &amp;#34;app-bot&amp;#34;]&amp;#39;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>expressions の &lt;a href="https://docs.github.com/en/actions/learn-github-actions/expressions#functions">Functions&lt;/a> に組み込みの関数がいくつか紹介されている。それらを組み合わせるとうまくいきそうと思って書いてみた。たしかにちょっと楽に実装はできるけど、github actions の expression とシェルの文字列との境界が、yaml のコード上では曖昧なため、真偽値などはとくにわかりにくい。例えば、次のコード。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#f92672">[[&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>{ contains(fromJSON(env.DEPLOYABLE_USERS), github.actor) &lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">}&amp;#34;&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#34;true&amp;#34;&lt;/span> &lt;span style="color:#f92672">]]&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>${{ ... }}&lt;/code> で囲まれたところは github の expression なので boolean として評価できるが、それをシェルにもってくると文字列になってしまうので文字列で比較しないといけない。普通にコードを書いていて気づきにくいので実行して振る舞いを検証しないと間違うみたいな話し。&lt;/p></content></item><item><title>もっとさいきょうのでぷろい</title><link>/diary/posts/2022/0306/</link><pubDate>Sun, 06 Mar 2022 02:58:35 +0900</pubDate><guid>/diary/posts/2022/0306/</guid><description>ぼくのかんがえたもっとさいきょうのでぷろい 昨日 ぼくのかんがえたさいきょうのでぷろい を実装したんだけど、その後、残っていた残課題に対応しているうちにもっと最強のデプロイ方法があることに気付いた。結論から言って GitHub Deployments を使う必要がなかった。GitHub Deployments で過去のリビジョンを指定したときは次のような 409 エラーが発生する。
gh: Conflict merging main into f0cff65c94c4a242efebc79c8fb1e31d58d2f592. (HTTP 409) これを回避するためにどんな手段があるかなと workflow dispatch event をみていて inputs というパラメーターがあることに気付いた。あれ？workflow dispatch ってパラメーターを受け取ることができたんだっけ？と調べたら2020年7月ぐらいからできるようになってた。
GitHub Actions: Manual triggers with workflow_dispatch GitHub Actions: Input types for manual workflows github actions の web ui とも連動していて画面からもパラメーターを渡せるようになっていた。jenkins で言うところのパラメーター付きビルドと呼ばれる機能。カスタムアクションの inputs と同じような使い勝手で利用できる。workflow dispatch がパラメーターを受け取れるなら GitHub Deployments を使うメリットって何があるっけ？と思ったら何もなかった。GitHub Deployments を使うことで無駄にリソースを浪費してパイプライン処理を複雑化させるデメリットしかなかった。inputs に渡す型に environment を指定すると、環境の制限や権限、protected branch などにも応用できるらしい。但し、この environment は public リポジトリか、github enterprise でしか高度な設定はできないみたい。GitHub Deployments 経由でリソースの作成自体はできる。</description><content>&lt;h2 id="ぼくのかんがえたもっとさいきょうのでぷろい">ぼくのかんがえたもっとさいきょうのでぷろい&lt;/h2>
&lt;p>昨日 &lt;a href="/diary/diary/posts/2022/0305/#ぼくのかんがえたさいきょうのでぷろい">ぼくのかんがえたさいきょうのでぷろい&lt;/a> を実装したんだけど、その後、残っていた残課題に対応しているうちにもっと最強のデプロイ方法があることに気付いた。結論から言って &lt;a href="https://docs.github.com/en/rest/reference/deployments">GitHub Deployments&lt;/a> を使う必要がなかった。GitHub Deployments で過去のリビジョンを指定したときは次のような 409 エラーが発生する。&lt;/p>
&lt;pre tabindex="0">&lt;code>gh: Conflict merging main into f0cff65c94c4a242efebc79c8fb1e31d58d2f592. (HTTP 409)
&lt;/code>&lt;/pre>&lt;p>これを回避するためにどんな手段があるかなと &lt;a href="https://docs.github.com/en/rest/reference/actions#create-a-workflow-dispatch-event">workflow dispatch event&lt;/a> をみていて &lt;code>inputs&lt;/code> というパラメーターがあることに気付いた。あれ？workflow dispatch ってパラメーターを受け取ることができたんだっけ？と調べたら2020年7月ぐらいからできるようになってた。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.blog/changelog/2020-07-06-github-actions-manual-triggers-with-workflow_dispatch/">GitHub Actions: Manual triggers with workflow_dispatch&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.blog/changelog/2021-11-10-github-actions-input-types-for-manual-workflows/">GitHub Actions: Input types for manual workflows&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>github actions の web ui とも連動していて画面からもパラメーターを渡せるようになっていた。jenkins で言うところのパラメーター付きビルドと呼ばれる機能。カスタムアクションの &lt;a href="https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions#inputs">inputs&lt;/a> と同じような使い勝手で利用できる。workflow dispatch がパラメーターを受け取れるなら GitHub Deployments を使うメリットって何があるっけ？と思ったら何もなかった。GitHub Deployments を使うことで無駄にリソースを浪費してパイプライン処理を複雑化させるデメリットしかなかった。inputs に渡す型に &lt;a href="https://docs.github.com/en/actions/deployment/targeting-different-environments/using-environments-for-deployment">environment&lt;/a> を指定すると、環境の制限や権限、protected branch などにも応用できるらしい。但し、この environment は public リポジトリか、github enterprise でしか高度な設定はできないみたい。GitHub Deployments 経由でリソースの作成自体はできる。&lt;/p>
&lt;figure>&lt;img src="/diary/diary/img/2022/0306_workflow-dispatch.png"/>
&lt;/figure></content></item><item><title>週末は休出</title><link>/diary/posts/2022/0305/</link><pubDate>Sat, 05 Mar 2022 18:55:18 +0900</pubDate><guid>/diary/posts/2022/0305/</guid><description>2時に寝て8時頃に起きた。前日に深夜まで開発してたせいか、朝起きたら頭痛かった。
ストレッチ お仕事に集中していて今週は1回しかストレッチができなかった。今日の開脚幅は開始前164cmで、ストレッチ後165cmだった。先週と同じぐらいかな。それでも毎週予定が入っているので必ず週に1回はちゃんとしたストレッチを受けられる。もう1年以上続けているのだけど、以前より体調のよい状態をずっと継続できている。私はなにかに集中すると他のことをしばらく放置してそればっかりやってしまう傾向があるから毎週の予約があることが継続的な体調管理に大きく役立っている。太ももの後ろの筋肉と腰のストレッチの2つを楽しみにしている。デスクワークをする人は基本的にこの2つに疲労が蓄積するので疲労が溜まるのは自然と言える。その度合いがどのぐらいかでその週の疲労感や調子がよくわかる。今日は先週よりもその2つはましになっていた。
ぼくのかんがえたさいきょうのでぷろい ここ2週間ほど、ビルドとデプロイの分離のための作業をしている。具体的には GitHub Deployments と GitHub Actions を組み合わせて、新たな開発のワークフローを作るといったもの。main, test, develop と3つのブランチで開発/運用しているのを main ブランチ1つに統合し、ビルドもデプロイも最小限に留めて継続的デリバリーを目指すというもの。移行時は開発を止めてしまうのでこの土日で作業する予定だった。準備は十分にやっていたので問題なく移行を完了させた。今日は単体リポジトリのテスト環境へのデプロイができるところまでできた。あとはデプロイツールや github actions の処理を洗練させていくだけ。テンションが上がっているのでこのまま明日も休出してできるだけ品質をあげていく。</description><content>&lt;p>2時に寝て8時頃に起きた。前日に深夜まで開発してたせいか、朝起きたら頭痛かった。&lt;/p>
&lt;h2 id="ストレッチ">ストレッチ&lt;/h2>
&lt;p>お仕事に集中していて今週は1回しかストレッチができなかった。今日の開脚幅は開始前164cmで、ストレッチ後165cmだった。先週と同じぐらいかな。それでも毎週予定が入っているので必ず週に1回はちゃんとしたストレッチを受けられる。もう1年以上続けているのだけど、以前より体調のよい状態をずっと継続できている。私はなにかに集中すると他のことをしばらく放置してそればっかりやってしまう傾向があるから毎週の予約があることが継続的な体調管理に大きく役立っている。太ももの後ろの筋肉と腰のストレッチの2つを楽しみにしている。デスクワークをする人は基本的にこの2つに疲労が蓄積するので疲労が溜まるのは自然と言える。その度合いがどのぐらいかでその週の疲労感や調子がよくわかる。今日は先週よりもその2つはましになっていた。&lt;/p>
&lt;h2 id="ぼくのかんがえたさいきょうのでぷろい">ぼくのかんがえたさいきょうのでぷろい&lt;/h2>
&lt;p>ここ2週間ほど、ビルドとデプロイの分離のための作業をしている。具体的には &lt;a href="https://docs.github.com/en/rest/reference/deployments">GitHub Deployments&lt;/a> と &lt;a href="https://docs.github.com/en/actions">GitHub Actions&lt;/a> を組み合わせて、新たな開発のワークフローを作るといったもの。main, test, develop と3つのブランチで開発/運用しているのを main ブランチ1つに統合し、ビルドもデプロイも最小限に留めて継続的デリバリーを目指すというもの。移行時は開発を止めてしまうのでこの土日で作業する予定だった。準備は十分にやっていたので問題なく移行を完了させた。今日は単体リポジトリのテスト環境へのデプロイができるところまでできた。あとはデプロイツールや github actions の処理を洗練させていくだけ。テンションが上がっているのでこのまま明日も休出してできるだけ品質をあげていく。&lt;/p></content></item><item><title>継続的デリバリーへの第一歩</title><link>/diary/posts/2022/0224/</link><pubDate>Thu, 24 Feb 2022 08:15:56 +0900</pubDate><guid>/diary/posts/2022/0224/</guid><description>0時に寝て6時に起きた。
docker object labels と git リビジョン 継続的デリバリーのために snapshot jar のマニフェストから取得した git のリビジョンを docker イメージの labels に追加するサンプルコードを jib-sample に実装してみた。jib の gradle プラグインを作って簡略化すれば便利かもしれない。</description><content>&lt;p>0時に寝て6時に起きた。&lt;/p>
&lt;h2 id="docker-object-labels-と-git-リビジョン">docker object labels と git リビジョン&lt;/h2>
&lt;p>継続的デリバリーのために snapshot jar のマニフェストから取得した git のリビジョンを docker イメージの &lt;a href="https://docs.docker.com/config/labels-custom-metadata/">labels&lt;/a> に追加するサンプルコードを &lt;a href="https://github.com/t2y/jib-sample">jib-sample&lt;/a> に実装してみた。jib の gradle プラグインを作って簡略化すれば便利かもしれない。&lt;/p></content></item><item><title>java アプリケーションの継続的デリバリー</title><link>/diary/posts/2022/0223/</link><pubDate>Wed, 23 Feb 2022 08:21:39 +0900</pubDate><guid>/diary/posts/2022/0223/</guid><description>0時に寝て3時に起きて6時ぐらいまでだらだらして寝て7時に起きた。
snapshot jar と継続的デリバリー 昨日 jar に git のリビジョン番号を含める ことについて書いた。jar から git のリビジョン番号を取得できれば、docker イメージを生成するときに labels に jar の artifact id と git のリビジョン番号のラベルを追加して、docker イメージからもソースコードの追跡ができるようになる。いまデプロイは docker イメージのみで運用しているため、maven のバージョン管理ができなくても docker イメージの追跡可能性さえあれば現実の運用で問題にならないのではないかと考えた。つまり、snapshot jar で開発したものをそのまま本番環境にデプロイするということを意味する。こうすれば特定のバージョン番号を付けるだけのビルドとデプロイが不要になって、テスト環境にデプロイされた docker イメージのテストを完了すれば、そのイメージをいつでも本番環境にデプロイできるようになる。デプロイするタイミングでビルドする必要がなくなるので継続的デリバリーに近づくのではないかと考えた。
今日、開発の偉い人やインフラ担当者も含めて、みんなでわいわい打ち合わせして、現状の開発では、インターフェースや互換性の変更にあわせてバージョン番号を付けていないし、古いバージョンに戻すことも現実にはなく、保守は常に最新のリビジョンを更新していくから maven でバージョン管理できなくなっても snapshot jar の運用でがんがん開発していけばいいんちゃうという合意を得られた。
実際にこのやり方がうまくいくかどうか、私も初めての試みなのでやってみないとわからないが、この運用によるワークフローの効率化のメリットも大きいので、引き続き、イニシアティブをもって取り組んでいきたい。</description><content>&lt;p>0時に寝て3時に起きて6時ぐらいまでだらだらして寝て7時に起きた。&lt;/p>
&lt;h2 id="snapshot-jar-と継続的デリバリー">snapshot jar と継続的デリバリー&lt;/h2>
&lt;p>昨日 &lt;a href="/diary/diary/posts/2022/0222/#jar-ファイルと-git-のリビジョン">jar に git のリビジョン番号を含める&lt;/a> ことについて書いた。jar から git のリビジョン番号を取得できれば、docker イメージを生成するときに &lt;a href="https://docs.docker.com/config/labels-custom-metadata/">labels&lt;/a> に jar の artifact id と git のリビジョン番号のラベルを追加して、docker イメージからもソースコードの追跡ができるようになる。いまデプロイは docker イメージのみで運用しているため、maven のバージョン管理ができなくても docker イメージの追跡可能性さえあれば現実の運用で問題にならないのではないかと考えた。つまり、snapshot jar で開発したものをそのまま本番環境にデプロイするということを意味する。こうすれば特定のバージョン番号を付けるだけのビルドとデプロイが不要になって、テスト環境にデプロイされた docker イメージのテストを完了すれば、そのイメージをいつでも本番環境にデプロイできるようになる。デプロイするタイミングでビルドする必要がなくなるので継続的デリバリーに近づくのではないかと考えた。&lt;/p>
&lt;p>今日、開発の偉い人やインフラ担当者も含めて、みんなでわいわい打ち合わせして、現状の開発では、インターフェースや互換性の変更にあわせてバージョン番号を付けていないし、古いバージョンに戻すことも現実にはなく、保守は常に最新のリビジョンを更新していくから maven でバージョン管理できなくなっても snapshot jar の運用でがんがん開発していけばいいんちゃうという合意を得られた。&lt;/p>
&lt;p>実際にこのやり方がうまくいくかどうか、私も初めての試みなのでやってみないとわからないが、この運用によるワークフローの効率化のメリットも大きいので、引き続き、イニシアティブをもって取り組んでいきたい。&lt;/p></content></item></channel></rss>