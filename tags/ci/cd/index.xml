<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ci/cd on forest nook</title><link>/diary/tags/ci/cd/</link><description>Recent content in ci/cd on forest nook</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><copyright>© 2021 Tetsuya Morimoto</copyright><atom:icon>/diary/favicon.ico</atom:icon><icon>/diary/favicon.ico</icon><atom:link href="/diary/tags/ci/cd/index.xml" rel="self" type="application/rss+xml"/><item><title>msgraph-sdk-go のビルド問題</title><link>/diary/posts/2023/0825/</link><pubDate>Fri, 25 Aug 2023 18:28:18 +0900</pubDate><guid>/diary/posts/2023/0825/</guid><description>1時に寝て何度か起きて7時に起きた。昨日は少し早めにお仕事を終えて家で休んでいたので少し回復した。
msgraph-sdk-go を使った開発 昨日の続き 。前日に作ったマージリクエストをチームのメンバーにレビューしてもらっていくつか修正して、マージを終えた。一段落。
さらにこの sdk を使うことで8月の前半に開発していた差分比較のところも変更しないといけないことに気付いた。public な構造体のメンバーにアクセスして差分比較する処理を実装していたが、この sdk は getter で構造体のメンバーにアクセスしないといけないことに気付いた。reflectoin の処理に追加で実装を入れるだけなのでそんなに難しくはない。そういった修正をしていたら1日終わってしまった。開発していると時間が過ぎるのは早い。
たまたま ci/cd ジョブの実行時間の上限を10分にしていて超えるときがあってジョブが失敗した。 調べてみると、msgraph-sdk-go の api が巨大過ぎてメモリを浪費したりコンパイルに時間がかかったりするという issue をみつけた。
Memory Leak when creating msgraph client #436 私のローカル環境で測ってみると、約36秒で完了していたテストが2分23秒かかるようになっていた。テストの実行が4-5倍ぐらい遅くなった。さらにコンテナイメージのサイズは 36 MiB から 109 MiB と3倍ほど増えた。無駄に開発を遅らせる環境要因になっているのでこれは別途調査して対応しないといけないことに気付いた。</description><content>&lt;p>1時に寝て何度か起きて7時に起きた。昨日は少し早めにお仕事を終えて家で休んでいたので少し回復した。&lt;/p>
&lt;h2 id="msgraph-sdk-go-を使った開発">msgraph-sdk-go を使った開発&lt;/h2>
&lt;p>&lt;a href="/diary/diary/posts/2023/0824/#msgraph-sdk-go-を使った開発">昨日の続き&lt;/a> 。前日に作ったマージリクエストをチームのメンバーにレビューしてもらっていくつか修正して、マージを終えた。一段落。&lt;/p>
&lt;p>さらにこの sdk を使うことで8月の前半に開発していた差分比較のところも変更しないといけないことに気付いた。public な構造体のメンバーにアクセスして差分比較する処理を実装していたが、この sdk は getter で構造体のメンバーにアクセスしないといけないことに気付いた。reflectoin の処理に追加で実装を入れるだけなのでそんなに難しくはない。そういった修正をしていたら1日終わってしまった。開発していると時間が過ぎるのは早い。&lt;/p>
&lt;p>たまたま ci/cd ジョブの実行時間の上限を10分にしていて超えるときがあってジョブが失敗した。
調べてみると、msgraph-sdk-go の api が巨大過ぎてメモリを浪費したりコンパイルに時間がかかったりするという issue をみつけた。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/microsoftgraph/msgraph-sdk-go/issues/436">Memory Leak when creating msgraph client #436&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>私のローカル環境で測ってみると、約36秒で完了していたテストが2分23秒かかるようになっていた。テストの実行が4-5倍ぐらい遅くなった。さらにコンテナイメージのサイズは 36 MiB から 109 MiB と3倍ほど増えた。無駄に開発を遅らせる環境要因になっているのでこれは別途調査して対応しないといけないことに気付いた。&lt;/p></content></item><item><title>docker image のマルチプラットフォーム対応</title><link>/diary/posts/2023/0427/</link><pubDate>Thu, 27 Apr 2023 08:23:18 +0900</pubDate><guid>/diary/posts/2023/0427/</guid><description>22時に寝て0時に起きてやや吐き気で苦しんで4時に起きて7時に起きた。夜遅くに食べてないのに調子悪かった。
docker image のマルチプラットフォーム対応 やぎさんが docker buildx でマルチプラットフォームのイメージを作成する の記事を書いてて buildx プラグインがあることを知った。ちょうどいまお仕事でコンテナベースのプロダクトを開発している。まずはオンプレミス向けが対象なので amd64 でビルドしていた。今後はクラウド向けにも提供していくので arm64 ビルドもいずれ追加しないといけないと考えていた。ちょうどリリースを終えて調査時間の余裕があるのでこの機会に buildx について調べてみることにした。
Docker Engine 23.0 release notes をみると次のように書いてある。
Set Buildx and BuildKit as the default builder on Linux. moby/moby#43992 Alias docker build to docker buildx build. docker/cli#3314 The legacy builder can still be used by explicitly setting DOCKER_BUILDKIT=0. There are differences in how BuildKit and the legacy builder handle multi-stage builds. For more information, see Multi-stage builds.</description><content>&lt;p>22時に寝て0時に起きてやや吐き気で苦しんで4時に起きて7時に起きた。夜遅くに食べてないのに調子悪かった。&lt;/p>
&lt;h2 id="docker-image-のマルチプラットフォーム対応">docker image のマルチプラットフォーム対応&lt;/h2>
&lt;p>やぎさんが &lt;a href="https://blog.ayakumo.net/entry/2023/04/21/004712">docker buildx でマルチプラットフォームのイメージを作成する&lt;/a> の記事を書いてて &lt;a href="https://github.com/docker/buildx">buildx&lt;/a> プラグインがあることを知った。ちょうどいまお仕事でコンテナベースのプロダクトを開発している。まずはオンプレミス向けが対象なので amd64 でビルドしていた。今後はクラウド向けにも提供していくので arm64 ビルドもいずれ追加しないといけないと考えていた。ちょうどリリースを終えて調査時間の余裕があるのでこの機会に buildx について調べてみることにした。&lt;/p>
&lt;p>&lt;a href="https://docs.docker.com/engine/release-notes/23.0/">Docker Engine 23.0 release notes&lt;/a> をみると次のように書いてある。&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>Set Buildx and BuildKit as the default builder on Linux. moby/moby#43992
&lt;ul>
&lt;li>Alias docker build to docker buildx build. docker/cli#3314&lt;/li>
&lt;li>The legacy builder can still be used by explicitly setting DOCKER_BUILDKIT=0.&lt;/li>
&lt;li>There are differences in how BuildKit and the legacy builder handle multi-stage builds. For more information, see Multi-stage builds.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>23 からデフォルトのビルダーとして buildx が使われるようになっているらしい。&lt;a href="https://github.com/docker/buildx#building-multi-platform-images">Building multi-platform images&lt;/a> を一通り読んで試してみた。&lt;/p>
&lt;p>buildx ではカスタムビルダーを定義して複数プラットフォーム向けの docker image を一緒にビルドできる。このとき個々のビルド環境を &lt;em>builder instance&lt;/em> と呼び、ビルド環境を抽象した概念として扱われている。マルチプラットフォーム対応の文脈で言えば amd64 や arm64 のビルド環境をそれぞれに作る。例えば amd64 のマシン上で arm64 のビルド環境を作るときは &lt;a href="https://www.qemu.org/">qemu&lt;/a> を使ってエミュレーションしたビルド環境を用意したりもできる。builder instance はカスタムビルダーで制御する。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ docker buildx create --name mybuilder --platform linux/amd64,linux/arm64
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ docker buildx ls
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>NAME/NODE DRIVER/ENDPOINT STATUS BUILDKIT PLATFORMS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mybuilder docker-container
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mybuilder0 unix:///var/run/docker.sock inactive linux/amd64*, linux/arm64*
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで作ったカスタムビルダーの driver は、デフォルトビルダーの &lt;code>docker&lt;/code> ではなく、&lt;code>docker-container&lt;/code> になる。おそらく builder instance の実体であるビルド環境がコンテナ上に構築されるのだと思う。これらの builder instance を使ってビルドされる。カスタムビルダーをデフォルトで使うには次のように実行する。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ docker buildx use mybuilder
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このカスタムビルダーを使って docker image をビルドする。カスタムビルダー側にプラットフォームの設定をもっているので &lt;code>--platform&lt;/code> は指定しなくてもよいけど、明示した方がわかりやすいだろう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ docker buildx build --platform linux/amd64,linux/arm64 -t myimage:latest .
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ビルドの処理は進んでいたが、正常終了しなかったので途中でやめた。なにか設定の漏れがあるかもしれないが、だいたいの雰囲気はつかめた。&lt;/p>
&lt;p>ここでいま gitlab ci/cd 環境では &lt;a href="https://github.com/GoogleContainerTools/kaniko">kaniko&lt;/a> というツールを使って docker image をビルドしている。そもそも kaniko と buildx の違いもわからなくなって README を読み返すと次のようなことが書いてあった。&lt;/p>
&lt;blockquote>
&lt;p>kaniko は Docker デーモンに依存せず、Dockerfile 内の各コマンドを完全にユーザースペースで実行します。これにより、標準的な Kubernetes クラスタのように、Docker デーモンを簡単かつ安全に実行できない環境でもコンテナイメージを構築することができます。&lt;/p>
&lt;/blockquote>
&lt;p>ローカルで検証しているとしばしば忘れてしまうが、docker cli を使うには docker daemon を起動しておかないといけない。ci/cd におけるビルド環境がそもそも dokcer で動いていたりすると docker daemon を使えるかどうか (dind: docker in docker) はセキュリティ上の大きな違いになってくる。ci/cd 環境によっては docker daemon が使えないという状況はありえる。そういった環境でも docker image をビルドできるのが kaniko のメリットと言える。&lt;/p>
&lt;p>kaniko はマルチプラットフォーム対応なビルドができるのかどうか？issue でもそういった質問がいくつかみつかる。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/GoogleContainerTools/kaniko/issues/786">how to build multi-arch image using kaniko #786&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/GoogleContainerTools/kaniko/issues/1746">Multi architecture build with only Kaniko #1746&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>結論から言うと、kaniko そのものはマルチプラットフォーム対応のビルド機能をもっていない。アーキテクチャごとのビルド環境があればそれぞれビルドするだけになる。しかし、マルチプラットフォーム対応の docker image というのは &lt;a href="https://docs.docker.com/engine/reference/commandline/manifest/">manifest list&lt;/a> というのを作ってコンテナレジストリに push すればよいという仕組みらしい。この manifest を作るためのツールとして &lt;a href="https://github.com/estesp/manifest-tool">manifest-tool&lt;/a> というのがある。このツールと組み合わせれば、kaniko でもマルチプラットフォーム対応の docker image をコンテナレジストリに登録できる。実際に試したわけではないので想像で書くが次のような手順だと推測する。&lt;/p>
&lt;ol>
&lt;li>kaniko でそれぞれのプラットフォームの docker image をビルドする
&lt;ol>
&lt;li>amd64 向けにビルドする =&amp;gt; latest-amd64&lt;/li>
&lt;li>arm64 向けにビルドする =&amp;gt; latest-arm64&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>ビルドされた複数プラットフォームの docker image に対して manifest-tool でコンテナレジストリに push する
&lt;ol>
&lt;li>&lt;code>latest-&lt;/code> prefix のタグをもつ docker image の manifest list を作る&lt;/li>
&lt;li>manifest list を使ってコンテナレジストリへ push する&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;p>ci/cd 環境でこういった手順のパイプライン処理やジョブを定義して実行すれば kaniko でもマルチプラットフォーム対応な docker image を push できると思う。&lt;/p></content></item><item><title>gitlab packages api の使い方</title><link>/diary/posts/2023/0329/</link><pubDate>Wed, 29 Mar 2023 07:32:25 +0900</pubDate><guid>/diary/posts/2023/0329/</guid><description>0時に寝て何度か起きて6時半に起きた。先週より少し早く起きれるようになってきた。
gitlab ci/cd で別プロジェクト (リポジトリ) の成果物を取得する gitlab では複数のパッケージリポジトリに対応しているが、それらに当てはまらない汎用の成果物向けに GitLab Generic Packages Repository というものがある。zip でもバイナリファイルでも何でも置くためのリポジトリと言える。但し、同じパッケージ名でバージョン管理するといった作りにはなっていなくて、同じパッケージ名でアップロードしても別のパッケージ id が割り当てられて管理される。他バージョンとの紐付け自体はできているので、おそらく歴史的経緯でそういう仕様なのだと思う。そのために、あるパッケージの最新のバージョンを取得したいときは作成日の降順でソートして最初のパッケージを取得するといったコードを書かないといけない。それは Packages API を駆使して簡単なスクリプトを書くことになる。
もう1つ分からないことにトークンの使い分けがある。なるべく ci/cd での処理は GitLab CI/CD job token を使いたいところだが、どうも Packages API の呼び出しはできなくて別途プロジェクトでアクセストークンを作成して呼び出すようにしている。これはもしかしたら別の設定で CI/CD job token でも呼び出しできるかもしれない。rest api への呼び出し権限そのものがないのかもしれない。
最終的には次のようなスクリプトで任意のプロジェクトの generic リポジトリの最新の成果物を取得できた。
rm -rf ${TARGET_DIR} mkdir -p ${TARGET_DIR} for project in $PROJECTS do prj=$(echo &amp;#34;$project&amp;#34; | jq -Rr @uri) base=&amp;#34;${CI_API_V4_URL}/projects/${prj}&amp;#34; pkg=$(curl -s -H &amp;#34;PRIVATE-TOKEN: $PROJECT_ACCESS_TOKEN&amp;#34; &amp;#34;${base}/packages?order_by=created_at&amp;amp;sort=desc&amp;amp;per_page=1&amp;#34; | jq &amp;#39;.[0]&amp;#39;) pkg_id=$(echo $pkg | jq -r .</description><content>&lt;p>0時に寝て何度か起きて6時半に起きた。先週より少し早く起きれるようになってきた。&lt;/p>
&lt;h2 id="gitlab-cicd-で別プロジェクト-リポジトリ-の成果物を取得する">gitlab ci/cd で別プロジェクト (リポジトリ) の成果物を取得する&lt;/h2>
&lt;p>gitlab では複数のパッケージリポジトリに対応しているが、それらに当てはまらない汎用の成果物向けに &lt;a href="https://docs.gitlab.com/ee/user/packages/generic_packages/">GitLab Generic Packages Repository&lt;/a> というものがある。zip でもバイナリファイルでも何でも置くためのリポジトリと言える。但し、同じパッケージ名でバージョン管理するといった作りにはなっていなくて、同じパッケージ名でアップロードしても別のパッケージ id が割り当てられて管理される。他バージョンとの紐付け自体はできているので、おそらく歴史的経緯でそういう仕様なのだと思う。そのために、あるパッケージの最新のバージョンを取得したいときは作成日の降順でソートして最初のパッケージを取得するといったコードを書かないといけない。それは &lt;a href="https://docs.gitlab.com/ee/api/packages.html">Packages API&lt;/a> を駆使して簡単なスクリプトを書くことになる。&lt;/p>
&lt;p>もう1つ分からないことにトークンの使い分けがある。なるべく ci/cd での処理は &lt;a href="https://docs.gitlab.com/ee/ci/jobs/ci_job_token.html">GitLab CI/CD job token&lt;/a> を使いたいところだが、どうも Packages API の呼び出しはできなくて別途プロジェクトでアクセストークンを作成して呼び出すようにしている。これはもしかしたら別の設定で CI/CD job token でも呼び出しできるかもしれない。rest api への呼び出し権限そのものがないのかもしれない。&lt;/p>
&lt;p>最終的には次のようなスクリプトで任意のプロジェクトの generic リポジトリの最新の成果物を取得できた。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>rm -rf &lt;span style="color:#e6db74">${&lt;/span>TARGET_DIR&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mkdir -p &lt;span style="color:#e6db74">${&lt;/span>TARGET_DIR&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> project in $PROJECTS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> prj&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>echo &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$project&lt;span style="color:#e6db74">&amp;#34;&lt;/span> | jq -Rr @uri&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> base&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>CI_API_V4_URL&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/projects/&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>prj&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pkg&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>curl -s -H &lt;span style="color:#e6db74">&amp;#34;PRIVATE-TOKEN: &lt;/span>$PROJECT_ACCESS_TOKEN&lt;span style="color:#e6db74">&amp;#34;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>base&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/packages?order_by=created_at&amp;amp;sort=desc&amp;amp;per_page=1&amp;#34;&lt;/span> | jq &lt;span style="color:#e6db74">&amp;#39;.[0]&amp;#39;&lt;/span>&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pkg_id&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>echo $pkg | jq -r .id&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pkg_name&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>echo $pkg | jq -r .name&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pkg_version&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>echo $pkg | jq -r .version&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> file_names&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>curl -s -H &lt;span style="color:#e6db74">&amp;#34;PRIVATE-TOKEN: &lt;/span>$PROJECT_ACCESS_TOKEN&lt;span style="color:#e6db74">&amp;#34;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>base&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/packages/&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>pkg_id&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/package_files&amp;#34;&lt;/span> | jq -r &lt;span style="color:#e6db74">&amp;#39;.[].file_name&amp;#39;&lt;/span>&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> file_name in $file_names
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dw_endpoint&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>base&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/packages/generic/&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>pkg_name&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>pkg_version&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>file_name&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> curl -s -H &lt;span style="color:#e6db74">&amp;#34;PRIVATE-TOKEN: &lt;/span>$PROJECT_ACCESS_TOKEN&lt;span style="color:#e6db74">&amp;#34;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>dw_endpoint&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> -o &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>TARGET_DIR&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>file_name&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>find &lt;span style="color:#e6db74">${&lt;/span>TARGET_DIR&lt;span style="color:#e6db74">}&lt;/span> -type f
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></content></item><item><title>コンテナの運用ツールを作る</title><link>/diary/posts/2023/0324/</link><pubDate>Fri, 24 Mar 2023 13:31:48 +0900</pubDate><guid>/diary/posts/2023/0324/</guid><description>1時に寝て明け方に起きて7時に起きた。あまり眠れてない雰囲気がある。
docker/compose の運用 いま作っているアプリケーションは docker compose で構成している。マージ単位で gitlab ci/cd から docker image をビルドしていて、テスト環境のデプロイスクリプトで最新の docker image を取得してコンテナを再作成するようにしている。デプロイスクリプトは docker cli と docker compose cli の2つを組み合わせてシェルスクリプトで実装しているが、複数のアプリケーションやミドルウェアがあるのでそれらを統合的に扱うことはできないし、さまざまな状況を想定して動くようにもなっていない。がんばれば doccker/compose cli と jq とシェルスクリプトで細かい要件を実装することもできるけど、それをお客さんの本番環境においても使うには一定の cli 操作に慣れが必要な上、docker/compose の知識やスキルも要求してしまう。少なくとも頻繁にある運用作業として docker image の更新やコンテナの再作成が想定される。ローリングアップデートまでは実装しないけど、アプリケーションの要件にあわせた docker image の更新とコンテナの再作成 (アプリケーションの再起動) ぐらいはまとめてやってしまってよいと思う。
github.com/docker/docker は github.com/moby/moby にリダイレクトされる。docker は開発ツール、moby はインフラやライブラリという住み分けでそれぞれに関心のあることに注力するようにモジュール構成を分離している。それが2019年に行われていまもおそらくまだ途上だと思う。あと docker のモジュール群は go modules に対応していない。大きなプロジェクトが移行するのが大変なのは理解できるけれど、依存解決のような複雑なところを放置するのはまったく賛成できない。そこが不健全だと依存ライブラリの整理やモジュール分割がうまく進まない気がする。docker の client は https://github.com/moby/moby/tree/master/client に定義されていて、readme のサンプルコードにあるようにすぐに使えるようになっている。一方で compose の spec は github.com/compose-spec/compose-go で定義されていて、github.com/docker/compose はまだライブラリとして使いやすいようにはなっていない。仕様と実装が混在していて動いている状態。そういう issue もあげられている。
Using compose as library #9602 testcontainers-go というアプリケーションが compose をライブラリとして使う実装をしている。このコードをみれば compose をどう使えばよいのかはわかる。</description><content>&lt;p>1時に寝て明け方に起きて7時に起きた。あまり眠れてない雰囲気がある。&lt;/p>
&lt;h2 id="dockercompose-の運用">docker/compose の運用&lt;/h2>
&lt;p>いま作っているアプリケーションは &lt;a href="https://docs.docker.com/compose/">docker compose&lt;/a> で構成している。マージ単位で gitlab ci/cd から docker image をビルドしていて、テスト環境のデプロイスクリプトで最新の docker image を取得してコンテナを再作成するようにしている。デプロイスクリプトは docker cli と docker compose cli の2つを組み合わせてシェルスクリプトで実装しているが、複数のアプリケーションやミドルウェアがあるのでそれらを統合的に扱うことはできないし、さまざまな状況を想定して動くようにもなっていない。がんばれば doccker/compose cli と jq とシェルスクリプトで細かい要件を実装することもできるけど、それをお客さんの本番環境においても使うには一定の cli 操作に慣れが必要な上、docker/compose の知識やスキルも要求してしまう。少なくとも頻繁にある運用作業として docker image の更新やコンテナの再作成が想定される。ローリングアップデートまでは実装しないけど、アプリケーションの要件にあわせた docker image の更新とコンテナの再作成 (アプリケーションの再起動) ぐらいはまとめてやってしまってよいと思う。&lt;/p>
&lt;p>github.com/docker/docker は &lt;a href="https://github.com/moby/moby">github.com/moby/moby&lt;/a> にリダイレクトされる。docker は開発ツール、moby はインフラやライブラリという住み分けでそれぞれに関心のあることに注力するようにモジュール構成を分離している。それが2019年に行われていまもおそらくまだ途上だと思う。あと docker のモジュール群は go modules に対応していない。大きなプロジェクトが移行するのが大変なのは理解できるけれど、依存解決のような複雑なところを放置するのはまったく賛成できない。そこが不健全だと依存ライブラリの整理やモジュール分割がうまく進まない気がする。docker の client は &lt;a href="https://github.com/moby/moby/tree/master/client">https://github.com/moby/moby/tree/master/client&lt;/a> に定義されていて、readme のサンプルコードにあるようにすぐに使えるようになっている。一方で compose の spec は &lt;a href="https://github.com/compose-spec/compose-go">github.com/compose-spec/compose-go&lt;/a> で定義されていて、&lt;a href="https://github.com/docker/compose">github.com/docker/compose&lt;/a> はまだライブラリとして使いやすいようにはなっていない。仕様と実装が混在していて動いている状態。そういう issue もあげられている。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/docker/compose/issues/9602">Using compose as library #9602&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>testcontainers-go というアプリケーションが compose をライブラリとして使う実装をしている。このコードをみれば compose をどう使えばよいのかはわかる。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://golang.testcontainers.org/features/docker_compose/">Using Docker Compose&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>自分で compose を実装してもよいけれど、compose の service を扱うための project やオプションの設定が煩雑なことも伺える。仕様と実装が混在しているというのはそこら変の整理ができていないようにみえるからだ。testcontainers-go も自前の client を用意して使いやすいようにしているのでそれを再利用した方が運用ツールを作るのは簡単になる。testcontainers-go の compose client 経由で compose の up/down を制御する。その他のコンテナの操作は docker client を直接使って実装する。この組み合わせで自分たちのアプリケーション向けの運用ツールを作ろうと思う。&lt;/p>
&lt;blockquote class="twitter-tweet">&lt;p lang="ja" dir="ltr">コンテナを操作する運用ツールを作るために docker をライブラリとして使ってツールを作っている。関連するところの docker のソースを読んでいて、感覚的にあまり洗練されていない印象をうける。依存解決も意味不明な所感。&lt;/p>&amp;mdash; Tetsuya Morimoto (@t2y) &lt;a href="https://twitter.com/t2y/status/1639233150357471233?ref_src=twsrc%5Etfw">March 24, 2023&lt;/a>&lt;/blockquote>
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8">&lt;/script></content></item><item><title>プライベートリポジトリの go アプリケーションの依存解決</title><link>/diary/posts/2023/0322/</link><pubDate>Wed, 22 Mar 2023 16:38:30 +0900</pubDate><guid>/diary/posts/2023/0322/</guid><description>0時に寝て6時半に起きた。面倒なお仕事を朝から集中して片づけた。
go.mod のプライベートリポジトリの依存解決 非公開のプライベートリポジトリで開発している go アプリケーションを他のリポジトリから依存ライブラリとして使う方法を調べた。go modules は基本的に公開されたパブリックなリポジトリを前提としている。go.mod のワークフローで他の依存ライブラリと同様にバージョン管理ができるようにするには、プライベートリポジトリであることを go.mod に認識させ、トークンなどを使って認証する必要がある。
go 1.13 から GOPROXY と GOPRIVATE という環境変数が追加された。デフォルトでは GOPROXY は https://proxy.golang.org に設定されており、このプロキシサーバー経由で依存ライブラリを取得する。これは公開リポジトリを、ある日、作者が急に削除したり非公開にしたときにビルドできないといった問題を防ぐために依存ライブラリのリポジトリをキャッシュしてくれる役割を担っている。
一方でインターネット上のプロキシサーバーからはプライベートリポジトリへアクセスできないので GOPRIVATE を設定してアクセスできないサイトを go.mod へ教えてあげる必要がある。
$ go env -w GOPRIVATE=&amp;#34;private.repo.jp&amp;#34; $ go env | grep GOPRIVATE GOPRIVATE=&amp;#34;private.repo.jp&amp;#34; 通常 go.mod は https で依存ライブラリをリポジトリから取得 (クローン) しようとする。このときに git の設定を変更することで特定のサイトへのアクセスを ssh 経由に変更できる。次の例では https://private.repo.jp へのアクセスをすべて ssh://git@private.repo.jp でクローンできる。
$ git config --global url.&amp;#34;ssh://git@private.repo.jp&amp;#34;.insteadOf &amp;#34;https://private.repo.jp&amp;#34;` $ tail -n 2 ~/.gitconfig [url &amp;#34;ssh://git@gitlab.osstech.co.jp&amp;#34;] insteadOf = https://gitlab.osstech.co.jp これで git リポジトリのクローンは ssh で行われるようになるが、go.</description><content>&lt;p>0時に寝て6時半に起きた。面倒なお仕事を朝から集中して片づけた。&lt;/p>
&lt;h2 id="gomod-のプライベートリポジトリの依存解決">go.mod のプライベートリポジトリの依存解決&lt;/h2>
&lt;p>非公開のプライベートリポジトリで開発している go アプリケーションを他のリポジトリから依存ライブラリとして使う方法を調べた。go modules は基本的に公開されたパブリックなリポジトリを前提としている。go.mod のワークフローで他の依存ライブラリと同様にバージョン管理ができるようにするには、プライベートリポジトリであることを go.mod に認識させ、トークンなどを使って認証する必要がある。&lt;/p>
&lt;p>&lt;a href="https://go.dev/doc/go1.13">go 1.13&lt;/a> から &lt;code>GOPROXY&lt;/code> と &lt;code>GOPRIVATE&lt;/code> という環境変数が追加された。デフォルトでは GOPROXY は &lt;a href="https://proxy.golang.org">https://proxy.golang.org&lt;/a> に設定されており、このプロキシサーバー経由で依存ライブラリを取得する。これは公開リポジトリを、ある日、作者が急に削除したり非公開にしたときにビルドできないといった問題を防ぐために依存ライブラリのリポジトリをキャッシュしてくれる役割を担っている。&lt;/p>
&lt;p>一方でインターネット上のプロキシサーバーからはプライベートリポジトリへアクセスできないので &lt;code>GOPRIVATE&lt;/code> を設定してアクセスできないサイトを go.mod へ教えてあげる必要がある。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ go env -w GOPRIVATE&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;private.repo.jp&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ go env | grep GOPRIVATE
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>GOPRIVATE&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;private.repo.jp&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>通常 go.mod は https で依存ライブラリをリポジトリから取得 (クローン) しようとする。このときに git の設定を変更することで特定のサイトへのアクセスを ssh 経由に変更できる。次の例では &lt;code>https://private.repo.jp&lt;/code> へのアクセスをすべて &lt;code>ssh://git@private.repo.jp&lt;/code> でクローンできる。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ git config --global url.&lt;span style="color:#e6db74">&amp;#34;ssh://git@private.repo.jp&amp;#34;&lt;/span>.insteadOf &lt;span style="color:#e6db74">&amp;#34;https://private.repo.jp&amp;#34;&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ tail -n &lt;span style="color:#ae81ff">2&lt;/span> ~/.gitconfig
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>url &lt;span style="color:#e6db74">&amp;#34;ssh://git@gitlab.osstech.co.jp&amp;#34;&lt;/span>&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> insteadOf &lt;span style="color:#f92672">=&lt;/span> https://gitlab.osstech.co.jp
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これで git リポジトリのクローンは ssh で行われるようになるが、go.mod のワークフローでは https でもアクセスする処理があるようにみえる。https でもアクセスできるように PAT などのトークンを取得して次のように &lt;code>~/.netrc&lt;/code> に https でプライベートリポジトリへアクセスするための認証設定を追加する。&lt;/p>
&lt;pre tabindex="0">&lt;code>machine private.repo.jp
login t2y
password ${PERSONAL_ACCESS_TOKEN}
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>&lt;a href="https://www.digitalocean.com/community/tutorials/how-to-use-a-private-go-module-in-your-own-project">How to Use a Private Go Module in Your Own Project&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://erwinvaneyk.nl/private-repositories-with-go-mod/">How to use private repositories with Go modules&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="コワーキングのオンラインイベント">コワーキングのオンラインイベント&lt;/h2>
&lt;p>月例のカフーツさんのオンラインイベントに参加した。&lt;a href="/diary/diary/posts/2023/0215/#コワーキングのオンラインイベント">先月の所感はここ&lt;/a> 。いとうさんの近況を把握していないが、どうやらバリ島 (インドネシア) のコワーキングスペースをいくつか訪問してきたらしい。その旅程を写真をみながらふりかえるようなイベントだった。バリ島の自然や建物の雰囲気が伺えてとてもおもしろかった。&lt;/p>
&lt;p>いとうさんからバリ島はデジタルノマドの先進的な取り組みをしているように聞いていた。例えば &lt;a href="https://cosmicalz.com/indonesianomadvisaunderconsideration">バリ島でリモートも可能!?インドネシアのノマドビザは最長5年を検討中&lt;/a> にあるように最長5年のビザを用意しているという話しが日本で盛り上がっているが、現地ではまだ正式にそのようなビザがあるようには存在が確認されていないらしい。それに近い長期のビザを取得するには、一定の金融資産があることを証明しないといけないらしく、日本円だと数千万円程度ないとビザを取得できないのではないか？といった話題もあったと思う。基本的にインドネシア政府は海外から金持ちを呼び込みたいらしく、金持ち向けに待遇のよいビザを整備するのではないかとのこと。ビザの話しはともかく、ここ2-3年でバリ島のコワーキングスペースもいくつか廃業しているらしい。それは利用者の大半が外国人であったため、コロナ禍により、インドネシア政府からの要請もあって外国人に帰国を促したという。外国人利用者の半分ぐらいが自分たちの国に帰ってしまい、施設の運用コストを維持できなくなった。バリ島は今後の成長が見込まれていることから数年前から外資が入ってきて土地や家賃が急騰しているために利用者が激減すると運用コストを維持できなくなったとのこと。&lt;/p>
&lt;p>肝心のバリ島のコワーキングスペースの雰囲気を聞いていると、利用者は外国人が大半で、感覚的にはヨーロッパから来ている人が多そうだといとうさんが話された。バリ島のコワーキングスペースでいとうさんが見学していたときには、現地の人たちと外国人のコミュニティが活発に活動しているようにはあまりみえなかったらしい。利用者もそう多くはなかったし、その人たちも静かにただ作業しているだけのように映ったという。いとうさんはコワーキングスペースとはコミュニティやコラボレーションが重要という話しをよくしているけれど、バリ島のコワーキングスペースに関しては裕福な外国のデジタルノマドを呼び込むのに成功しただけのような、もしかしたらコロナ禍でそのコミュニティが破壊されてしまったのかもしれないが、普段このイベントで話しているような高い期待値に応えられるような状況ではないようにみえたという。&lt;/p>
&lt;p>とはいえ、日本の田舎よりは遥かにデジタルノマドが集まる場所として世界的に認知されているところなので写真をみながら私もいつか行ってみたいと思えた。&lt;/p></content></item><item><title>集中のち寝不足</title><link>/diary/posts/2023/0206/</link><pubDate>Mon, 06 Feb 2023 09:21:43 +0900</pubDate><guid>/diary/posts/2023/0206/</guid><description>1時に帰ってきてそのまま寝ないで6時10分の新幹線に乗ってから2時間半ほど寝た。これはこれで時間の使い方が有意義な気がする。午前中は翌日の定例会議の準備を着々と進めて、ci/cd 環境の改善、午後からリファクタリングなどをやっていた。15時をまわると眠くなってきて散歩したりして気分転換しつつも体調悪いなと思って17時半にお仕事を終えてホテルへ戻って2-3時間ほど寝てた。その後、晩ご飯食べるかなと出掛けたものの、あまり食欲もなくて、2時間ほど付近を散歩して運動していた。たまにはそういうのもいいか。飲食店が多い地域なので外から眺めているだけでもわりと楽しい。
ssh 経由のデプロイ これまで ci/cd でテストして docker イメージをビルドしてコンテナレジストリに登録するところまでやっていた。実際にテスト環境にデプロイするときは、テスト環境にログインして更新用のスクリプトを私が手動実行していた。そんなに頻繁にテスト環境を更新する必要がなかったのでそれでも十分ではあるものの、ci/cd の完成形を目指すなら自動化すべきという考え方もあってデプロイの部分を作ることにした。
もっとも簡単な方法として Using SSH keys with GitLab CI/CD をみながら、ssh でテスト環境にデプロイすることにした。すでに更新用のスクリプトがあって、テスト環境にログインして実行すればできる状態なので ssh さえ使えればすぐに移行できるという話しでもある。openssh-client を使うためにベースイメージを alpine から ubuntu にしてパッケージをインストールしないといけない。実行時間がややかかるというコスト以外には気にならないかな。ssh の秘密鍵を file 種別でもつのか通常の環境変数でもつのかで扱いが異なって、それに少しはまったぐらいですぐできた。今後は docker イメージのビルド単位に自動的にデプロイされるようになる。
interface{} の型エイリアスとしての any go のコードをリファクタリングしていて json.Marshal の引数が any となっていることに気付いた。
func Marshal(v any) ([]byte, error) { ... } go 1.18 以降で interface{} の型エイリアスとして any が定義されているらしい。任意の型を扱えるシグネチャとして、メソッドの振る舞いのみを規定する interface{} を使うというのは型システムとしては正しい。他言語でいえば object に相当するものが go はオブジェクト指向言語ではないのでそれがない。そういう間違っていないけど、わかりにくいなと思っていたものに any という名前の型エイリアスが導入されてとてもしっくりきた。プログラミングしていて、実務的にどうかというところをちゃんと改善していくところがみえるのは楽しい。
type any = interface{} Go 1.18 で interface{} の代わりに any が使えるようになる話</description><content>&lt;p>1時に帰ってきてそのまま寝ないで6時10分の新幹線に乗ってから2時間半ほど寝た。これはこれで時間の使い方が有意義な気がする。午前中は翌日の定例会議の準備を着々と進めて、ci/cd 環境の改善、午後からリファクタリングなどをやっていた。15時をまわると眠くなってきて散歩したりして気分転換しつつも体調悪いなと思って17時半にお仕事を終えてホテルへ戻って2-3時間ほど寝てた。その後、晩ご飯食べるかなと出掛けたものの、あまり食欲もなくて、2時間ほど付近を散歩して運動していた。たまにはそういうのもいいか。飲食店が多い地域なので外から眺めているだけでもわりと楽しい。&lt;/p>
&lt;h2 id="ssh-経由のデプロイ">ssh 経由のデプロイ&lt;/h2>
&lt;p>これまで ci/cd でテストして docker イメージをビルドしてコンテナレジストリに登録するところまでやっていた。実際にテスト環境にデプロイするときは、テスト環境にログインして更新用のスクリプトを私が手動実行していた。そんなに頻繁にテスト環境を更新する必要がなかったのでそれでも十分ではあるものの、ci/cd の完成形を目指すなら自動化すべきという考え方もあってデプロイの部分を作ることにした。&lt;/p>
&lt;p>もっとも簡単な方法として &lt;a href="https://docs.gitlab.com/ee/ci/ssh_keys/">Using SSH keys with GitLab CI/CD&lt;/a> をみながら、ssh でテスト環境にデプロイすることにした。すでに更新用のスクリプトがあって、テスト環境にログインして実行すればできる状態なので ssh さえ使えればすぐに移行できるという話しでもある。openssh-client を使うためにベースイメージを alpine から ubuntu にしてパッケージをインストールしないといけない。実行時間がややかかるというコスト以外には気にならないかな。ssh の秘密鍵を &lt;code>file&lt;/code> 種別でもつのか通常の環境変数でもつのかで扱いが異なって、それに少しはまったぐらいですぐできた。今後は docker イメージのビルド単位に自動的にデプロイされるようになる。&lt;/p>
&lt;h2 id="interface-の型エイリアスとしての-any">interface{} の型エイリアスとしての any&lt;/h2>
&lt;p>go のコードをリファクタリングしていて json.Marshal の引数が &lt;code>any&lt;/code> となっていることに気付いた。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">Marshal&lt;/span>(&lt;span style="color:#a6e22e">v&lt;/span> &lt;span style="color:#a6e22e">any&lt;/span>) ([]&lt;span style="color:#66d9ef">byte&lt;/span>, &lt;span style="color:#66d9ef">error&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>go 1.18 以降で &lt;code>interface{}&lt;/code> の型エイリアスとして &lt;code>any&lt;/code> が定義されているらしい。任意の型を扱えるシグネチャとして、メソッドの振る舞いのみを規定する &lt;code>interface{}&lt;/code> を使うというのは型システムとしては正しい。他言語でいえば object に相当するものが go はオブジェクト指向言語ではないのでそれがない。そういう間違っていないけど、わかりにくいなと思っていたものに &lt;code>any&lt;/code> という名前の型エイリアスが導入されてとてもしっくりきた。プログラミングしていて、実務的にどうかというところをちゃんと改善していくところがみえるのは楽しい。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">any&lt;/span> = &lt;span style="color:#66d9ef">interface&lt;/span>{}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;a href="https://zenn.dev/syumai/articles/c6q5un1j0msim0aj0ca0">Go 1.18 で interface{} の代わりに any が使えるようになる話&lt;/a>&lt;/li>
&lt;/ul></content></item><item><title>思い立ったらドキュメントを公開</title><link>/diary/posts/2023/0130/</link><pubDate>Mon, 30 Jan 2023 13:02:58 +0900</pubDate><guid>/diary/posts/2023/0130/</guid><description>23時に寝て2時頃に少し吐いて起きた。夜遅めに日本酒飲んでいい気分で寝たものの、もう夜に食べたらダメな体になりつつある。4時ぐらいまで起きててそれから寝て7時に起きた。
echo の静的ファイルの扱い web api のドキュメントは openapi スキーマを使って生成 している。本当はこのドキュメントを gitlab pages で公開させたいのだけど、まだそのインフラ構築ができていなくて先送りになっている。いつもローカルで gitlab ci/cd がビルドしたドキュメントをみていたのだけど、ある機能開発をするときにローカルで web api ドキュメントみるの飽きたなと思って、web api サーバーに同梱してしまえと思い立った。テスト環境の web api サーバーは常に動いているのだから、そこに web api のドキュメントが同梱されていて、なんの不都合があろうか？ (いや、なにもない) 。
次のドキュメントに echo で静的ファイルを扱う方法が書いてある。
Static Files ミドルウェアで実装されているようで簡単に静的ファイルを返せる。指定したパスのディレクトリ配下を扱えるのが Static で、指定したパスのファイルを扱うのが File になる。web api ドキュメントのようなものならキャッシュしてもいいなとは思ったものの、次の issue によると v4 ではミドルウェアで自前実装しないといけないらしい。v5 ではその仕組みが echo の機能として入るかもしれない。
TTL (Cache-Control header in response) for static files #1902 その後、gitlab ci/cd で web api サーバーのビルド後、openapi.yml からドキュメント生成をして、任意の static ディレクトリに配置するように設定した。docker のマルチステージビルドを使うと簡単にできる。バックエンドやっていて、サーバーとインフラの両方に手を入れて機能を作っていくときの、うまくできると利便性と達成感の両方を得られるのが楽しい。web api サーバーがドキュメントを提供することは、要件に含まれるわけでも、誰かに指示されたわけでもない。私が勝手にローカルでドキュメントみるの飽きたと思って、勝手に作って、勝手に動くようにしただけ。こういう開発の遊びのゆとりや権限をチームのメンバーにも与えられるようにしていきたい。開発が楽しくて悪いことはなにもないと思うんよね。</description><content>&lt;p>23時に寝て2時頃に少し吐いて起きた。夜遅めに日本酒飲んでいい気分で寝たものの、もう夜に食べたらダメな体になりつつある。4時ぐらいまで起きててそれから寝て7時に起きた。&lt;/p>
&lt;h2 id="echo-の静的ファイルの扱い">echo の静的ファイルの扱い&lt;/h2>
&lt;p>web api のドキュメントは &lt;a href="/diary/diary/posts/2022/1216/#openapi-勉強会">openapi スキーマを使って生成&lt;/a> している。本当はこのドキュメントを gitlab pages で公開させたいのだけど、まだそのインフラ構築ができていなくて先送りになっている。いつもローカルで gitlab ci/cd がビルドしたドキュメントをみていたのだけど、ある機能開発をするときにローカルで web api ドキュメントみるの飽きたなと思って、web api サーバーに同梱してしまえと思い立った。テスト環境の web api サーバーは常に動いているのだから、そこに web api のドキュメントが同梱されていて、なんの不都合があろうか？ (いや、なにもない) 。&lt;/p>
&lt;p>次のドキュメントに echo で静的ファイルを扱う方法が書いてある。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://echo.labstack.com/guide/static-files/">Static Files&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>ミドルウェアで実装されているようで簡単に静的ファイルを返せる。指定したパスのディレクトリ配下を扱えるのが &lt;code>Static&lt;/code> で、指定したパスのファイルを扱うのが &lt;code>File&lt;/code> になる。web api ドキュメントのようなものならキャッシュしてもいいなとは思ったものの、次の issue によると v4 ではミドルウェアで自前実装しないといけないらしい。v5 ではその仕組みが echo の機能として入るかもしれない。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/labstack/echo/issues/1902">TTL (Cache-Control header in response) for static files #1902&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>その後、gitlab ci/cd で web api サーバーのビルド後、openapi.yml からドキュメント生成をして、任意の static ディレクトリに配置するように設定した。docker のマルチステージビルドを使うと簡単にできる。バックエンドやっていて、サーバーとインフラの両方に手を入れて機能を作っていくときの、うまくできると利便性と達成感の両方を得られるのが楽しい。web api サーバーがドキュメントを提供することは、要件に含まれるわけでも、誰かに指示されたわけでもない。私が勝手にローカルでドキュメントみるの飽きたと思って、勝手に作って、勝手に動くようにしただけ。こういう開発の遊びのゆとりや権限をチームのメンバーにも与えられるようにしていきたい。開発が楽しくて悪いことはなにもないと思うんよね。&lt;/p></content></item><item><title>dind をやってみた</title><link>/diary/posts/2022/1219/</link><pubDate>Mon, 19 Dec 2022 11:28:33 +0900</pubDate><guid>/diary/posts/2022/1219/</guid><description>3時に寝て7時半に起きた。最後なのでワールドカップの決勝戦をみてた。接戦で試合もおもしろかったしよかったと思う。
gitlab ci/cd で docker in docker ミドルウェアを伴う結合テストは dockertest というツールを使って docker でミドルウェアを起動して実行している。デフォルトで作成した gitlab runner で docker を使おうとすると失敗する。これは gitlab runner が ci/cd ジョブを docker で動かすため docker in docker (これを dind と呼ぶらしい) のための設定が必要になる。大雑把に言えば gitlab runner にそのための権限を設定する必要がある。gitlab の次のドキュメントに詳細が書いてある。
Use Docker-in-Docker gitlab runner に権限を設定したら次のような job が動けば docker in docker は成功と言える。
hello-dind: stage: test image: docker:20.10.21 variables: DOCKER_HOST: tcp://docker:2375 DOCKER_TLS_CERTDIR: &amp;#34;&amp;#34; services: - docker:20.10.21-dind allow_failure: true before_script: - docker info script: - docker run hello-world あとになって気付いたことだけど、dockertest の README にも Running dockertest in Gitlab CI としていくつか tips が紹介されている。dockertest で作成したリソースからホスト名とポート番号を取得するには次のようなユーティリティを使う必要がある。</description><content>&lt;p>3時に寝て7時半に起きた。最後なのでワールドカップの決勝戦をみてた。接戦で試合もおもしろかったしよかったと思う。&lt;/p>
&lt;h2 id="gitlab-cicd-で-docker-in-docker">gitlab ci/cd で docker in docker&lt;/h2>
&lt;p>ミドルウェアを伴う結合テストは &lt;a href="https://github.com/ory/dockertest">dockertest&lt;/a> というツールを使って docker でミドルウェアを起動して実行している。デフォルトで作成した gitlab runner で docker を使おうとすると失敗する。これは gitlab runner が ci/cd ジョブを docker で動かすため docker in docker (これを &lt;em>dind&lt;/em> と呼ぶらしい) のための設定が必要になる。大雑把に言えば gitlab runner にそのための権限を設定する必要がある。gitlab の次のドキュメントに詳細が書いてある。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.gitlab.com/ee/ci/docker/using_docker_build.html#use-docker-in-docker">Use Docker-in-Docker&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>gitlab runner に権限を設定したら次のような job が動けば docker in docker は成功と言える。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yml" data-lang="yml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">hello-dind&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">stage&lt;/span>: &lt;span style="color:#ae81ff">test&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">image&lt;/span>: &lt;span style="color:#ae81ff">docker:20.10.21&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">variables&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">DOCKER_HOST&lt;/span>: &lt;span style="color:#ae81ff">tcp://docker:2375&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">DOCKER_TLS_CERTDIR&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">services&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">docker:20.10.21-dind&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">allow_failure&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">before_script&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">docker info&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">script&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">docker run hello-world&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>あとになって気付いたことだけど、dockertest の README にも &lt;a href="https://github.com/ory/dockertest#running-dockertest-in-gitlab-ci">Running dockertest in Gitlab CI&lt;/a> としていくつか tips が紹介されている。dockertest で作成したリソースからホスト名とポート番号を取得するには次のようなユーティリティを使う必要がある。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">getHostPort&lt;/span>(&lt;span style="color:#a6e22e">resource&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">dockertest&lt;/span>.&lt;span style="color:#a6e22e">Resource&lt;/span>, &lt;span style="color:#a6e22e">id&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>) &lt;span style="color:#66d9ef">string&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">dockerURL&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">os&lt;/span>.&lt;span style="color:#a6e22e">Getenv&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;DOCKER_HOST&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">dockerURL&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">resource&lt;/span>.&lt;span style="color:#a6e22e">GetHostPort&lt;/span>(&lt;span style="color:#a6e22e">id&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">u&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">url&lt;/span>.&lt;span style="color:#a6e22e">Parse&lt;/span>(&lt;span style="color:#a6e22e">dockerURL&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> panic(&lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">u&lt;/span>.&lt;span style="color:#a6e22e">Hostname&lt;/span>() &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;:&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">resource&lt;/span>.&lt;span style="color:#a6e22e">GetPort&lt;/span>(&lt;span style="color:#a6e22e">id&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></content></item><item><title>openapi-ext-tools をまた使う日がきた</title><link>/diary/posts/2022/1210/</link><pubDate>Sat, 10 Dec 2022 12:03:13 +0900</pubDate><guid>/diary/posts/2022/1210/</guid><description>0時に寝て4時に起きて7時に起きた。わりとよく眠れた。
ストレッチ トレーナーさんと月曜日の日本対クロアチア戦の感想を話したりしていた。今日の開脚幅は開始前153cmで、ストレッチ後156cmだった。先週は疲弊と疲労で散々な数値になっていたものが復調してきつつある。今週も毎日8-22時はオフィスで缶詰め状態だった。たくさん座っている (同じ体勢でいる) 時間が増えると筋肉にはよくない。まだまだ右腰と右太もも周りの張りは強く復調にはもう少し時間がかかるようにみえる。一方で忙しさのピークを越したと思うので今週以降は少しペースダウンしながら体作りをしていく。いまお手伝いしている開発は12月にすべての集中力を費やしてもよいと考えている。残りは期間はメンバーに委譲するような体制になるとベストかもしれない。そのための体力づくりは重要。
openapi-ext-tools 再び github pages ならぬ gitlab pages がある。ふと web api のドキュメントを作るために openapi のスキーマを定義したら gitlab の ci/cd と連携できていいんじゃないかと思い付いた。スキーマがあればフロントエンドのクライアント生成や e2e テストコードの自動生成などに使えるかもしれないし。過去に作った openapi-ext-tools を oss にしておいたからいまも使える。oss 万歳。先のことはわからない。redoc を使ってちゃっちゃと実装した。
pages: only: changes: - schema/* stage: deploy image: alpine:latest before_script: - apk --no-cache add python3 nodejs npm - python --version - python -m ensurepip - pip3 --version - node --version - npm --version - npm install --global redoc-cli - redoc-cli --version - pip3 install openapi-ext-tools - pip3 freeze openapi-ext-tools | grep openapi script: - openapi-spec-cli --spec-path schema/openapi.</description><content>&lt;p>0時に寝て4時に起きて7時に起きた。わりとよく眠れた。&lt;/p>
&lt;h2 id="ストレッチ">ストレッチ&lt;/h2>
&lt;p>トレーナーさんと月曜日の日本対クロアチア戦の感想を話したりしていた。今日の開脚幅は開始前153cmで、ストレッチ後156cmだった。先週は疲弊と疲労で散々な数値になっていたものが復調してきつつある。今週も毎日8-22時はオフィスで缶詰め状態だった。たくさん座っている (同じ体勢でいる) 時間が増えると筋肉にはよくない。まだまだ右腰と右太もも周りの張りは強く復調にはもう少し時間がかかるようにみえる。一方で忙しさのピークを越したと思うので今週以降は少しペースダウンしながら体作りをしていく。いまお手伝いしている開発は12月にすべての集中力を費やしてもよいと考えている。残りは期間はメンバーに委譲するような体制になるとベストかもしれない。そのための体力づくりは重要。&lt;/p>
&lt;h2 id="openapi-ext-tools-再び">openapi-ext-tools 再び&lt;/h2>
&lt;p>github pages ならぬ &lt;a href="https://docs.gitlab.com/ee/user/project/pages/">gitlab pages&lt;/a> がある。ふと web api のドキュメントを作るために openapi のスキーマを定義したら gitlab の ci/cd と連携できていいんじゃないかと思い付いた。スキーマがあればフロントエンドのクライアント生成や e2e テストコードの自動生成などに使えるかもしれないし。過去に作った &lt;a href="https://pypi.org/project/openapi-ext-tools/">openapi-ext-tools&lt;/a> を oss にしておいたからいまも使える。oss 万歳。先のことはわからない。&lt;a href="https://github.com/Redocly/redoc">redoc&lt;/a> を使ってちゃっちゃと実装した。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yml" data-lang="yml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">pages&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">only&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">changes&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">schema/*&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">stage&lt;/span>: &lt;span style="color:#ae81ff">deploy&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">image&lt;/span>: &lt;span style="color:#ae81ff">alpine:latest&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">before_script&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">apk --no-cache add python3 nodejs npm&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">python --version&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">python -m ensurepip&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">pip3 --version&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">node --version&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">npm --version&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">npm install --global redoc-cli&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">redoc-cli --version&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">pip3 install openapi-ext-tools&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">pip3 freeze openapi-ext-tools | grep openapi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">script&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">openapi-spec-cli --spec-path schema/openapi.yml&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - |+&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> redoc-cli bundle bundled_openapi.yaml \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> --output index.html \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> --options.expandResponses=all \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> --options.requiredPropsFirst=true \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> --options.jsonSampleExpandLevel=10 \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> --options.hideLoading=true \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> --options.pathInMiddlePanel=true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">mkdir -p public&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">mv index.html public/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">artifacts&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">paths&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">public&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>久しぶりに触ったら openapi-ext-tools が依存ライブラリの変更で動かなくなっていたので直した。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/t2y/openapi-ext-tools/issues/1">cannot import name &amp;lsquo;ValidationError&amp;rsquo; from &amp;lsquo;openapi_spec_validator.exceptions&amp;rsquo; #1&lt;/a>&lt;/li>
&lt;/ul></content></item><item><title>gitlab の ci/cd 入門</title><link>/diary/posts/2022/1207/</link><pubDate>Wed, 07 Dec 2022 19:52:19 +0900</pubDate><guid>/diary/posts/2022/1207/</guid><description>0時に寝て3時に起きてそのまま眠れずにいたら6時になって7時過ぎから準備してオフィス行ってお仕事を始めた。
gitlab の ci/cd の調査 初めて GitLab CI/CD を触っている。まだ触り始めたばかりだが、感覚的には github actions 相当の機能はあるようにみえる。ソースコードリポジトリやパッケージリポジトリ／コンテナレジストリと ci/cd がセットになっているととても便利だ。これはすごいことだと最近思うようになってきた。もはやソースコードリポジトリのみのホスティングビジネスは成り立たない。なぜなら github や gitlab のような ci/cd が当たり前になってしまうと、その機能がない場合、デメリットを上回るメリットがないとそんなソースコードリポジトリを選択しない。
docker image をビルドして push する仕組みは既にメンバーが作ってくれていたのでその後始末の処理を作った。Container Registry API を使うと、不要な docker image を削除できる。
Delete registry repository tags in bulk 削除向けに便利な api 設計になっている。こういう細かい配慮は嬉しい。keep_n で最低限残すイメージ数を指定して older_than で過去何日より古いイメージを削除対象とするといったよくある運用の設定ができる。
curl -s -H &amp;#34;PRIVATE-TOKEN: $PROJECT_ACCESS_TOKEN&amp;#34; -X DELETE &amp;#34;${endpoint}&amp;#34; \ --data &amp;#34;name_regex_delete=.*&amp;#34; \ --data &amp;#34;keep_n=${KEEP_N}&amp;#34; \ --data &amp;#34;older_than=${OLDER_THAN}&amp;#34; あとは認証のトークンを指定する方法として私が調べた限りだと2通りある。
(ci_job_token_scope の feature flag を有効にして) $CI_JOB_TOKEN を使う こっちの方が一時トークンなのでよりセキュアなはず この場合はヘッダーに JOB-TOKEN を指定する プロジェクトレベルのアクセストークン を発行して ci/cd の variables に登録する トークンが漏洩したときにプロジェクトレベルで被害が発生する この場合はヘッダーに PRIVATE-TOKEN を指定する 使うトークンによってヘッダーが変わるというのがちょっと変な認証の設計にもみえるけど、まぁそれぐらいしか気にはならない。</description><content>&lt;p>0時に寝て3時に起きてそのまま眠れずにいたら6時になって7時過ぎから準備してオフィス行ってお仕事を始めた。&lt;/p>
&lt;h2 id="gitlab-の-cicd-の調査">gitlab の ci/cd の調査&lt;/h2>
&lt;p>初めて &lt;a href="https://docs.gitlab.com/ee/ci/">GitLab CI/CD&lt;/a> を触っている。まだ触り始めたばかりだが、感覚的には github actions 相当の機能はあるようにみえる。ソースコードリポジトリやパッケージリポジトリ／コンテナレジストリと ci/cd がセットになっているととても便利だ。これはすごいことだと最近思うようになってきた。もはやソースコードリポジトリのみのホスティングビジネスは成り立たない。なぜなら github や gitlab のような ci/cd が当たり前になってしまうと、その機能がない場合、デメリットを上回るメリットがないとそんなソースコードリポジトリを選択しない。&lt;/p>
&lt;p>docker image をビルドして push する仕組みは既にメンバーが作ってくれていたのでその後始末の処理を作った。&lt;a href="https://docs.gitlab.com/ee/api/container_registry.html">Container Registry API&lt;/a> を使うと、不要な docker image を削除できる。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.gitlab.com/ee/api/container_registry.html#delete-registry-repository-tags-in-bulk">Delete registry repository tags in bulk&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>削除向けに便利な api 設計になっている。こういう細かい配慮は嬉しい。&lt;code>keep_n&lt;/code> で最低限残すイメージ数を指定して &lt;code>older_than&lt;/code> で過去何日より古いイメージを削除対象とするといったよくある運用の設定ができる。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>curl -s -H &lt;span style="color:#e6db74">&amp;#34;PRIVATE-TOKEN: &lt;/span>$PROJECT_ACCESS_TOKEN&lt;span style="color:#e6db74">&amp;#34;&lt;/span> -X DELETE &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>endpoint&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --data &lt;span style="color:#e6db74">&amp;#34;name_regex_delete=.*&amp;#34;&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --data &lt;span style="color:#e6db74">&amp;#34;keep_n=&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>KEEP_N&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --data &lt;span style="color:#e6db74">&amp;#34;older_than=&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>OLDER_THAN&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>あとは認証のトークンを指定する方法として私が調べた限りだと2通りある。&lt;/p>
&lt;ul>
&lt;li>(&lt;code>ci_job_token_scope&lt;/code> の feature flag を有効にして) &lt;code>$CI_JOB_TOKEN&lt;/code> を使う
&lt;ul>
&lt;li>こっちの方が一時トークンなのでよりセキュアなはず&lt;/li>
&lt;li>この場合はヘッダーに JOB-TOKEN を指定する&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://docs.gitlab.com/ee/user/project/settings/project_access_tokens.html">プロジェクトレベルのアクセストークン&lt;/a> を発行して ci/cd の variables に登録する
&lt;ul>
&lt;li>トークンが漏洩したときにプロジェクトレベルで被害が発生する&lt;/li>
&lt;li>この場合はヘッダーに PRIVATE-TOKEN を指定する&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>使うトークンによってヘッダーが変わるというのがちょっと変な認証の設計にもみえるけど、まぁそれぐらいしか気にはならない。&lt;/p></content></item><item><title>久しぶりにブログを書いた</title><link>/diary/posts/2022/0731/</link><pubDate>Sun, 31 Jul 2022 13:06:19 +0900</pubDate><guid>/diary/posts/2022/0731/</guid><description>2時過ぎに寝て7時に起きて9時まで寝てた。
もてなしだけではもう食えない 読み進めておもしろかったし学びにもなったので書評を書いた。
もてなしだけではもう食えない -ホテル経営学の本質と実践- backlog-github-integration-action v1.0.1 リリース backlog-github-integration-action のバグ修正 した変更を v1.0.1 としてリリースした。2週間ほど検証環境でリグレッションがないかをみていた。問題なさそうなので v1 ブランチにマージして docker イメージを push して v1.0.1 タグを付けてリリース成果物を作成した。久しぶりにやると手順を忘れていてドキュメントを書かないといけないなとか思ったりした。
backlog-github-integration-action</description><content>&lt;p>2時過ぎに寝て7時に起きて9時まで寝てた。&lt;/p>
&lt;h2 id="もてなしだけではもう食えない">もてなしだけではもう食えない&lt;/h2>
&lt;p>読み進めておもしろかったし学びにもなったので書評を書いた。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://note.com/t2y1979/n/nc5c156ae529e">もてなしだけではもう食えない -ホテル経営学の本質と実践-&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="backlog-github-integration-action-v101-リリース">backlog-github-integration-action v1.0.1 リリース&lt;/h2>
&lt;p>&lt;a href="/diary/diary/posts/2022/0710/#backlog-github-integration-action-のバグ修正">backlog-github-integration-action のバグ修正&lt;/a> した変更を v1.0.1 としてリリースした。2週間ほど検証環境でリグレッションがないかをみていた。問題なさそうなので v1 ブランチにマージして docker イメージを push して v1.0.1 タグを付けてリリース成果物を作成した。久しぶりにやると手順を忘れていてドキュメントを書かないといけないなとか思ったりした。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/marketplace/actions/backlog-github-integration-action">backlog-github-integration-action&lt;/a>&lt;/li>
&lt;/ul></content></item><item><title>意図がわかる設計とリファクタリング</title><link>/diary/posts/2022/0714/</link><pubDate>Thu, 14 Jul 2022 08:14:28 +0900</pubDate><guid>/diary/posts/2022/0714/</guid><description>1時に寝て7時に起きた。久しぶりに HELLSING をみてた。アレクサンド・アンデルセンの狂信者ノリが好き。
煩雑な保守 昨日から着手した s3 とやり取りするアプリケーションの保守をしている。一通り機能は実装できたが、このアプリケーションの保守を今後どうやっていけばいいのかが私からはみえない。要件が変わる度に継ぎ接ぎで拡張してきて、意図をもった設計があるわけではないようにみえる。このまま保守することはできるかもしれないが、このロジックの説明もテストも検証もすべてが難しい。私がみても難しいのだから、経験の浅い開発者がみるともっと難しいのではないかと思う。
これを直すにはまず単体テストを直さないといけない。単体テストの大半がモックベースなので実際の振る舞いと異なる可能性がある。とくに s3 とやり取りするところの検証ができない。testcontainers の localstack があるので単体テストはモックからこのモジュールを使うように代替できそう。まずはそこからやるべきだが、2-3日はかかると見込まれるのでチームで承認を得られるかどうか、ちょっと聞いてみてから考える。
Job Summary を使ってみた ちょっと前に github actions のワークフローの実行画面にサマリを出力できるようになったという記事をみた。
Supercharging GitHub Actions with Job Summaries 自動でよさげなサマリを出力してくれるわけではなく、自分でサマリを作らないといけないので面倒だなと思ってそのまま放置していた。先週末に モジュール別のビルド・デプロイのワークフロー改善 を行った。ふとワークフローの実行結果をみていて、選択したモジュール名が表示されているとわかりやすくていいなと思えた。それを出力する手段としてサマリがちょうどいいやということに気付いた。inputs などで動的に変更するパラメーターをワークフローの実行画面で確認できるといちいちログ確認する手間が省けてよいという場面が他の用途でもある気がしてきた。もっと積極的にサマリを使っていこうと思えた瞬間だった。</description><content>&lt;p>1時に寝て7時に起きた。久しぶりに &lt;a href="https://www.nbcuni.co.jp/rondorobe/anime/hellsing/">HELLSING&lt;/a> をみてた。アレクサンド・アンデルセンの狂信者ノリが好き。&lt;/p>
&lt;h2 id="煩雑な保守">煩雑な保守&lt;/h2>
&lt;p>昨日から着手した s3 とやり取りするアプリケーションの保守をしている。一通り機能は実装できたが、このアプリケーションの保守を今後どうやっていけばいいのかが私からはみえない。要件が変わる度に継ぎ接ぎで拡張してきて、意図をもった設計があるわけではないようにみえる。このまま保守することはできるかもしれないが、このロジックの説明もテストも検証もすべてが難しい。私がみても難しいのだから、経験の浅い開発者がみるともっと難しいのではないかと思う。&lt;/p>
&lt;p>これを直すにはまず単体テストを直さないといけない。単体テストの大半がモックベースなので実際の振る舞いと異なる可能性がある。とくに s3 とやり取りするところの検証ができない。&lt;a href="https://www.testcontainers.org/modules/localstack/">testcontainers の localstack&lt;/a> があるので単体テストはモックからこのモジュールを使うように代替できそう。まずはそこからやるべきだが、2-3日はかかると見込まれるのでチームで承認を得られるかどうか、ちょっと聞いてみてから考える。&lt;/p>
&lt;h2 id="job-summary-を使ってみた">Job Summary を使ってみた&lt;/h2>
&lt;p>ちょっと前に github actions のワークフローの実行画面にサマリを出力できるようになったという記事をみた。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.blog/2022-05-09-supercharging-github-actions-with-job-summaries/">Supercharging GitHub Actions with Job Summaries&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>自動でよさげなサマリを出力してくれるわけではなく、自分でサマリを作らないといけないので面倒だなと思ってそのまま放置していた。先週末に &lt;a href="/diary/diary/posts/2022/0709/#github-actions-の-push-イベントワークフロー改善">モジュール別のビルド・デプロイのワークフロー改善&lt;/a> を行った。ふとワークフローの実行結果をみていて、選択したモジュール名が表示されているとわかりやすくていいなと思えた。それを出力する手段としてサマリがちょうどいいやということに気付いた。inputs などで動的に変更するパラメーターをワークフローの実行画面で確認できるといちいちログ確認する手間が省けてよいという場面が他の用途でもある気がしてきた。もっと積極的にサマリを使っていこうと思えた瞬間だった。&lt;/p></content></item><item><title>放置していたバグを直した</title><link>/diary/posts/2022/0710/</link><pubDate>Sun, 10 Jul 2022 11:51:06 +0900</pubDate><guid>/diary/posts/2022/0710/</guid><description>1時に寝て7時に起きた。寝ていて夜中に吐き気して眠れなくて上体を起こすしかなかった。たまにある 胃食道逆流症 のひどいやつ。
参議院選挙 普段は期日前投票で済ませるのだけど、今週は他のことに注意を取られていたせいか、当日行ってきた。場所が期日前と違ったので勝手がわからなかったけど、とくに混雑もしてなかったのですぐに完了できた。タイムラインを眺めると、私のタイムライン上では投票したと発言する人が増えてきたように思う。投票率が50%程度で半分ぐらいの人が投票していない状況に懸念をもつ人たちの可視化がされている。
ふと父の選挙はどうなるんだろう？と思って検索してみた。意思表示できない状態だと選挙はできないみたい。
選挙人本人が投票所に行き自らの意思で投票することが原則であることから、意思表示が困難である場合には投票することはできません。これは投票所の係員が選挙人の投票を補助する代理投票においても同様です。したがって、家族の方が本人に代わって投票することはできません。
神戸市 FAQ &amp;gt; 市政情報 &amp;gt; 選挙
70歳以上は傷病で選挙権を行使できない人たちもいるだろうから減るのかな？と、総務省の 年代別投票率 のグラフを確認してみた。直近だと、70歳以上が61.96, 60歳代が71.43、50歳代が62.96だった。60歳代と比べて減ってはいるけど、50歳代とそう変わらないのをみると、元気な人たちに選挙へ行こうと呼びかけるのは正しい気がした。
backlog-github-integration-action のバグ修正 運用してすぐにコミットメッセージ中にシングルクォートやダブルクォートが含まれると引数を正しくパースできなくてエラーになることがわかっていた。いま運用している環境の用途だと、それほど重要ではないので後回しにしているうちに面倒になって放置していた。晩ご飯を食べてからデバッグしていたら7時間ぐらいやってた。
push subcommand is failed when a commit message includes single quote or double quote #6 bash 上の文字列の扱いと action.yml の inputs の args に引数渡しするときの振る舞いの勘違いもあって、issue の見た目以上に複雑な振る舞いをしていることがわかった。github actions 上のコンテキストに依存したくなかったため、github.event.commits の json をそのまま cli パラメーターとして渡している。bash 上の json 文字列と cli パラメーターとしての扱いが煩雑になるのでこのやり方は失敗だったかもしれない。ローカルでのテストもやりにくい。私はそのことをよく理解していたはずなのに github actoins 上のアンチパターンにはまってしまった。カスタムアクションのユーザーが簡単に使えるように cli パラメーターの設定を簡単にする意図で json 渡しにしたんだけど、エスケープの振る舞いが想像以上にややこしくなって、エスケープしたいユーザーには簡単ではなくなってしまった。それでもデバッグをがんばったおかげでシングルクォートは完全に使えるように実装できた。ダブルクォートは制限付きでエラーにならなくできるが、事実上は使わないでくださいといった仕様制限にしてしまおうと思う。引用するときはダブルクォートじゃなくてシングルクォートを使ってくださいと啓蒙することに決めた。</description><content>&lt;p>1時に寝て7時に起きた。寝ていて夜中に吐き気して眠れなくて上体を起こすしかなかった。たまにある &lt;a href="/diary/diary/posts/2021/1114/#傾斜枕">胃食道逆流症&lt;/a> のひどいやつ。&lt;/p>
&lt;h2 id="参議院選挙">参議院選挙&lt;/h2>
&lt;p>普段は期日前投票で済ませるのだけど、今週は他のことに注意を取られていたせいか、当日行ってきた。場所が期日前と違ったので勝手がわからなかったけど、とくに混雑もしてなかったのですぐに完了できた。タイムラインを眺めると、私のタイムライン上では投票したと発言する人が増えてきたように思う。投票率が50%程度で半分ぐらいの人が投票していない状況に懸念をもつ人たちの可視化がされている。&lt;/p>
&lt;figure>&lt;img src="/diary/diary/img/2022/0710_voted.jpg"/>
&lt;/figure>
&lt;p>ふと父の選挙はどうなるんだろう？と思って検索してみた。意思表示できない状態だと選挙はできないみたい。&lt;/p>
&lt;blockquote>
&lt;p>選挙人本人が投票所に行き自らの意思で投票することが原則であることから、意思表示が困難である場合には投票することはできません。これは投票所の係員が選挙人の投票を補助する代理投票においても同様です。したがって、家族の方が本人に代わって投票することはできません。&lt;/p>
&lt;p>&lt;a href="https://help.city.kobe.lg.jp/hc/ja/articles/4488187002767-%E6%84%8F%E6%80%9D%E8%A1%A8%E7%A4%BA%E3%81%8C%E5%9B%B0%E9%9B%A3%E3%81%AA%E9%81%B8%E6%8C%99%E4%BA%BA%E3%81%AB%E4%BB%A3%E3%82%8F%E3%81%A3%E3%81%A6-%E5%AE%B6%E6%97%8F%E3%81%8C%E6%8A%95%E7%A5%A8%E3%81%99%E3%82%8B%E6%96%B9%E6%B3%95%E3%81%AF%E3%81%82%E3%82%8A%E3%81%BE%E3%81%99%E3%81%8B-">神戸市 FAQ &amp;gt; 市政情報 &amp;gt; 選挙&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>70歳以上は傷病で選挙権を行使できない人たちもいるだろうから減るのかな？と、総務省の &lt;a href="https://www.soumu.go.jp/senkyo/senkyo_s/news/sonota/nendaibetu/">年代別投票率&lt;/a> のグラフを確認してみた。直近だと、70歳以上が61.96, 60歳代が71.43、50歳代が62.96だった。60歳代と比べて減ってはいるけど、50歳代とそう変わらないのをみると、元気な人たちに選挙へ行こうと呼びかけるのは正しい気がした。&lt;/p>
&lt;h2 id="backlog-github-integration-action-のバグ修正">backlog-github-integration-action のバグ修正&lt;/h2>
&lt;p>運用してすぐにコミットメッセージ中にシングルクォートやダブルクォートが含まれると引数を正しくパースできなくてエラーになることがわかっていた。いま運用している環境の用途だと、それほど重要ではないので後回しにしているうちに面倒になって放置していた。晩ご飯を食べてからデバッグしていたら7時間ぐらいやってた。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kazamori/backlog-github-integration-action/issues/6">push subcommand is failed when a commit message includes single quote or double quote #6&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>bash 上の文字列の扱いと action.yml の inputs の args に引数渡しするときの振る舞いの勘違いもあって、issue の見た目以上に複雑な振る舞いをしていることがわかった。github actions 上のコンテキストに依存したくなかったため、&lt;code>github.event.commits&lt;/code> の json をそのまま cli パラメーターとして渡している。bash 上の json 文字列と cli パラメーターとしての扱いが煩雑になるのでこのやり方は失敗だったかもしれない。ローカルでのテストもやりにくい。私はそのことをよく理解していたはずなのに github actoins 上のアンチパターンにはまってしまった。カスタムアクションのユーザーが簡単に使えるように cli パラメーターの設定を簡単にする意図で json 渡しにしたんだけど、エスケープの振る舞いが想像以上にややこしくなって、エスケープしたいユーザーには簡単ではなくなってしまった。それでもデバッグをがんばったおかげでシングルクォートは完全に使えるように実装できた。ダブルクォートは制限付きでエラーにならなくできるが、事実上は使わないでくださいといった仕様制限にしてしまおうと思う。引用するときはダブルクォートじゃなくてシングルクォートを使ってくださいと啓蒙することに決めた。&lt;/p></content></item><item><title>github actions の push イベントワークフロー改善</title><link>/diary/posts/2022/0709/</link><pubDate>Sat, 09 Jul 2022 09:09:46 +0900</pubDate><guid>/diary/posts/2022/0709/</guid><description>23時に寝て6時に起きた。今週はサービスインで凸凹していて疲れた。
ストレッチ 今日の開脚幅は開始前161cmで、ストレッチ後164cmだった。ちょっと数値がよくなった。一昨日の日本酒イベントで4時間ほど立ち呑みをしていた疲労で腰に張りが少しあった。それ以外はとくに問題はなくて調子がよかった。右股関節の詰まりも2-3週間前よりもよくなっている気がする。これはトレーナーさんも注意を払って詰まりを取り除くようにストレッチのメニューを組んでくれているのでその成果が徐々に出始めている気がする。以前よりも可動領域が広がってきている気がして安心感を得た。
github actions の push イベントワークフロー改善 午後からビルド・デプロイの最適化のために github actions のワークフローを改善作業をしていた。
今週はサービスインにより、本番環境への緊急リリースを何回もやっているのを傍からみていて、ビルド・デプロイが速くなればなるほど、その回数を増やせるし、修正後の検証に時間を多く割ける。あるリポジトリが7つのモジュールをまとめてビルド・デプロイしている。これはあるモジュールの微修正の反映には向かないので改善することにした。結果として最大で50%ぐらいのビルド時間の削減、モジュールに依っては、具体的には10分かかっていたものを4分台でビルドできるようにした。
ワークフロー改善のためのデバッグしている間はビルド・デプロイが出来なくなることから開発者が使っていない時間帯が望ましい。必然的にサービス休日出勤して github actions のワークフローを改善していた。デバッグと動作の検証も兼ねて午後から半日以上やっていたので休日にやったのは正解だと言えるだろう。
push イベントの github コンテキストの github.event.commits にコミット情報が入っていて、そこにコミットのリビジョンがある。例えば、次のようなオブジェクトで id がコミットのリビジョンに相当する。
[ { &amp;#34;author&amp;#34;: { &amp;#34;email&amp;#34;: &amp;#34;...&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;...&amp;#34;, &amp;#34;username&amp;#34;: &amp;#34;t2y&amp;#34; }, &amp;#34;committer&amp;#34;: { &amp;#34;email&amp;#34;: &amp;#34;...&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;...&amp;#34;, &amp;#34;username&amp;#34;: &amp;#34;t2y&amp;#34; }, &amp;#34;distinct&amp;#34;: true, &amp;#34;id&amp;#34;: &amp;#34;f8df1f77ffec9ef234e7321b2e237b663256b01c&amp;#34;, &amp;#34;message&amp;#34;: &amp;#34;コミットログのメッセージ&amp;#34;, &amp;#34;timestamp&amp;#34;: &amp;#34;2022-07-08T12:32:33+09:00&amp;#34;, &amp;#34;tree_id&amp;#34;: &amp;#34;37b066734e58779c5d2c687d40b4cc43af177cb2&amp;#34;, &amp;#34;url&amp;#34;: &amp;#34;https://github.com/OWNER/REPO/commit/f8df1f77ffec9ef234e7321b2e237b663256b01c&amp;#34; }, ... ] このリビジョンを使って github rest api からファイル情報を取得できる。
$ gh api -H &amp;#34;Accept: application/vnd.</description><content>&lt;p>23時に寝て6時に起きた。今週はサービスインで凸凹していて疲れた。&lt;/p>
&lt;h2 id="ストレッチ">ストレッチ&lt;/h2>
&lt;p>今日の開脚幅は開始前161cmで、ストレッチ後164cmだった。ちょっと数値がよくなった。一昨日の日本酒イベントで4時間ほど立ち呑みをしていた疲労で腰に張りが少しあった。それ以外はとくに問題はなくて調子がよかった。右股関節の詰まりも2-3週間前よりもよくなっている気がする。これはトレーナーさんも注意を払って詰まりを取り除くようにストレッチのメニューを組んでくれているのでその成果が徐々に出始めている気がする。以前よりも可動領域が広がってきている気がして安心感を得た。&lt;/p>
&lt;h2 id="github-actions-の-push-イベントワークフロー改善">github actions の push イベントワークフロー改善&lt;/h2>
&lt;p>午後からビルド・デプロイの最適化のために github actions のワークフローを改善作業をしていた。&lt;/p>
&lt;p>今週はサービスインにより、本番環境への緊急リリースを何回もやっているのを傍からみていて、ビルド・デプロイが速くなればなるほど、その回数を増やせるし、修正後の検証に時間を多く割ける。あるリポジトリが7つのモジュールをまとめてビルド・デプロイしている。これはあるモジュールの微修正の反映には向かないので改善することにした。結果として最大で50%ぐらいのビルド時間の削減、モジュールに依っては、具体的には10分かかっていたものを4分台でビルドできるようにした。&lt;/p>
&lt;p>ワークフロー改善のためのデバッグしている間はビルド・デプロイが出来なくなることから開発者が使っていない時間帯が望ましい。必然的にサービス休日出勤して github actions のワークフローを改善していた。デバッグと動作の検証も兼ねて午後から半日以上やっていたので休日にやったのは正解だと言えるだろう。&lt;/p>
&lt;p>push イベントの github コンテキストの &lt;code>github.event.commits&lt;/code> にコミット情報が入っていて、そこにコミットのリビジョンがある。例えば、次のようなオブジェクトで &lt;code>id&lt;/code> がコミットのリビジョンに相当する。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>[
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;author&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;email&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;...&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;...&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;username&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;t2y&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;committer&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;email&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;...&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;...&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;username&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;t2y&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;distinct&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;id&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;f8df1f77ffec9ef234e7321b2e237b663256b01c&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;message&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;コミットログのメッセージ&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;timestamp&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;2022-07-08T12:32:33+09:00&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;tree_id&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;37b066734e58779c5d2c687d40b4cc43af177cb2&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;url&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;https://github.com/OWNER/REPO/commit/f8df1f77ffec9ef234e7321b2e237b663256b01c&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このリビジョンを使って &lt;a href="https://docs.github.com/en/rest/commits/commits#get-a-commit">github rest api&lt;/a> からファイル情報を取得できる。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ gh api -H &lt;span style="color:#e6db74">&amp;#34;Accept: application/vnd.github+json&amp;#34;&lt;/span> /repos/OWNER/REPO/commits/f8df1f77ffec9ef234e7321b2e237b663256b01c
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>いろんなデータが返ってくるけど、ここでは変更したファイルのパスを知りたい。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;sha&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;...&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;node_id&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;...&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;commit&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;files&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;sha&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;...&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;filename&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;module1/path/to/src&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;sha&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;...&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;filename&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;module2/path/to/src&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この &lt;code>filename&lt;/code> のトップディレクトリがモジュール名と同じなのでここだけ取り出して、管理対象のモジュールかどうかを比較する。bash でも &lt;code>=~&lt;/code> をサブ文字列のマッチングができる。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ targets&lt;span style="color:#f92672">=(&lt;/span>mymodule1 mymodule2&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ echo &lt;span style="color:#e6db74">&amp;#34; &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>targets[@]&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74"> &amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mymodule1 mymodule2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ &lt;span style="color:#f92672">[[&lt;/span> &lt;span style="color:#e6db74">&amp;#34; &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>targets[@]&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74"> &amp;#34;&lt;/span> &lt;span style="color:#f92672">=&lt;/span>~ &lt;span style="color:#e6db74">&amp;#34; mymodule1 &amp;#34;&lt;/span> &lt;span style="color:#f92672">]]&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> echo &lt;span style="color:#e6db74">&amp;#34;match&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>match
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ &lt;span style="color:#f92672">[[&lt;/span> &lt;span style="color:#e6db74">&amp;#34; &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>targets[@]&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74"> &amp;#34;&lt;/span> &lt;span style="color:#f92672">=&lt;/span>~ &lt;span style="color:#e6db74">&amp;#34; mymodule2 &amp;#34;&lt;/span> &lt;span style="color:#f92672">]]&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> echo &lt;span style="color:#e6db74">&amp;#34;match&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>match
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>さらにマッチしたモジュールを &lt;a href="https://docs.github.com/en/actions/learn-github-actions/expressions">github actions の expressions&lt;/a> で制御しやすいように json の array に変換する。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ jq --compact-output --null-input &lt;span style="color:#e6db74">&amp;#39;$ARGS.positional&amp;#39;&lt;/span> --args -- &lt;span style="color:#e6db74">${&lt;/span>targets[@]&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#e6db74">&amp;#34;mymodule1&amp;#34;&lt;/span>,&lt;span style="color:#e6db74">&amp;#34;mymodule2&amp;#34;&lt;/span>&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これを step の outputs として格納する。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>echo &lt;span style="color:#e6db74">&amp;#34;::set-output name=modules::&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>json_array&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>例えば、後続の job で実行条件としてモジュールの有無を調べたいときは expressions を使って次のように記述できる。if 文は &lt;code>${{ ... }}&lt;/code> のブラケットを省略できるようだけど、ここだけ省略すると返って混乱するかなと思って私は記述するようにしている。その方が統合性があってコードが読みやすいように私は考えている。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span> mymodule1-job:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>: &lt;span style="color:#e6db74">${&lt;/span>{ contains(fromJSON(needs.build.outputs.mymodule_target.modules), &lt;span style="color:#e6db74">&amp;#39;mymodule1&amp;#39;&lt;/span>) &lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> needs:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - build
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ちなみに workflow レベルの env は job の if 文には使えない。outputs を使って動的な値を扱うようにしている。どうも workflow レベルの env はいろいろ問題があるみたいでなかなか issue がクローズされないのをみると取り扱い注意なのかもしれない。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/actions/runner/issues/480">Workflow level env does not work properly in all fields. #480&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/actions/runner/issues/1661">workflow level env. is unrecognised on job level&amp;rsquo;s &amp;lsquo;if&amp;rsquo;-expression when calling reusable workflow #1661&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>最終的なモジュールを判別するための step は次のようなものになった。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yml" data-lang="yml">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">build&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">outputs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">mymodule_target&lt;/span>: &lt;span style="color:#ae81ff">${{ steps.mymodule-target.outputs.modules }}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">steps&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">コミットログからビルド対象のモジュールを設定&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">id&lt;/span>: &lt;span style="color:#ae81ff">mymodule-target&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">run&lt;/span>: |&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> declare -A modules
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> target_modules=${{ env.TARGET_MODULES }}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> revisions=$(jq --raw-output &amp;#39;.[].id&amp;#39; &amp;lt;&amp;lt;&amp;lt; &amp;#39;${{ env.COMMITS }}&amp;#39;)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> for revision in ${revisions}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> do
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> names=$(gh api -H &amp;#34;${{ env.ACCEPT_HEADER }}&amp;#34; ${{ env.COMMITS_PATH }}/${revision} | jq --raw-output &amp;#39;.files[].filename&amp;#39; | cut -d&amp;#34;/&amp;#34; -f1 | sort -u)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> for name in $names
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> do
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> if [[ &amp;#34; ${target_modules[@]} &amp;#34; =~ &amp;#34; ${name} &amp;#34; ]]; then
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> modules[${name}]=true
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> fi
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> done
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> done
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> targets=$(jq --compact-output --null-input &amp;#39;$ARGS.positional&amp;#39; --args -- &amp;#34;${!modules[@]}&amp;#34;)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> echo &amp;#34;::set-output name=modules::${targets}&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">env&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">TARGET_MODULES&lt;/span>: |&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> (
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#39;mymodule1&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#39;mymodule2&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> )&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">ACCEPT_HEADER&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Accept: application/vnd.github+json&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">COMMITS_PATH&lt;/span>: &lt;span style="color:#ae81ff">/repos/${{ github.repository }}/commits&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">COMMITS&lt;/span>: &lt;span style="color:#ae81ff">${{ toJSON(github.event.commits) }}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>処理も理屈も簡単なんだけど、実際の運用コードはもう少しだけ複雑なものの、デバッグは github actions を実行しないといけない。ちょっとした typo のために実は2時間ほどはまっていたのは内緒。シェルの配列や連想配列を使うと、記号が多くてわかりにくい。配列の閉じブラケットを忘れていたがために EOF のエラーが発生していた。閉じブラケットのミスだけにエラーが発生しているところと実際のコードがズレていて、それに気付くのに少しずつコードを足したり消したりしてデバッグするみたいな原始的なやり方で些細な typo を気付くのに時間がかかった。&lt;/p>
&lt;pre tabindex="0">&lt;code>xxx.sh: line 47: unexpected EOF while looking for matching `&amp;#34;&amp;#39;
&lt;/code>&lt;/pre></content></item><item><title>個人開発楽しい</title><link>/diary/posts/2022/0424/</link><pubDate>Sun, 24 Apr 2022 21:06:20 +0900</pubDate><guid>/diary/posts/2022/0424/</guid><description>0時に寝て7時に起きた。朝から雨降りだったのでだらだらしながら家を出たけど、オフィスに着いたのは9時頃だったと思う。午前中にコードを書いてテストして、それからお昼ご飯食べて、家に戻って、ちょっとゆっくりしてからオフィスに戻ろうと思ってたら3時間ほど寝てた。
backlog のコミット連携の反応 たまたまツィートしていたらこみやさんが関心をもってくれた。fix, close などでチケットのステータスを変えたいという要望をもらったので作ることにした。
同じ構成なのでちょっと気になる
&amp;mdash; tk0miya (@tk0miya) April 23, 2022 3時間ほどとわりとすぐに実装できた。いまのプロジェクトでは使わない機能なので当初は乗り気ではなかったけど、やっぱり使いたいという人がいると開発のモチベーションになる。
Add a feature to change the issue status with commit messages (fix, close) #3 機能拡張して、テストしたり、ドキュメント書いたりしてた。github discussions も積極的に使ってみようと思っていてちょっとした faq も書いてみた。
About Internationalization (i18n) #4 1-2週間ほど試験運用して問題なさそうだったら v1 のタグをつけて marketplace などに公開してもよいかもしれない。ブログにも書かないとな。まだまだタスクは残っている。</description><content>&lt;p>0時に寝て7時に起きた。朝から雨降りだったのでだらだらしながら家を出たけど、オフィスに着いたのは9時頃だったと思う。午前中にコードを書いてテストして、それからお昼ご飯食べて、家に戻って、ちょっとゆっくりしてからオフィスに戻ろうと思ってたら3時間ほど寝てた。&lt;/p>
&lt;h2 id="backlog-のコミット連携の反応">backlog のコミット連携の反応&lt;/h2>
&lt;p>たまたまツィートしていたらこみやさんが関心をもってくれた。fix, close などでチケットのステータスを変えたいという要望をもらったので作ることにした。&lt;/p>
&lt;blockquote class="twitter-tweet">&lt;p lang="ja" dir="ltr">同じ構成なのでちょっと気になる&lt;/p>&amp;mdash; tk0miya (@tk0miya) &lt;a href="https://twitter.com/tk0miya/status/1517681854539001856?ref_src=twsrc%5Etfw">April 23, 2022&lt;/a>&lt;/blockquote>
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8">&lt;/script>
&lt;p>3時間ほどとわりとすぐに実装できた。いまのプロジェクトでは使わない機能なので当初は乗り気ではなかったけど、やっぱり使いたいという人がいると開発のモチベーションになる。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kazamori/backlog-github-integration-action/pull/3">Add a feature to change the issue status with commit messages (fix, close) #3&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>機能拡張して、テストしたり、ドキュメント書いたりしてた。github discussions も積極的に使ってみようと思っていてちょっとした faq も書いてみた。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kazamori/backlog-github-integration-action/discussions/4">About Internationalization (i18n) #4&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>1-2週間ほど試験運用して問題なさそうだったら v1 のタグをつけて marketplace などに公開してもよいかもしれない。ブログにも書かないとな。まだまだタスクは残っている。&lt;/p></content></item><item><title>カスタム action の開発再開</title><link>/diary/posts/2022/0422/</link><pubDate>Fri, 22 Apr 2022 07:42:50 +0900</pubDate><guid>/diary/posts/2022/0422/</guid><description>22時に寝て0時に起きて3時に起きて5時半に起きた。
ワーケーションのリトライ オミクロン株の流行で延期していた開発合宿を行う。レンタカーと きのいえ の予約を6月3-5日で確定させた。3回目のワクチンを接種したばかりだし、世の中の雰囲気も with コロナへの取り組みになってきている気がする。行き先は同じなので前回作った旅のしおりをコピーしていくつか修正しながら再計画していく。Go To トラベル 再開が6月ではないかという噂もある。
backlog-github-integration-action の機能拡張 先日作った backlog-github-integration-action に push という新たなサブコマンドを追加した。コミットをリポジトリに push したときのイベントをフックしてカスタム action を実行する。インプットが github から取得できるデータになるため、GitHub Events 単位にサブコマンドを作ればトリガーと扱えるインプットデータが一致してわかりやすい機能分割になるんじゃないかと思えた。ひとまずそれでやってみる。今日のところはローカルで動かしてコミット連携ができることを確認して、いくつかテストを書いていた。また明日、結合レベルのテストをやってみる。</description><content>&lt;p>22時に寝て0時に起きて3時に起きて5時半に起きた。&lt;/p>
&lt;h2 id="ワーケーションのリトライ">ワーケーションのリトライ&lt;/h2>
&lt;p>オミクロン株の流行で延期していた開発合宿を行う。レンタカーと &lt;a href="https://kinosaki-kinoie.com/">きのいえ&lt;/a> の予約を6月3-5日で確定させた。3回目のワクチンを接種したばかりだし、世の中の雰囲気も with コロナへの取り組みになってきている気がする。行き先は同じなので前回作った旅のしおりをコピーしていくつか修正しながら再計画していく。&lt;a href="https://goto.jata-net.or.jp/">Go To トラベル&lt;/a> 再開が6月ではないかという噂もある。&lt;/p>
&lt;h2 id="backlog-github-integration-action-の機能拡張">backlog-github-integration-action の機能拡張&lt;/h2>
&lt;p>先日作った &lt;a href="/diary/diary/posts/2022/0327/">backlog-github-integration-action&lt;/a> に push という新たなサブコマンドを追加した。コミットをリポジトリに push したときのイベントをフックしてカスタム action を実行する。インプットが github から取得できるデータになるため、&lt;a href="https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows">GitHub Events&lt;/a> 単位にサブコマンドを作ればトリガーと扱えるインプットデータが一致してわかりやすい機能分割になるんじゃないかと思えた。ひとまずそれでやってみる。今日のところはローカルで動かしてコミット連携ができることを確認して、いくつかテストを書いていた。また明日、結合レベルのテストをやってみる。&lt;/p></content></item><item><title>backlog-github-integration-action を運用し始めた</title><link>/diary/posts/2022/0328/</link><pubDate>Mon, 28 Mar 2022 17:15:41 +0900</pubDate><guid>/diary/posts/2022/0328/</guid><description>2時に寝て6時半に起きた。
backlog と github のインテグレーション action の試験運用 昨日作った backlog-github-integration-action を早速お手伝い先の github リポジトリと backlog に導入した。いま暇な時期というのもあって、誰からもクレームが出なかった。この閑散とした間隙を「乗るしかない、このビッグウェーブに」というノリで導入して運用して既成事実を作る。ses でお手伝いに行って課題管理のツールを作っているというのは頭おかしいと思うけど、周りからクレームが出る前に電光石火で運用にのせてしまう。実際に運用で使うといくつかバグがあって、いま latest の docker イメージを使ってカスタム action が動いている。バグがあったら修正して、./gradlew jib (docker push) で新しい docker イメージを gihtub packages に push して、不具合があった pr のジョブを再実行すれば再現環境でテストもできる。いくつかバグ修正をした。実際の運用のデータを使うとばらばらとバグがみつかる。運用で実際に使われていないツールはダメ、絶対。</description><content>&lt;p>2時に寝て6時半に起きた。&lt;/p>
&lt;h2 id="backlog-と-github-のインテグレーション-action-の試験運用">backlog と github のインテグレーション action の試験運用&lt;/h2>
&lt;p>昨日作った backlog-github-integration-action を早速お手伝い先の github リポジトリと backlog に導入した。いま暇な時期というのもあって、誰からもクレームが出なかった。この閑散とした間隙を「乗るしかない、このビッグウェーブに」というノリで導入して運用して既成事実を作る。ses でお手伝いに行って課題管理のツールを作っているというのは頭おかしいと思うけど、周りからクレームが出る前に電光石火で運用にのせてしまう。実際に運用で使うといくつかバグがあって、いま latest の docker イメージを使ってカスタム action が動いている。バグがあったら修正して、&lt;code>./gradlew jib&lt;/code> (docker push) で新しい docker イメージを gihtub packages に push して、不具合があった pr のジョブを再実行すれば再現環境でテストもできる。いくつかバグ修正をした。実際の運用のデータを使うとばらばらとバグがみつかる。運用で実際に使われていないツールはダメ、絶対。&lt;/p></content></item><item><title>backlog-github-integration-action を作った</title><link>/diary/posts/2022/0327/</link><pubDate>Sun, 27 Mar 2022 07:41:04 +0900</pubDate><guid>/diary/posts/2022/0327/</guid><description>0時に寝て7時に起きた。丸一日開発していた。構想1ヶ月、実装2日といったところか。
backlog と github のインテグレーション action お手伝い先が backlog を課題管理システムとして使っている。backlog は git 連携 の機能をもっているが、これは nulab 社のクラウド上に git リポジトリを構築したものと連携する機能であって、github と連携する機能ではない。そこで github と backlog と連携するためのカスタム github action を作った。
https://github.com/kazamori/backlog-github-integration-action カスタム github action を java で開発するのは普通にはやらないと思うが、いくつか理由があってお手伝い先が java しかできないというのと、nulab 社が提供している公式クライアント nulab/backlog4j が java しかないから。最初は go で実装しようと思って go のクライアントを試したんだけど、サンプルコードをかいたら一部の処理でエラーになって、そのエラーがよくわからなくてやる気がなくなってしまった。最新の rest api の仕様にそってメンテナンスされていないのかな？と思って、やっぱり公式クライアントしかないなと。他にも次のライブラリを使っている。
設定ファイル: https://github.com/lightbend/config コマンドライン解析: https://github.com/remkop/picocli github クライアント: https://github.com/hub4j/github-api これまでは commons-cli を使ってきたけど、サブコマンドの機能を提供していない。もうメンテされてないかも？サブコマンドの機能をもつ argument parser がほしくて picocli を選択した。初めて使っていて、実装してみたらわりと私の好みでよく出来ていると思う。今後は cli ライブラリとして picocli を使っていこうと思う。</description><content>&lt;p>0時に寝て7時に起きた。丸一日開発していた。構想1ヶ月、実装2日といったところか。&lt;/p>
&lt;h2 id="backlog-と-github-のインテグレーション-action">backlog と github のインテグレーション action&lt;/h2>
&lt;p>お手伝い先が &lt;a href="https://backlog.com/ja/">backlog&lt;/a> を課題管理システムとして使っている。backlog は &lt;a href="https://support-ja.backlog.com/hc/ja/sections/360005425774-Git">git 連携&lt;/a> の機能をもっているが、これは nulab 社のクラウド上に git リポジトリを構築したものと連携する機能であって、github と連携する機能ではない。そこで github と backlog と連携するためのカスタム github action を作った。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kazamori/backlog-github-integration-action">https://github.com/kazamori/backlog-github-integration-action&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>カスタム github action を java で開発するのは普通にはやらないと思うが、いくつか理由があってお手伝い先が java しかできないというのと、nulab 社が提供している公式クライアント &lt;a href="https://github.com/nulab/backlog4j">nulab/backlog4j&lt;/a> が java しかないから。最初は go で実装しようと思って go のクライアントを試したんだけど、サンプルコードをかいたら一部の処理でエラーになって、そのエラーがよくわからなくてやる気がなくなってしまった。最新の rest api の仕様にそってメンテナンスされていないのかな？と思って、やっぱり公式クライアントしかないなと。他にも次のライブラリを使っている。&lt;/p>
&lt;ul>
&lt;li>設定ファイル: &lt;a href="https://github.com/lightbend/config">https://github.com/lightbend/config&lt;/a>&lt;/li>
&lt;li>コマンドライン解析: &lt;a href="https://github.com/remkop/picocli">https://github.com/remkop/picocli&lt;/a>&lt;/li>
&lt;li>github クライアント: &lt;a href="https://github.com/hub4j/github-api">https://github.com/hub4j/github-api&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>これまでは commons-cli を使ってきたけど、サブコマンドの機能を提供していない。もうメンテされてないかも？サブコマンドの機能をもつ argument parser がほしくて picocli を選択した。初めて使っていて、実装してみたらわりと私の好みでよく出来ていると思う。今後は cli ライブラリとして picocli を使っていこうと思う。&lt;/p></content></item><item><title>github actions の課金金額</title><link>/diary/posts/2022/0321/</link><pubDate>Mon, 21 Mar 2022 11:10:59 +0900</pubDate><guid>/diary/posts/2022/0321/</guid><description>2時に寝て何度か起きてだらだらしながら10時に起きた。
gihtub-api-tools のリファクタリングとデータ分析 実際に使ってみながらリファクタリングしたり、足りない機能を追加したりした。ツールに拡張した機能が使えるかどうかの検証のため、お仕事のプライベートリポジトリのデータを使って分析をし始めて、気付いたら分析ならびに分析結果の資料まで作ってしまった。軽く半日ぐらいのお仕事をやってしまっていた。過去5ヶ月分の課金時間の合計を算出し、単体テストの実行を github actions に追加することで増える課金時間の見積もりと金額を算出した。月間でいまより3時間30分、全体の課金時間に対して20%弱程度の追加が見込まれる。それによる課金金額を算出すると 210 * $0.008 = $1.68 になる。いままで無料枠を超えないように運用してきたわけだが、こんな200円程度の金額を節約するために github actions 上でテスト実行しないといった判断がくだされていた。開発者は誰も実際の課金金額を知らなかったし、課金金額を算出するとあほらしくなった。あと github actions はめちゃくちゃ安い。</description><content>&lt;p>2時に寝て何度か起きてだらだらしながら10時に起きた。&lt;/p>
&lt;h2 id="gihtub-api-tools-のリファクタリングとデータ分析">gihtub-api-tools のリファクタリングとデータ分析&lt;/h2>
&lt;p>実際に使ってみながらリファクタリングしたり、足りない機能を追加したりした。ツールに拡張した機能が使えるかどうかの検証のため、お仕事のプライベートリポジトリのデータを使って分析をし始めて、気付いたら分析ならびに分析結果の資料まで作ってしまった。軽く半日ぐらいのお仕事をやってしまっていた。過去5ヶ月分の課金時間の合計を算出し、単体テストの実行を github actions に追加することで増える課金時間の見積もりと金額を算出した。月間でいまより3時間30分、全体の課金時間に対して20%弱程度の追加が見込まれる。それによる課金金額を算出すると 210 * $0.008 = $1.68 になる。いままで無料枠を超えないように運用してきたわけだが、こんな200円程度の金額を節約するために github actions 上でテスト実行しないといった判断がくだされていた。開発者は誰も実際の課金金額を知らなかったし、課金金額を算出するとあほらしくなった。あと github actions はめちゃくちゃ安い。&lt;/p></content></item><item><title>gihtub-api-tools の拡張</title><link>/diary/posts/2022/0320/</link><pubDate>Sun, 20 Mar 2022 12:11:13 +0900</pubDate><guid>/diary/posts/2022/0320/</guid><description>5時に寝て9時過ぎに起きた。昨日は久しぶりに夜更ししてコードを書いてた。
github actions のいろいろな時間の算出 以前作った github-api-tools を拡張して github actions の実行履歴の分析するための機能を作っている。
Add actions statistics Add gh-cli-actions command for Actions API ひとまずワークフローの実行履歴からジョブのステップの実行時間を積み上げた時間を算出してみた。いくつか API を調べているうちに課金時間は直接 API から取得できることに気付いた。この3つの時間は全然別の意味をもっていて、それぞれの時間は一致しない。
ステップ実行時間: ジョブのそれぞれのステップの実行時間の合計 課金時間: 課金対象として数えられている時間の合計 ワークフロー実行時間: アクションのワークフローの実行にかかった時間 github actions は public リポジトリに関しては課金対象ではないんやね。private リポジトリ且つ github-hosted ランナーを使っている場合のみ課金対象となるみたい。
Viewing job execution time About billing for GitHub Actions</description><content>&lt;p>5時に寝て9時過ぎに起きた。昨日は久しぶりに夜更ししてコードを書いてた。&lt;/p>
&lt;h2 id="github-actions-のいろいろな時間の算出">github actions のいろいろな時間の算出&lt;/h2>
&lt;p>以前作った github-api-tools を拡張して github actions の実行履歴の分析するための機能を作っている。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kazamori/github-api-tools/issues/2">Add actions statistics&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/kazamori/github-api-tools/pull/4">Add gh-cli-actions command for Actions API&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>ひとまずワークフローの実行履歴からジョブのステップの実行時間を積み上げた時間を算出してみた。いくつか API を調べているうちに課金時間は直接 API から取得できることに気付いた。この3つの時間は全然別の意味をもっていて、それぞれの時間は一致しない。&lt;/p>
&lt;ul>
&lt;li>ステップ実行時間: ジョブのそれぞれのステップの実行時間の合計&lt;/li>
&lt;li>課金時間: 課金対象として数えられている時間の合計&lt;/li>
&lt;li>ワークフロー実行時間: アクションのワークフローの実行にかかった時間&lt;/li>
&lt;/ul>
&lt;p>github actions は public リポジトリに関しては課金対象ではないんやね。private リポジトリ且つ github-hosted ランナーを使っている場合のみ課金対象となるみたい。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/viewing-job-execution-time">Viewing job execution time&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.github.com/en/billing/managing-billing-for-github-actions/about-billing-for-github-actions">About billing for GitHub Actions&lt;/a>&lt;/li>
&lt;/ul></content></item><item><title>github actions の改善</title><link>/diary/posts/2022/0318/</link><pubDate>Fri, 18 Mar 2022 10:05:06 +0900</pubDate><guid>/diary/posts/2022/0318/</guid><description>0時に寝て3時に起きて6時に起きた。
失敗したジョブの再実行 せらさんのツィートをみかけて調べたら2日ほど前に失敗したジョブからの再実行の改善が行われたらしい。
GitHub Action で失敗したジョブだけ実行できる様になってる。今まで失敗しやすいものは再実行を小さくするために設定を分けたりとかしていたんだけど、そういうことをしなくてもよくなった。
&amp;mdash; Kazuhiro Sera (瀬良) (@seratch_ja) March 18, 2022 Save time with partial re-runs in GitHub Actions たまにだけど、i/o エラーみたいな内容で github actions のワークフロー実行が異常終了することがある。そんなときに途中から再実行できるといいなぁとは思っていた。これはステップ単位ではなく、ジョブ単位の実行みたいだけど、それでも途中から再実行できればワークフローの自由度や効率は上がると思う。github actions がどんどん強力になっていくのが楽しみ。あとやぎさんから教えてもらった GitHub Actions 実践入門 も購入した。ある程度触ったところで雰囲気は掴めてきたので体系的に学んでみる。</description><content>&lt;p>0時に寝て3時に起きて6時に起きた。&lt;/p>
&lt;h2 id="失敗したジョブの再実行">失敗したジョブの再実行&lt;/h2>
&lt;p>せらさんのツィートをみかけて調べたら2日ほど前に失敗したジョブからの再実行の改善が行われたらしい。&lt;/p>
&lt;blockquote class="twitter-tweet">&lt;p lang="ja" dir="ltr">GitHub Action で失敗したジョブだけ実行できる様になってる。今まで失敗しやすいものは再実行を小さくするために設定を分けたりとかしていたんだけど、そういうことをしなくてもよくなった。&lt;/p>&amp;mdash; Kazuhiro Sera (瀬良) (@seratch_ja) &lt;a href="https://twitter.com/seratch_ja/status/1504664461483085826?ref_src=twsrc%5Etfw">March 18, 2022&lt;/a>&lt;/blockquote>
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8">&lt;/script>
&lt;ul>
&lt;li>&lt;a href="https://github.blog/2022-03-16-save-time-partial-re-runs-github-actions/">Save time with partial re-runs in GitHub Actions&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>たまにだけど、i/o エラーみたいな内容で github actions のワークフロー実行が異常終了することがある。そんなときに途中から再実行できるといいなぁとは思っていた。これはステップ単位ではなく、ジョブ単位の実行みたいだけど、それでも途中から再実行できればワークフローの自由度や効率は上がると思う。github actions がどんどん強力になっていくのが楽しみ。あとやぎさんから教えてもらった &lt;a href="https://miyajan.booth.pm/items/1865906">GitHub Actions 実践入門&lt;/a> も購入した。ある程度触ったところで雰囲気は掴めてきたので体系的に学んでみる。&lt;/p></content></item><item><title>平穏な一日</title><link>/diary/posts/2022/0314/</link><pubDate>Mon, 14 Mar 2022 07:54:52 +0900</pubDate><guid>/diary/posts/2022/0314/</guid><description>0時に寝て5時半に起きた。一仕事を終えて淡々と前の作業の続きのリファクタリングなどをしていた。
デプロイ改善のタスク完了報告 週末にパイプライン処理の検証やロールバック処理の実装を行った。ドキュメントも一通り書いた。チームの開発者にそれらを説明して3スプリント(3週間)に渡った改善が完了したことを報告した。チケットにすると26、そのうち私が担当したのが22なので、私がイニシアティブをとって完遂させた。github actions を始めとする、github のサービスの理解が深まってそれなりに学びがあった。自分でもいくつかカスタム action を作ってみようと思う。</description><content>&lt;p>0時に寝て5時半に起きた。一仕事を終えて淡々と前の作業の続きのリファクタリングなどをしていた。&lt;/p>
&lt;h2 id="デプロイ改善のタスク完了報告">デプロイ改善のタスク完了報告&lt;/h2>
&lt;p>週末にパイプライン処理の検証やロールバック処理の実装を行った。ドキュメントも一通り書いた。チームの開発者にそれらを説明して3スプリント(3週間)に渡った改善が完了したことを報告した。チケットにすると26、そのうち私が担当したのが22なので、私がイニシアティブをとって完遂させた。github actions を始めとする、github のサービスの理解が深まってそれなりに学びがあった。自分でもいくつかカスタム action を作ってみようと思う。&lt;/p></content></item><item><title>デプロイ改善の残作業</title><link>/diary/posts/2022/0312/</link><pubDate>Sat, 12 Mar 2022 09:49:06 +0900</pubDate><guid>/diary/posts/2022/0312/</guid><description>23時に寝て2時に起きて4時ぐらいまでだらだらして寝て6時に起きた。
ストレッチ これまで11時からストレッチを受けていたが、今週から dr.stretch さんの土日の開店時間が10時になったのにあわせる形で時間変更した。朝に予定が入っているとその時間にあわせて起きて身支度して1日が始まるので家で中途半端にだらだらしなくてよい。いつもは11時にあわせて家を出掛けるのが、10時にあわせて出掛けるようになったのでいつもより1時間早く活動できるようになった。私はなんか予定がないとだらだらしてしまって怠惰に過ごしてしまう。そういう怠ける自分の性格もわかっているので適度に予定を入れて怠けないように注意している。
今日の開脚幅は開始前163cmで、ストレッチ後165cmだった。先週とほぼ同じ。今週もお仕事が忙しくて全くできなかったので現状維持といったところ。
デプロイのパイプライン処理 github deployment から workflow dispatch に移行したおかげでせっかく deployments ベースで作ったパイプライン処理のツールを workflow dispatch 向けに移行する必要があった。言うても基本的に同じパラメーターを処理するだけなので大半は再利用できる。ツールのちょっとしたリファクタリングをやってパイプライン処理が動くかどうかの検証をして、ドキュメントを wiki にまとめた。あとはロールバックを自動化するための仕組みを作るだけ。基本的には k8s の kubectl を実行するワークフローを作るだけという想定。</description><content>&lt;p>23時に寝て2時に起きて4時ぐらいまでだらだらして寝て6時に起きた。&lt;/p>
&lt;h2 id="ストレッチ">ストレッチ&lt;/h2>
&lt;p>これまで11時からストレッチを受けていたが、今週から dr.stretch さんの土日の開店時間が10時になったのにあわせる形で時間変更した。朝に予定が入っているとその時間にあわせて起きて身支度して1日が始まるので家で中途半端にだらだらしなくてよい。いつもは11時にあわせて家を出掛けるのが、10時にあわせて出掛けるようになったのでいつもより1時間早く活動できるようになった。私はなんか予定がないとだらだらしてしまって怠惰に過ごしてしまう。そういう怠ける自分の性格もわかっているので適度に予定を入れて怠けないように注意している。&lt;/p>
&lt;p>今日の開脚幅は開始前163cmで、ストレッチ後165cmだった。先週とほぼ同じ。今週もお仕事が忙しくて全くできなかったので現状維持といったところ。&lt;/p>
&lt;h2 id="デプロイのパイプライン処理">デプロイのパイプライン処理&lt;/h2>
&lt;p>github deployment から workflow dispatch に移行したおかげでせっかく deployments ベースで作ったパイプライン処理のツールを workflow dispatch 向けに移行する必要があった。言うても基本的に同じパラメーターを処理するだけなので大半は再利用できる。ツールのちょっとしたリファクタリングをやってパイプライン処理が動くかどうかの検証をして、ドキュメントを wiki にまとめた。あとはロールバックを自動化するための仕組みを作るだけ。基本的には k8s の kubectl を実行するワークフローを作るだけという想定。&lt;/p></content></item><item><title>デプロイ改善の成果まとめ</title><link>/diary/posts/2022/0308/</link><pubDate>Tue, 08 Mar 2022 06:24:20 +0900</pubDate><guid>/diary/posts/2022/0308/</guid><description>23時に寝て5時過ぎに起きた。何度か途中で起きたけど、久しぶりによく寝た。前日あまり寝てなかったから19時過ぎには帰ってきてだらだらしてた。
もてなしだけではもう食えない 業界研究を兼ねて もてなしだけではもう食えない -ホテル経営学の本質と実践- を読み始めた。同じ出版社の週刊ホテルレストランという雑誌の連載を書籍化したものらしい。著者は立教大学で社会人向けビジネススクールでホテルマネジメントとホテルインベストメントを教えているらしい。ビジネスの堅い話しを小説調にすれば読みやすいんじゃないかみたいな取り組みなのかな？よくわかてないけど、小説仕立てで業界研究ができるような書籍になっているらしい。第1章プロローグと第2章腐りやすい在庫を読んだ。実際の現場でこんな仕事できない人が改革チームのリーダーなんかになったりしないなと思いながら読んでた。そこは本題じゃない！コンサルティングでありそうな経営の話しが出てくるのでうちの会社の経営の勉強にもなるかもしれない。少しずつ読んでいく。
デプロイ改善の成果 水曜日がすくらむのふりかえりイベントがあるのでそれに間に合わせて簡単にまとめの資料を作った。3スプリント (3週間) もかけて抜本的に開発のワークフローからビルド/デプロイの ci/cd を見直したので開発全般に影響を与えた。
本番環境デプロイ: 実行時間を約72%の短縮 テスト環境デプロイ: 実行時間を約51%の短縮 hotfix デプロイ: 実行時間を約64%の短縮 そもそも従来のやり方では hotfix を出していないので机上の時間ではあるが 単純に github actions の実行時間だけ比較しても速くなっているのだけど、それ以上にブランチ戦略を大きく変えた。従来は3つのブランチで運用していた。
develop test main これを1つのブランチのみで運用できるように開発のワークフローを刷新した。ブランチが1つしかないので ci/cd の戦略もシンプルになって、変則的な運用 (hotfix を出したいとか) をしても、開発全体に影響を与えない。「誰か勝手にブランチを作ってデプロイして」で終わる。従来のやり方は3つのブランチが開発ワークフローと ci/cd に密接であったために本番環境のリリースするときは開発すべてが止まってしまう状態だった。週1回のリリースだったので本番リリース前の1-2日は PR のレビューやマージを止めているという運用になっていた。それは開発速度に大きな影響を与えていた。ブランチ戦略を見直したことでいつでも本番環境にデプロイできるようになって、継続的デリバリーっぽいことがやりたかったらできるよという話しをした。</description><content>&lt;p>23時に寝て5時過ぎに起きた。何度か途中で起きたけど、久しぶりによく寝た。前日あまり寝てなかったから19時過ぎには帰ってきてだらだらしてた。&lt;/p>
&lt;h2 id="もてなしだけではもう食えない">もてなしだけではもう食えない&lt;/h2>
&lt;p>業界研究を兼ねて &lt;a href="https://ec.hoteresonline.com/products/detail.php?product_id=262">もてなしだけではもう食えない -ホテル経営学の本質と実践-&lt;/a> を読み始めた。同じ出版社の週刊ホテルレストランという雑誌の連載を書籍化したものらしい。著者は立教大学で社会人向けビジネススクールでホテルマネジメントとホテルインベストメントを教えているらしい。ビジネスの堅い話しを小説調にすれば読みやすいんじゃないかみたいな取り組みなのかな？よくわかてないけど、小説仕立てで業界研究ができるような書籍になっているらしい。第1章プロローグと第2章腐りやすい在庫を読んだ。実際の現場でこんな仕事できない人が改革チームのリーダーなんかになったりしないなと思いながら読んでた。そこは本題じゃない！コンサルティングでありそうな経営の話しが出てくるのでうちの会社の経営の勉強にもなるかもしれない。少しずつ読んでいく。&lt;/p>
&lt;h2 id="デプロイ改善の成果">デプロイ改善の成果&lt;/h2>
&lt;p>水曜日がすくらむのふりかえりイベントがあるのでそれに間に合わせて簡単にまとめの資料を作った。3スプリント (3週間) もかけて抜本的に開発のワークフローからビルド/デプロイの ci/cd を見直したので開発全般に影響を与えた。&lt;/p>
&lt;ul>
&lt;li>本番環境デプロイ: 実行時間を約72%の短縮&lt;/li>
&lt;li>テスト環境デプロイ: 実行時間を約51%の短縮&lt;/li>
&lt;li>hotfix デプロイ: 実行時間を約64%の短縮
&lt;ul>
&lt;li>そもそも従来のやり方では hotfix を出していないので机上の時間ではあるが&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>単純に github actions の実行時間だけ比較しても速くなっているのだけど、それ以上にブランチ戦略を大きく変えた。従来は3つのブランチで運用していた。&lt;/p>
&lt;ul>
&lt;li>develop&lt;/li>
&lt;li>test&lt;/li>
&lt;li>main&lt;/li>
&lt;/ul>
&lt;p>これを1つのブランチのみで運用できるように開発のワークフローを刷新した。ブランチが1つしかないので ci/cd の戦略もシンプルになって、変則的な運用 (hotfix を出したいとか) をしても、開発全体に影響を与えない。「誰か勝手にブランチを作ってデプロイして」で終わる。従来のやり方は3つのブランチが開発ワークフローと ci/cd に密接であったために本番環境のリリースするときは開発すべてが止まってしまう状態だった。週1回のリリースだったので本番リリース前の1-2日は PR のレビューやマージを止めているという運用になっていた。それは開発速度に大きな影響を与えていた。ブランチ戦略を見直したことでいつでも本番環境にデプロイできるようになって、継続的デリバリーっぽいことがやりたかったらできるよという話しをした。&lt;/p></content></item><item><title>ワークフローの移行説明</title><link>/diary/posts/2022/0307/</link><pubDate>Mon, 07 Mar 2022 08:11:25 +0900</pubDate><guid>/diary/posts/2022/0307/</guid><description>3時に寝て6時半に起きた。朝起きたら github actions のリソース上限に達しているという連絡が slack に書き込まれていて週末に移行作業して1500分ぐらいは浪費しましたと事後報告した。
ワークフロー移行後の説明 週末に移行した新しい ci/cd の仕組みを開発者に説明した。開発のワークフローも大きく変わる。いくつか要望をもらいつつ、とくに混乱も誤解もなく受け入れられた。github actions の管理画面からボタンでデプロイ実行できるため、本番環境にデプロイできるユーザーは制限したいと言われて次のようなステップを追加した。
- name: デプロイユーザーを確認 if: ${{ env.DEPLOYMENT_ENV == &amp;#39;prod&amp;#39; }} run: | [[ &amp;#34;${{ contains(fromJSON(env.DEPLOYABLE_USERS), github.actor) }}&amp;#34; == &amp;#34;true&amp;#34; ]] &amp;amp;&amp;amp; exit 0 echo &amp;#34;デプロイ権限のあるユーザーではありません&amp;#34; exit 1 env: DEPLOYABLE_USERS: &amp;#39;[&amp;#34;user1&amp;#34;, &amp;#34;user2&amp;#34;, &amp;#34;app-bot&amp;#34;]&amp;#39; expressions の Functions に組み込みの関数がいくつか紹介されている。それらを組み合わせるとうまくいきそうと思って書いてみた。たしかにちょっと楽に実装はできるけど、github actions の expression とシェルの文字列との境界が、yaml のコード上では曖昧なため、真偽値などはとくにわかりにくい。例えば、次のコード。
[[ &amp;#34;${{ contains(fromJSON(env.DEPLOYABLE_USERS), github.actor) }}&amp;#34; == &amp;#34;true&amp;#34; ]] ${{ ... }} で囲まれたところは github の expression なので boolean として評価できるが、それをシェルにもってくると文字列になってしまうので文字列で比較しないといけない。普通にコードを書いていて気づきにくいので実行して振る舞いを検証しないと間違うみたいな話し。</description><content>&lt;p>3時に寝て6時半に起きた。朝起きたら github actions のリソース上限に達しているという連絡が slack に書き込まれていて週末に移行作業して1500分ぐらいは浪費しましたと事後報告した。&lt;/p>
&lt;h2 id="ワークフロー移行後の説明">ワークフロー移行後の説明&lt;/h2>
&lt;p>週末に移行した新しい ci/cd の仕組みを開発者に説明した。開発のワークフローも大きく変わる。いくつか要望をもらいつつ、とくに混乱も誤解もなく受け入れられた。github actions の管理画面からボタンでデプロイ実行できるため、本番環境にデプロイできるユーザーは制限したいと言われて次のようなステップを追加した。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yml" data-lang="yml">&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">デプロイユーザーを確認&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">if&lt;/span>: &lt;span style="color:#ae81ff">${{ env.DEPLOYMENT_ENV == &amp;#39;prod&amp;#39; }}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">run&lt;/span>: |&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> [[ &amp;#34;${{ contains(fromJSON(env.DEPLOYABLE_USERS), github.actor) }}&amp;#34; == &amp;#34;true&amp;#34; ]] &amp;amp;&amp;amp; exit 0
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> echo &amp;#34;デプロイ権限のあるユーザーではありません&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> exit 1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">env&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">DEPLOYABLE_USERS&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;[&amp;#34;user1&amp;#34;, &amp;#34;user2&amp;#34;, &amp;#34;app-bot&amp;#34;]&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>expressions の &lt;a href="https://docs.github.com/en/actions/learn-github-actions/expressions#functions">Functions&lt;/a> に組み込みの関数がいくつか紹介されている。それらを組み合わせるとうまくいきそうと思って書いてみた。たしかにちょっと楽に実装はできるけど、github actions の expression とシェルの文字列との境界が、yaml のコード上では曖昧なため、真偽値などはとくにわかりにくい。例えば、次のコード。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[[&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>{ contains(fromJSON(env.DEPLOYABLE_USERS), github.actor) &lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">}&amp;#34;&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#34;true&amp;#34;&lt;/span> &lt;span style="color:#f92672">]]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>${{ ... }}&lt;/code> で囲まれたところは github の expression なので boolean として評価できるが、それをシェルにもってくると文字列になってしまうので文字列で比較しないといけない。普通にコードを書いていて気づきにくいので実行して振る舞いを検証しないと間違うみたいな話し。&lt;/p></content></item><item><title>もっとさいきょうのでぷろい</title><link>/diary/posts/2022/0306/</link><pubDate>Sun, 06 Mar 2022 02:58:35 +0900</pubDate><guid>/diary/posts/2022/0306/</guid><description>ぼくのかんがえたもっとさいきょうのでぷろい 昨日 ぼくのかんがえたさいきょうのでぷろい を実装したんだけど、その後、残っていた残課題に対応しているうちにもっと最強のデプロイ方法があることに気付いた。結論から言って GitHub Deployments を使う必要がなかった。GitHub Deployments で過去のリビジョンを指定したときは次のような 409 エラーが発生する。
gh: Conflict merging main into f0cff65c94c4a242efebc79c8fb1e31d58d2f592. (HTTP 409) これを回避するためにどんな手段があるかなと workflow dispatch event をみていて inputs というパラメーターがあることに気付いた。あれ？workflow dispatch ってパラメーターを受け取ることができたんだっけ？と調べたら2020年7月ぐらいからできるようになってた。
GitHub Actions: Manual triggers with workflow_dispatch GitHub Actions: Input types for manual workflows github actions の web ui とも連動していて画面からもパラメーターを渡せるようになっていた。jenkins で言うところのパラメーター付きビルドと呼ばれる機能。カスタムアクションの inputs と同じような使い勝手で利用できる。workflow dispatch がパラメーターを受け取れるなら GitHub Deployments を使うメリットって何があるっけ？と思ったら何もなかった。GitHub Deployments を使うことで無駄にリソースを浪費してパイプライン処理を複雑化させるデメリットしかなかった。inputs に渡す型に environment を指定すると、環境の制限や権限、protected branch などにも応用できるらしい。但し、この environment は public リポジトリか、github enterprise でしか高度な設定はできないみたい。GitHub Deployments 経由でリソースの作成自体はできる。</description><content>&lt;h2 id="ぼくのかんがえたもっとさいきょうのでぷろい">ぼくのかんがえたもっとさいきょうのでぷろい&lt;/h2>
&lt;p>昨日 &lt;a href="/diary/diary/posts/2022/0305/#ぼくのかんがえたさいきょうのでぷろい">ぼくのかんがえたさいきょうのでぷろい&lt;/a> を実装したんだけど、その後、残っていた残課題に対応しているうちにもっと最強のデプロイ方法があることに気付いた。結論から言って &lt;a href="https://docs.github.com/en/rest/reference/deployments">GitHub Deployments&lt;/a> を使う必要がなかった。GitHub Deployments で過去のリビジョンを指定したときは次のような 409 エラーが発生する。&lt;/p>
&lt;pre tabindex="0">&lt;code>gh: Conflict merging main into f0cff65c94c4a242efebc79c8fb1e31d58d2f592. (HTTP 409)
&lt;/code>&lt;/pre>&lt;p>これを回避するためにどんな手段があるかなと &lt;a href="https://docs.github.com/en/rest/reference/actions#create-a-workflow-dispatch-event">workflow dispatch event&lt;/a> をみていて &lt;code>inputs&lt;/code> というパラメーターがあることに気付いた。あれ？workflow dispatch ってパラメーターを受け取ることができたんだっけ？と調べたら2020年7月ぐらいからできるようになってた。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.blog/changelog/2020-07-06-github-actions-manual-triggers-with-workflow_dispatch/">GitHub Actions: Manual triggers with workflow_dispatch&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.blog/changelog/2021-11-10-github-actions-input-types-for-manual-workflows/">GitHub Actions: Input types for manual workflows&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>github actions の web ui とも連動していて画面からもパラメーターを渡せるようになっていた。jenkins で言うところのパラメーター付きビルドと呼ばれる機能。カスタムアクションの &lt;a href="https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions#inputs">inputs&lt;/a> と同じような使い勝手で利用できる。workflow dispatch がパラメーターを受け取れるなら GitHub Deployments を使うメリットって何があるっけ？と思ったら何もなかった。GitHub Deployments を使うことで無駄にリソースを浪費してパイプライン処理を複雑化させるデメリットしかなかった。inputs に渡す型に &lt;a href="https://docs.github.com/en/actions/deployment/targeting-different-environments/using-environments-for-deployment">environment&lt;/a> を指定すると、環境の制限や権限、protected branch などにも応用できるらしい。但し、この environment は public リポジトリか、github enterprise でしか高度な設定はできないみたい。GitHub Deployments 経由でリソースの作成自体はできる。&lt;/p>
&lt;figure>&lt;img src="/diary/diary/img/2022/0306_workflow-dispatch.png"/>
&lt;/figure></content></item><item><title>週末は休出</title><link>/diary/posts/2022/0305/</link><pubDate>Sat, 05 Mar 2022 18:55:18 +0900</pubDate><guid>/diary/posts/2022/0305/</guid><description>2時に寝て8時頃に起きた。前日に深夜まで開発してたせいか、朝起きたら頭痛かった。
ストレッチ お仕事に集中していて今週は1回しかストレッチができなかった。今日の開脚幅は開始前164cmで、ストレッチ後165cmだった。先週と同じぐらいかな。それでも毎週予定が入っているので必ず週に1回はちゃんとしたストレッチを受けられる。もう1年以上続けているのだけど、以前より体調のよい状態をずっと継続できている。私はなにかに集中すると他のことをしばらく放置してそればっかりやってしまう傾向があるから毎週の予約があることが継続的な体調管理に大きく役立っている。太ももの後ろの筋肉と腰のストレッチの2つを楽しみにしている。デスクワークをする人は基本的にこの2つに疲労が蓄積するので疲労が溜まるのは自然と言える。その度合いがどのぐらいかでその週の疲労感や調子がよくわかる。今日は先週よりもその2つはましになっていた。
ぼくのかんがえたさいきょうのでぷろい ここ2週間ほど、ビルドとデプロイの分離のための作業をしている。具体的には GitHub Deployments と GitHub Actions を組み合わせて、新たな開発のワークフローを作るといったもの。main, test, develop と3つのブランチで開発/運用しているのを main ブランチ1つに統合し、ビルドもデプロイも最小限に留めて継続的デリバリーを目指すというもの。移行時は開発を止めてしまうのでこの土日で作業する予定だった。準備は十分にやっていたので問題なく移行を完了させた。今日は単体リポジトリのテスト環境へのデプロイができるところまでできた。あとはデプロイツールや github actions の処理を洗練させていくだけ。テンションが上がっているのでこのまま明日も休出してできるだけ品質をあげていく。</description><content>&lt;p>2時に寝て8時頃に起きた。前日に深夜まで開発してたせいか、朝起きたら頭痛かった。&lt;/p>
&lt;h2 id="ストレッチ">ストレッチ&lt;/h2>
&lt;p>お仕事に集中していて今週は1回しかストレッチができなかった。今日の開脚幅は開始前164cmで、ストレッチ後165cmだった。先週と同じぐらいかな。それでも毎週予定が入っているので必ず週に1回はちゃんとしたストレッチを受けられる。もう1年以上続けているのだけど、以前より体調のよい状態をずっと継続できている。私はなにかに集中すると他のことをしばらく放置してそればっかりやってしまう傾向があるから毎週の予約があることが継続的な体調管理に大きく役立っている。太ももの後ろの筋肉と腰のストレッチの2つを楽しみにしている。デスクワークをする人は基本的にこの2つに疲労が蓄積するので疲労が溜まるのは自然と言える。その度合いがどのぐらいかでその週の疲労感や調子がよくわかる。今日は先週よりもその2つはましになっていた。&lt;/p>
&lt;h2 id="ぼくのかんがえたさいきょうのでぷろい">ぼくのかんがえたさいきょうのでぷろい&lt;/h2>
&lt;p>ここ2週間ほど、ビルドとデプロイの分離のための作業をしている。具体的には &lt;a href="https://docs.github.com/en/rest/reference/deployments">GitHub Deployments&lt;/a> と &lt;a href="https://docs.github.com/en/actions">GitHub Actions&lt;/a> を組み合わせて、新たな開発のワークフローを作るといったもの。main, test, develop と3つのブランチで開発/運用しているのを main ブランチ1つに統合し、ビルドもデプロイも最小限に留めて継続的デリバリーを目指すというもの。移行時は開発を止めてしまうのでこの土日で作業する予定だった。準備は十分にやっていたので問題なく移行を完了させた。今日は単体リポジトリのテスト環境へのデプロイができるところまでできた。あとはデプロイツールや github actions の処理を洗練させていくだけ。テンションが上がっているのでこのまま明日も休出してできるだけ品質をあげていく。&lt;/p></content></item><item><title>継続的デリバリーへの第一歩</title><link>/diary/posts/2022/0224/</link><pubDate>Thu, 24 Feb 2022 08:15:56 +0900</pubDate><guid>/diary/posts/2022/0224/</guid><description>0時に寝て6時に起きた。
docker object labels と git リビジョン 継続的デリバリーのために snapshot jar のマニフェストから取得した git のリビジョンを docker イメージの labels に追加するサンプルコードを jib-sample に実装してみた。jib の gradle プラグインを作って簡略化すれば便利かもしれない。</description><content>&lt;p>0時に寝て6時に起きた。&lt;/p>
&lt;h2 id="docker-object-labels-と-git-リビジョン">docker object labels と git リビジョン&lt;/h2>
&lt;p>継続的デリバリーのために snapshot jar のマニフェストから取得した git のリビジョンを docker イメージの &lt;a href="https://docs.docker.com/config/labels-custom-metadata/">labels&lt;/a> に追加するサンプルコードを &lt;a href="https://github.com/t2y/jib-sample">jib-sample&lt;/a> に実装してみた。jib の gradle プラグインを作って簡略化すれば便利かもしれない。&lt;/p></content></item><item><title>java アプリケーションの継続的デリバリー</title><link>/diary/posts/2022/0223/</link><pubDate>Wed, 23 Feb 2022 08:21:39 +0900</pubDate><guid>/diary/posts/2022/0223/</guid><description>0時に寝て3時に起きて6時ぐらいまでだらだらして寝て7時に起きた。
snapshot jar と継続的デリバリー 昨日 jar に git のリビジョン番号を含める ことについて書いた。jar から git のリビジョン番号を取得できれば、docker イメージを生成するときに labels に jar の artifact id と git のリビジョン番号のラベルを追加して、docker イメージからもソースコードの追跡ができるようになる。いまデプロイは docker イメージのみで運用しているため、maven のバージョン管理ができなくても docker イメージの追跡可能性さえあれば現実の運用で問題にならないのではないかと考えた。つまり、snapshot jar で開発したものをそのまま本番環境にデプロイするということを意味する。こうすれば特定のバージョン番号を付けるだけのビルドとデプロイが不要になって、テスト環境にデプロイされた docker イメージのテストを完了すれば、そのイメージをいつでも本番環境にデプロイできるようになる。デプロイするタイミングでビルドする必要がなくなるので継続的デリバリーに近づくのではないかと考えた。
今日、開発の偉い人やインフラ担当者も含めて、みんなでわいわい打ち合わせして、現状の開発では、インターフェースや互換性の変更にあわせてバージョン番号を付けていないし、古いバージョンに戻すことも現実にはなく、保守は常に最新のリビジョンを更新していくから maven でバージョン管理できなくなっても snapshot jar の運用でがんがん開発していけばいいんちゃうという合意を得られた。
実際にこのやり方がうまくいくかどうか、私も初めての試みなのでやってみないとわからないが、この運用によるワークフローの効率化のメリットも大きいので、引き続き、イニシアティブをもって取り組んでいきたい。</description><content>&lt;p>0時に寝て3時に起きて6時ぐらいまでだらだらして寝て7時に起きた。&lt;/p>
&lt;h2 id="snapshot-jar-と継続的デリバリー">snapshot jar と継続的デリバリー&lt;/h2>
&lt;p>昨日 &lt;a href="/diary/diary/posts/2022/0222/#jar-ファイルと-git-のリビジョン">jar に git のリビジョン番号を含める&lt;/a> ことについて書いた。jar から git のリビジョン番号を取得できれば、docker イメージを生成するときに &lt;a href="https://docs.docker.com/config/labels-custom-metadata/">labels&lt;/a> に jar の artifact id と git のリビジョン番号のラベルを追加して、docker イメージからもソースコードの追跡ができるようになる。いまデプロイは docker イメージのみで運用しているため、maven のバージョン管理ができなくても docker イメージの追跡可能性さえあれば現実の運用で問題にならないのではないかと考えた。つまり、snapshot jar で開発したものをそのまま本番環境にデプロイするということを意味する。こうすれば特定のバージョン番号を付けるだけのビルドとデプロイが不要になって、テスト環境にデプロイされた docker イメージのテストを完了すれば、そのイメージをいつでも本番環境にデプロイできるようになる。デプロイするタイミングでビルドする必要がなくなるので継続的デリバリーに近づくのではないかと考えた。&lt;/p>
&lt;p>今日、開発の偉い人やインフラ担当者も含めて、みんなでわいわい打ち合わせして、現状の開発では、インターフェースや互換性の変更にあわせてバージョン番号を付けていないし、古いバージョンに戻すことも現実にはなく、保守は常に最新のリビジョンを更新していくから maven でバージョン管理できなくなっても snapshot jar の運用でがんがん開発していけばいいんちゃうという合意を得られた。&lt;/p>
&lt;p>実際にこのやり方がうまくいくかどうか、私も初めての試みなのでやってみないとわからないが、この運用によるワークフローの効率化のメリットも大きいので、引き続き、イニシアティブをもって取り組んでいきたい。&lt;/p></content></item></channel></rss>