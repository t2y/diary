<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ci/cd on forest nook</title><link>/diary/tags/ci/cd/</link><description>Recent content in ci/cd on forest nook</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><copyright>© 2021 Tetsuya Morimoto</copyright><atom:icon>/diary/favicon.ico</atom:icon><icon>/diary/favicon.ico</icon><atom:link href="/diary/tags/ci/cd/index.xml" rel="self" type="application/rss+xml"/><item><title>個人開発楽しい</title><link>/diary/posts/2022/0424/</link><pubDate>Sun, 24 Apr 2022 21:06:20 +0900</pubDate><guid>/diary/posts/2022/0424/</guid><description>0時に寝て7時に起きた。朝から雨降りだったのでだらだらしながら家を出たけど、オフィスに着いたのは9時頃だったと思う。午前中にコードを書いてテストして、それからお昼ご飯食べて、家に戻って、ちょっとゆっくりしてからオフィスに戻ろうと思ってたら3時間ほど寝てた。
backlog のコミット連携の反応 たまたまツィートしていたらこみやさんが関心をもってくれた。fix, close などでチケットのステータスを変えたいという要望をもらったので作ることにした。
同じ構成なのでちょっと気になる
&amp;mdash; tk0miya (@tk0miya) April 23, 2022 3時間ほどとわりとすぐに実装できた。いまのプロジェクトでは使わない機能なので当初は乗り気ではなかったけど、やっぱり使いたいという人がいると開発のモチベーションになる。
Add a feature to change the issue status with commit messages (fix, close) #3 機能拡張して、テストしたり、ドキュメント書いたりしてた。github discussions も積極的に使ってみようと思っていてちょっとした faq も書いてみた。
About Internationalization (i18n) #4 1-2週間ほど試験運用して問題なさそうだったら v1 のタグをつけて marketplace などに公開してもよいかもしれない。ブログにも書かないとな。まだまだタスクは残っている。</description><content>&lt;p>0時に寝て7時に起きた。朝から雨降りだったのでだらだらしながら家を出たけど、オフィスに着いたのは9時頃だったと思う。午前中にコードを書いてテストして、それからお昼ご飯食べて、家に戻って、ちょっとゆっくりしてからオフィスに戻ろうと思ってたら3時間ほど寝てた。&lt;/p>
&lt;h2 id="backlog-のコミット連携の反応">backlog のコミット連携の反応&lt;/h2>
&lt;p>たまたまツィートしていたらこみやさんが関心をもってくれた。fix, close などでチケットのステータスを変えたいという要望をもらったので作ることにした。&lt;/p>
&lt;blockquote class="twitter-tweet">&lt;p lang="ja" dir="ltr">同じ構成なのでちょっと気になる&lt;/p>&amp;mdash; tk0miya (@tk0miya) &lt;a href="https://twitter.com/tk0miya/status/1517681854539001856?ref_src=twsrc%5Etfw">April 23, 2022&lt;/a>&lt;/blockquote>
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8">&lt;/script>
&lt;p>3時間ほどとわりとすぐに実装できた。いまのプロジェクトでは使わない機能なので当初は乗り気ではなかったけど、やっぱり使いたいという人がいると開発のモチベーションになる。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kazamori/backlog-github-integration-action/pull/3">Add a feature to change the issue status with commit messages (fix, close) #3&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>機能拡張して、テストしたり、ドキュメント書いたりしてた。github discussions も積極的に使ってみようと思っていてちょっとした faq も書いてみた。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kazamori/backlog-github-integration-action/discussions/4">About Internationalization (i18n) #4&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>1-2週間ほど試験運用して問題なさそうだったら v1 のタグをつけて marketplace などに公開してもよいかもしれない。ブログにも書かないとな。まだまだタスクは残っている。&lt;/p></content></item><item><title>カスタム action の開発再開</title><link>/diary/posts/2022/0422/</link><pubDate>Fri, 22 Apr 2022 07:42:50 +0900</pubDate><guid>/diary/posts/2022/0422/</guid><description>22時に寝て0時に起きて3時に起きて5時半に起きた。
ワーケーションのリトライ オミクロン株の流行で延期していた開発合宿を行う。レンタカーと きのいえ の予約を6月3-5日で確定させた。3回目のワクチンを接種したばかりだし、世の中の雰囲気も with コロナへの取り組みになってきている気がする。行き先は同じなので前回作った旅のしおりをコピーしていくつか修正しながら再計画していく。Go To トラベル 再開が6月ではないかという噂もある。
backlog-github-integration-action の機能拡張 先日作った backlog-github-integration-action に push という新たなサブコマンドを追加した。コミットをリポジトリに push したときのイベントをフックしてカスタム action を実行する。インプットが github から取得できるデータになるため、GitHub Events 単位にサブコマンドを作ればトリガーと扱えるインプットデータが一致してわかりやすい機能分割になるんじゃないかと思えた。ひとまずそれでやってみる。今日のところはローカルで動かしてコミット連携ができることを確認して、いくつかテストを書いていた。また明日、結合レベルのテストをやってみる。</description><content>&lt;p>22時に寝て0時に起きて3時に起きて5時半に起きた。&lt;/p>
&lt;h2 id="ワーケーションのリトライ">ワーケーションのリトライ&lt;/h2>
&lt;p>オミクロン株の流行で延期していた開発合宿を行う。レンタカーと &lt;a href="https://kinosaki-kinoie.com/">きのいえ&lt;/a> の予約を6月3-5日で確定させた。3回目のワクチンを接種したばかりだし、世の中の雰囲気も with コロナへの取り組みになってきている気がする。行き先は同じなので前回作った旅のしおりをコピーしていくつか修正しながら再計画していく。&lt;a href="https://goto.jata-net.or.jp/">Go To トラベル&lt;/a> 再開が6月ではないかという噂もある。&lt;/p>
&lt;h2 id="backlog-github-integration-action-の機能拡張">backlog-github-integration-action の機能拡張&lt;/h2>
&lt;p>先日作った &lt;a href="/diary/diary/posts/2022/0327/">backlog-github-integration-action&lt;/a> に push という新たなサブコマンドを追加した。コミットをリポジトリに push したときのイベントをフックしてカスタム action を実行する。インプットが github から取得できるデータになるため、&lt;a href="https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows">GitHub Events&lt;/a> 単位にサブコマンドを作ればトリガーと扱えるインプットデータが一致してわかりやすい機能分割になるんじゃないかと思えた。ひとまずそれでやってみる。今日のところはローカルで動かしてコミット連携ができることを確認して、いくつかテストを書いていた。また明日、結合レベルのテストをやってみる。&lt;/p></content></item><item><title>backlog-github-integration-action を運用し始めた</title><link>/diary/posts/2022/0328/</link><pubDate>Mon, 28 Mar 2022 17:15:41 +0900</pubDate><guid>/diary/posts/2022/0328/</guid><description>2時に寝て6時半に起きた。
backlog と github のインテグレーション action の試験運用 昨日作った backlog-github-integration-action を早速お手伝い先の github リポジトリと backlog に導入した。いま暇な時期というのもあって、誰からもクレームが出なかった。この閑散とした間隙を「乗るしかない、このビッグウェーブに」というノリで導入して運用して既成事実を作る。ses でお手伝いに行って課題管理のツールを作っているというのは頭おかしいと思うけど、周りからクレームが出る前に電光石火で運用にのせてしまう。実際に運用で使うといくつかバグがあって、いま latest の docker イメージを使ってカスタム action が動いている。バグがあったら修正して、./gradlew jib (docker push) で新しい docker イメージを gihtub packages に push して、不具合があった pr のジョブを再実行すれば再現環境でテストもできる。いくつかバグ修正をした。実際の運用のデータを使うとばらばらとバグがみつかる。運用で実際に使われていないツールはダメ、絶対。</description><content>&lt;p>2時に寝て6時半に起きた。&lt;/p>
&lt;h2 id="backlog-と-github-のインテグレーション-action-の試験運用">backlog と github のインテグレーション action の試験運用&lt;/h2>
&lt;p>昨日作った backlog-github-integration-action を早速お手伝い先の github リポジトリと backlog に導入した。いま暇な時期というのもあって、誰からもクレームが出なかった。この閑散とした間隙を「乗るしかない、このビッグウェーブに」というノリで導入して運用して既成事実を作る。ses でお手伝いに行って課題管理のツールを作っているというのは頭おかしいと思うけど、周りからクレームが出る前に電光石火で運用にのせてしまう。実際に運用で使うといくつかバグがあって、いま latest の docker イメージを使ってカスタム action が動いている。バグがあったら修正して、&lt;code>./gradlew jib&lt;/code> (docker push) で新しい docker イメージを gihtub packages に push して、不具合があった pr のジョブを再実行すれば再現環境でテストもできる。いくつかバグ修正をした。実際の運用のデータを使うとばらばらとバグがみつかる。運用で実際に使われていないツールはダメ、絶対。&lt;/p></content></item><item><title>backlog-github-integration-action を作った</title><link>/diary/posts/2022/0327/</link><pubDate>Sun, 27 Mar 2022 07:41:04 +0900</pubDate><guid>/diary/posts/2022/0327/</guid><description>0時に寝て7時に起きた。丸一日開発していた。構想1ヶ月、実装2日といったところか。
backlog と github のインテグレーション action お手伝い先が backlog を課題管理システムとして使っている。backlog は git 連携 の機能をもっているが、これは nulab 社のクラウド上に git リポジトリを構築したものと連携する機能であって、github と連携する機能ではない。そこで github と backlog と連携するためのカスタム github action を作った。
https://github.com/kazamori/backlog-github-integration-action カスタム github action を java で開発するのは普通にはやらないと思うが、いくつか理由があってお手伝い先が java しかできないというのと、nulab 社が提供している公式クライアント nulab/backlog4j が java しかないから。最初は go で実装しようと思って go のクライアントを試したんだけど、サンプルコードをかいたら一部の処理でエラーになって、そのエラーがよくわからなくてやる気がなくなってしまった。最新の rest api の仕様にそってメンテナンスされていないのかな？と思って、やっぱり公式クライアントしかないなと。他にも次のライブラリを使っている。
設定ファイル: https://github.com/lightbend/config コマンドライン解析: https://github.com/remkop/picocli github クライアント: https://github.com/hub4j/github-api これまでは commons-cli を使ってきたけど、サブコマンドの機能を提供していない。もうメンテされてないかも？サブコマンドの機能をもつ argument parser がほしくて picocli を選択した。初めて使っていて、実装してみたらわりと私の好みでよく出来ていると思う。今後は cli ライブラリとして picocli を使っていこうと思う。</description><content>&lt;p>0時に寝て7時に起きた。丸一日開発していた。構想1ヶ月、実装2日といったところか。&lt;/p>
&lt;h2 id="backlog-と-github-のインテグレーション-action">backlog と github のインテグレーション action&lt;/h2>
&lt;p>お手伝い先が &lt;a href="https://backlog.com/ja/">backlog&lt;/a> を課題管理システムとして使っている。backlog は &lt;a href="https://support-ja.backlog.com/hc/ja/sections/360005425774-Git">git 連携&lt;/a> の機能をもっているが、これは nulab 社のクラウド上に git リポジトリを構築したものと連携する機能であって、github と連携する機能ではない。そこで github と backlog と連携するためのカスタム github action を作った。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kazamori/backlog-github-integration-action">https://github.com/kazamori/backlog-github-integration-action&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>カスタム github action を java で開発するのは普通にはやらないと思うが、いくつか理由があってお手伝い先が java しかできないというのと、nulab 社が提供している公式クライアント &lt;a href="https://github.com/nulab/backlog4j">nulab/backlog4j&lt;/a> が java しかないから。最初は go で実装しようと思って go のクライアントを試したんだけど、サンプルコードをかいたら一部の処理でエラーになって、そのエラーがよくわからなくてやる気がなくなってしまった。最新の rest api の仕様にそってメンテナンスされていないのかな？と思って、やっぱり公式クライアントしかないなと。他にも次のライブラリを使っている。&lt;/p>
&lt;ul>
&lt;li>設定ファイル: &lt;a href="https://github.com/lightbend/config">https://github.com/lightbend/config&lt;/a>&lt;/li>
&lt;li>コマンドライン解析: &lt;a href="https://github.com/remkop/picocli">https://github.com/remkop/picocli&lt;/a>&lt;/li>
&lt;li>github クライアント: &lt;a href="https://github.com/hub4j/github-api">https://github.com/hub4j/github-api&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>これまでは commons-cli を使ってきたけど、サブコマンドの機能を提供していない。もうメンテされてないかも？サブコマンドの機能をもつ argument parser がほしくて picocli を選択した。初めて使っていて、実装してみたらわりと私の好みでよく出来ていると思う。今後は cli ライブラリとして picocli を使っていこうと思う。&lt;/p></content></item><item><title>github actions の課金金額</title><link>/diary/posts/2022/0321/</link><pubDate>Mon, 21 Mar 2022 11:10:59 +0900</pubDate><guid>/diary/posts/2022/0321/</guid><description>2時に寝て何度か起きてだらだらしながら10時に起きた。
gihtub-api-tools のリファクタリングとデータ分析 実際に使ってみながらリファクタリングしたり、足りない機能を追加したりした。ツールに拡張した機能が使えるかどうかの検証のため、お仕事のプライベートリポジトリのデータを使って分析をし始めて、気付いたら分析ならびに分析結果の資料まで作ってしまった。軽く半日ぐらいのお仕事をやってしまっていた。過去5ヶ月分の課金時間の合計を算出し、単体テストの実行を github actions に追加することで増える課金時間の見積もりと金額を算出した。月間でいまより3時間30分、全体の課金時間に対して20%弱程度の追加が見込まれる。それによる課金金額を算出すると 210 * $0.008 = $1.68 になる。いままで無料枠を超えないように運用してきたわけだが、こんな200円程度の金額を節約するために github actions 上でテスト実行しないといった判断がくだされていた。開発者は誰も実際の課金金額を知らなかったし、課金金額を算出するとあほらしくなった。あと github actions はめちゃくちゃ安い。</description><content>&lt;p>2時に寝て何度か起きてだらだらしながら10時に起きた。&lt;/p>
&lt;h2 id="gihtub-api-tools-のリファクタリングとデータ分析">gihtub-api-tools のリファクタリングとデータ分析&lt;/h2>
&lt;p>実際に使ってみながらリファクタリングしたり、足りない機能を追加したりした。ツールに拡張した機能が使えるかどうかの検証のため、お仕事のプライベートリポジトリのデータを使って分析をし始めて、気付いたら分析ならびに分析結果の資料まで作ってしまった。軽く半日ぐらいのお仕事をやってしまっていた。過去5ヶ月分の課金時間の合計を算出し、単体テストの実行を github actions に追加することで増える課金時間の見積もりと金額を算出した。月間でいまより3時間30分、全体の課金時間に対して20%弱程度の追加が見込まれる。それによる課金金額を算出すると 210 * $0.008 = $1.68 になる。いままで無料枠を超えないように運用してきたわけだが、こんな200円程度の金額を節約するために github actions 上でテスト実行しないといった判断がくだされていた。開発者は誰も実際の課金金額を知らなかったし、課金金額を算出するとあほらしくなった。あと github actions はめちゃくちゃ安い。&lt;/p></content></item><item><title>gihtub-api-tools の拡張</title><link>/diary/posts/2022/0320/</link><pubDate>Sun, 20 Mar 2022 12:11:13 +0900</pubDate><guid>/diary/posts/2022/0320/</guid><description>5時に寝て9時過ぎに起きた。昨日は久しぶりに夜更ししてコードを書いてた。
github actions のいろいろな時間の算出 以前作った github-api-tools を拡張して github actions の実行履歴の分析するための機能を作っている。
Add actions statistics Add gh-cli-actions command for Actions API ひとまずワークフローの実行履歴からジョブのステップの実行時間を積み上げた時間を算出してみた。いくつか API を調べているうちに課金時間は直接 API から取得できることに気付いた。この3つの時間は全然別の意味をもっていて、それぞれの時間は一致しない。
ステップ実行時間: ジョブのそれぞれのステップの実行時間の合計 課金時間: 課金対象として数えられている時間の合計 ワークフロー実行時間: アクションのワークフローの実行にかかった時間 github actions は public リポジトリに関しては課金対象ではないんやね。private リポジトリ且つ github-hosted ランナーを使っている場合のみ課金対象となるみたい。
Viewing job execution time About billing for GitHub Actions</description><content>&lt;p>5時に寝て9時過ぎに起きた。昨日は久しぶりに夜更ししてコードを書いてた。&lt;/p>
&lt;h2 id="github-actions-のいろいろな時間の算出">github actions のいろいろな時間の算出&lt;/h2>
&lt;p>以前作った github-api-tools を拡張して github actions の実行履歴の分析するための機能を作っている。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kazamori/github-api-tools/issues/2">Add actions statistics&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/kazamori/github-api-tools/pull/4">Add gh-cli-actions command for Actions API&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>ひとまずワークフローの実行履歴からジョブのステップの実行時間を積み上げた時間を算出してみた。いくつか API を調べているうちに課金時間は直接 API から取得できることに気付いた。この3つの時間は全然別の意味をもっていて、それぞれの時間は一致しない。&lt;/p>
&lt;ul>
&lt;li>ステップ実行時間: ジョブのそれぞれのステップの実行時間の合計&lt;/li>
&lt;li>課金時間: 課金対象として数えられている時間の合計&lt;/li>
&lt;li>ワークフロー実行時間: アクションのワークフローの実行にかかった時間&lt;/li>
&lt;/ul>
&lt;p>github actions は public リポジトリに関しては課金対象ではないんやね。private リポジトリ且つ github-hosted ランナーを使っている場合のみ課金対象となるみたい。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/viewing-job-execution-time">Viewing job execution time&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.github.com/en/billing/managing-billing-for-github-actions/about-billing-for-github-actions">About billing for GitHub Actions&lt;/a>&lt;/li>
&lt;/ul></content></item><item><title>github actions の改善</title><link>/diary/posts/2022/0318/</link><pubDate>Fri, 18 Mar 2022 10:05:06 +0900</pubDate><guid>/diary/posts/2022/0318/</guid><description>0時に寝て3時に起きて6時に起きた。
失敗したジョブの再実行 せらさんのツィートをみかけて調べたら2日ほど前に失敗したジョブからの再実行の改善が行われたらしい。
GitHub Action で失敗したジョブだけ実行できる様になってる。今まで失敗しやすいものは再実行を小さくするために設定を分けたりとかしていたんだけど、そういうことをしなくてもよくなった。
&amp;mdash; Kazuhiro Sera (瀬良) (@seratch_ja) March 18, 2022 Save time with partial re-runs in GitHub Actions たまにだけど、i/o エラーみたいな内容で github actions のワークフロー実行が異常終了することがある。そんなときに途中から再実行できるといいなぁとは思っていた。これはステップ単位ではなく、ジョブ単位の実行みたいだけど、それでも途中から再実行できればワークフローの自由度や効率は上がると思う。github actions がどんどん強力になっていくのが楽しみ。あとやぎさんから教えてもらった GitHub Actions 実践入門 も購入した。ある程度触ったところで雰囲気は掴めてきたので体系的に学んでみる。</description><content>&lt;p>0時に寝て3時に起きて6時に起きた。&lt;/p>
&lt;h2 id="失敗したジョブの再実行">失敗したジョブの再実行&lt;/h2>
&lt;p>せらさんのツィートをみかけて調べたら2日ほど前に失敗したジョブからの再実行の改善が行われたらしい。&lt;/p>
&lt;blockquote class="twitter-tweet">&lt;p lang="ja" dir="ltr">GitHub Action で失敗したジョブだけ実行できる様になってる。今まで失敗しやすいものは再実行を小さくするために設定を分けたりとかしていたんだけど、そういうことをしなくてもよくなった。&lt;/p>&amp;mdash; Kazuhiro Sera (瀬良) (@seratch_ja) &lt;a href="https://twitter.com/seratch_ja/status/1504664461483085826?ref_src=twsrc%5Etfw">March 18, 2022&lt;/a>&lt;/blockquote>
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8">&lt;/script>
&lt;ul>
&lt;li>&lt;a href="https://github.blog/2022-03-16-save-time-partial-re-runs-github-actions/">Save time with partial re-runs in GitHub Actions&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>たまにだけど、i/o エラーみたいな内容で github actions のワークフロー実行が異常終了することがある。そんなときに途中から再実行できるといいなぁとは思っていた。これはステップ単位ではなく、ジョブ単位の実行みたいだけど、それでも途中から再実行できればワークフローの自由度や効率は上がると思う。github actions がどんどん強力になっていくのが楽しみ。あとやぎさんから教えてもらった &lt;a href="https://miyajan.booth.pm/items/1865906">GitHub Actions 実践入門&lt;/a> も購入した。ある程度触ったところで雰囲気は掴めてきたので体系的に学んでみる。&lt;/p></content></item><item><title>平穏な一日</title><link>/diary/posts/2022/0314/</link><pubDate>Mon, 14 Mar 2022 07:54:52 +0900</pubDate><guid>/diary/posts/2022/0314/</guid><description>0時に寝て5時半に起きた。一仕事を終えて淡々と前の作業の続きのリファクタリングなどをしていた。
デプロイ改善のタスク完了報告 週末にパイプライン処理の検証やロールバック処理の実装を行った。ドキュメントも一通り書いた。チームの開発者にそれらを説明して3スプリント(3週間)に渡った改善が完了したことを報告した。チケットにすると26、そのうち私が担当したのが22なので、私がイニシアティブをとって完遂させた。github actions を始めとする、github のサービスの理解が深まってそれなりに学びがあった。自分でもいくつかカスタム action を作ってみようと思う。</description><content>&lt;p>0時に寝て5時半に起きた。一仕事を終えて淡々と前の作業の続きのリファクタリングなどをしていた。&lt;/p>
&lt;h2 id="デプロイ改善のタスク完了報告">デプロイ改善のタスク完了報告&lt;/h2>
&lt;p>週末にパイプライン処理の検証やロールバック処理の実装を行った。ドキュメントも一通り書いた。チームの開発者にそれらを説明して3スプリント(3週間)に渡った改善が完了したことを報告した。チケットにすると26、そのうち私が担当したのが22なので、私がイニシアティブをとって完遂させた。github actions を始めとする、github のサービスの理解が深まってそれなりに学びがあった。自分でもいくつかカスタム action を作ってみようと思う。&lt;/p></content></item><item><title>デプロイ改善の残作業</title><link>/diary/posts/2022/0312/</link><pubDate>Sat, 12 Mar 2022 09:49:06 +0900</pubDate><guid>/diary/posts/2022/0312/</guid><description>23時に寝て2時に起きて4時ぐらいまでだらだらして寝て6時に起きた。
ストレッチ これまで11時からストレッチを受けていたが、今週から dr.stretch さんの土日の開店時間が10時になったのにあわせる形で時間変更した。朝に予定が入っているとその時間にあわせて起きて身支度して1日が始まるので家で中途半端にだらだらしなくてよい。いつもは11時にあわせて家を出掛けるのが、10時にあわせて出掛けるようになったのでいつもより1時間早く活動できるようになった。私はなんか予定がないとだらだらしてしまって怠惰に過ごしてしまう。そういう怠ける自分の性格もわかっているので適度に予定を入れて怠けないように注意している。
今日の開脚幅は開始前163cmで、ストレッチ後165cmだった。先週とほぼ同じ。今週もお仕事が忙しくて全くできなかったので現状維持といったところ。
デプロイのパイプライン処理 github deployment から workflow dispatch に移行したおかげでせっかく deployments ベースで作ったパイプライン処理のツールを workflow dispatch 向けに移行する必要があった。言うても基本的に同じパラメーターを処理するだけなので大半は再利用できる。ツールのちょっとしたリファクタリングをやってパイプライン処理が動くかどうかの検証をして、ドキュメントを wiki にまとめた。あとはロールバックを自動化するための仕組みを作るだけ。基本的には k8s の kubectl を実行するワークフローを作るだけという想定。</description><content>&lt;p>23時に寝て2時に起きて4時ぐらいまでだらだらして寝て6時に起きた。&lt;/p>
&lt;h2 id="ストレッチ">ストレッチ&lt;/h2>
&lt;p>これまで11時からストレッチを受けていたが、今週から dr.stretch さんの土日の開店時間が10時になったのにあわせる形で時間変更した。朝に予定が入っているとその時間にあわせて起きて身支度して1日が始まるので家で中途半端にだらだらしなくてよい。いつもは11時にあわせて家を出掛けるのが、10時にあわせて出掛けるようになったのでいつもより1時間早く活動できるようになった。私はなんか予定がないとだらだらしてしまって怠惰に過ごしてしまう。そういう怠ける自分の性格もわかっているので適度に予定を入れて怠けないように注意している。&lt;/p>
&lt;p>今日の開脚幅は開始前163cmで、ストレッチ後165cmだった。先週とほぼ同じ。今週もお仕事が忙しくて全くできなかったので現状維持といったところ。&lt;/p>
&lt;h2 id="デプロイのパイプライン処理">デプロイのパイプライン処理&lt;/h2>
&lt;p>github deployment から workflow dispatch に移行したおかげでせっかく deployments ベースで作ったパイプライン処理のツールを workflow dispatch 向けに移行する必要があった。言うても基本的に同じパラメーターを処理するだけなので大半は再利用できる。ツールのちょっとしたリファクタリングをやってパイプライン処理が動くかどうかの検証をして、ドキュメントを wiki にまとめた。あとはロールバックを自動化するための仕組みを作るだけ。基本的には k8s の kubectl を実行するワークフローを作るだけという想定。&lt;/p></content></item><item><title>デプロイ改善の成果まとめ</title><link>/diary/posts/2022/0308/</link><pubDate>Tue, 08 Mar 2022 06:24:20 +0900</pubDate><guid>/diary/posts/2022/0308/</guid><description>23時に寝て5時過ぎに起きた。何度か途中で起きたけど、久しぶりによく寝た。前日あまり寝てなかったから19時過ぎには帰ってきてだらだらしてた。
もてなしだけではもう食えない 業界研究を兼ねて もてなしだけではもう食えない -ホテル経営学の本質と実践- を読み始めた。同じ出版社の週刊ホテルレストランという雑誌の連載を書籍化したものらしい。著者は立教大学で社会人向けビジネススクールでホテルマネジメントとホテルインベストメントを教えているらしい。ビジネスの堅い話しを小説調にすれば読みやすいんじゃないかみたいな取り組みなのかな？よくわかてないけど、小説仕立てで業界研究ができるような書籍になっているらしい。第1章プロローグと第2章腐りやすい在庫を読んだ。実際の現場でこんな仕事できない人が改革チームのリーダーなんかになったりしないなと思いながら読んでた。そこは本題じゃない！コンサルティングでありそうな経営の話しが出てくるのでうちの会社の経営の勉強にもなるかもしれない。少しずつ読んでいく。
デプロイ改善の成果 水曜日がすくらむのふりかえりイベントがあるのでそれに間に合わせて簡単にまとめの資料を作った。3スプリント (3週間) もかけて抜本的に開発のワークフローからビルド/デプロイの ci/cd を見直したので開発全般に影響を与えた。
本番環境デプロイ: 実行時間を約72%の短縮 テスト環境デプロイ: 実行時間を約51%の短縮 hotfix デプロイ: 実行時間を約64%の短縮 そもそも従来のやり方では hotfix を出していないので机上の時間ではあるが 単純に github actions の実行時間だけ比較しても速くなっているのだけど、それ以上にブランチ戦略を大きく変えた。従来は3つのブランチで運用していた。
develop test main これを1つのブランチのみで運用できるように開発のワークフローを刷新した。ブランチが1つしかないので ci/cd の戦略もシンプルになって、変則的な運用 (hotfix を出したいとか) をしても、開発全体に影響を与えない。「誰か勝手にブランチを作ってデプロイして」で終わる。従来のやり方は3つのブランチが開発ワークフローと ci/cd に密接であったために本番環境のリリースするときは開発すべてが止まってしまう状態だった。週1回のリリースだったので本番リリース前の1-2日は PR のレビューやマージを止めているという運用になっていた。それは開発速度に大きな影響を与えていた。ブランチ戦略を見直したことでいつでも本番環境にデプロイできるようになって、継続的デリバリーっぽいことがやりたかったらできるよという話しをした。</description><content>&lt;p>23時に寝て5時過ぎに起きた。何度か途中で起きたけど、久しぶりによく寝た。前日あまり寝てなかったから19時過ぎには帰ってきてだらだらしてた。&lt;/p>
&lt;h2 id="もてなしだけではもう食えない">もてなしだけではもう食えない&lt;/h2>
&lt;p>業界研究を兼ねて &lt;a href="https://ec.hoteresonline.com/products/detail.php?product_id=262">もてなしだけではもう食えない -ホテル経営学の本質と実践-&lt;/a> を読み始めた。同じ出版社の週刊ホテルレストランという雑誌の連載を書籍化したものらしい。著者は立教大学で社会人向けビジネススクールでホテルマネジメントとホテルインベストメントを教えているらしい。ビジネスの堅い話しを小説調にすれば読みやすいんじゃないかみたいな取り組みなのかな？よくわかてないけど、小説仕立てで業界研究ができるような書籍になっているらしい。第1章プロローグと第2章腐りやすい在庫を読んだ。実際の現場でこんな仕事できない人が改革チームのリーダーなんかになったりしないなと思いながら読んでた。そこは本題じゃない！コンサルティングでありそうな経営の話しが出てくるのでうちの会社の経営の勉強にもなるかもしれない。少しずつ読んでいく。&lt;/p>
&lt;h2 id="デプロイ改善の成果">デプロイ改善の成果&lt;/h2>
&lt;p>水曜日がすくらむのふりかえりイベントがあるのでそれに間に合わせて簡単にまとめの資料を作った。3スプリント (3週間) もかけて抜本的に開発のワークフローからビルド/デプロイの ci/cd を見直したので開発全般に影響を与えた。&lt;/p>
&lt;ul>
&lt;li>本番環境デプロイ: 実行時間を約72%の短縮&lt;/li>
&lt;li>テスト環境デプロイ: 実行時間を約51%の短縮&lt;/li>
&lt;li>hotfix デプロイ: 実行時間を約64%の短縮
&lt;ul>
&lt;li>そもそも従来のやり方では hotfix を出していないので机上の時間ではあるが&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>単純に github actions の実行時間だけ比較しても速くなっているのだけど、それ以上にブランチ戦略を大きく変えた。従来は3つのブランチで運用していた。&lt;/p>
&lt;ul>
&lt;li>develop&lt;/li>
&lt;li>test&lt;/li>
&lt;li>main&lt;/li>
&lt;/ul>
&lt;p>これを1つのブランチのみで運用できるように開発のワークフローを刷新した。ブランチが1つしかないので ci/cd の戦略もシンプルになって、変則的な運用 (hotfix を出したいとか) をしても、開発全体に影響を与えない。「誰か勝手にブランチを作ってデプロイして」で終わる。従来のやり方は3つのブランチが開発ワークフローと ci/cd に密接であったために本番環境のリリースするときは開発すべてが止まってしまう状態だった。週1回のリリースだったので本番リリース前の1-2日は PR のレビューやマージを止めているという運用になっていた。それは開発速度に大きな影響を与えていた。ブランチ戦略を見直したことでいつでも本番環境にデプロイできるようになって、継続的デリバリーっぽいことがやりたかったらできるよという話しをした。&lt;/p></content></item><item><title>ワークフローの移行説明</title><link>/diary/posts/2022/0307/</link><pubDate>Mon, 07 Mar 2022 08:11:25 +0900</pubDate><guid>/diary/posts/2022/0307/</guid><description>3時に寝て6時半に起きた。朝起きたら github actions のリソース上限に達しているという連絡が slack に書き込まれていて週末に移行作業して1500分ぐらいは浪費しましたと事後報告した。
ワークフロー移行後の説明 週末に移行した新しい ci/cd の仕組みを開発者に説明した。開発のワークフローも大きく変わる。いくつか要望をもらいつつ、とくに混乱も誤解もなく受け入れられた。github actions の管理画面からボタンでデプロイ実行できるため、本番環境にデプロイできるユーザーは制限したいと言われて次のようなステップを追加した。
- name: デプロイユーザーを確認 if: ${{ env.DEPLOYMENT_ENV == &amp;#39;prod&amp;#39; }} run: | [[ &amp;#34;${{ contains(fromJSON(env.DEPLOYABLE_USERS), github.actor) }}&amp;#34; == &amp;#34;true&amp;#34; ]] &amp;amp;&amp;amp; exit 0 echo &amp;#34;デプロイ権限のあるユーザーではありません&amp;#34; exit 1 env: DEPLOYABLE_USERS: &amp;#39;[&amp;#34;user1&amp;#34;, &amp;#34;user2&amp;#34;, &amp;#34;app-bot&amp;#34;]&amp;#39; expressions の Functions に組み込みの関数がいくつか紹介されている。それらを組み合わせるとうまくいきそうと思って書いてみた。たしかにちょっと楽に実装はできるけど、github actions の expression とシェルの文字列との境界が、yaml のコード上では曖昧なため、真偽値などはとくにわかりにくい。例えば、次のコード。
[[ &amp;#34;${{ contains(fromJSON(env.DEPLOYABLE_USERS), github.actor) }}&amp;#34; == &amp;#34;true&amp;#34; ]] ${{ ... }} で囲まれたところは github の expression なので boolean として評価できるが、それをシェルにもってくると文字列になってしまうので文字列で比較しないといけない。普通にコードを書いていて気づきにくいので実行して振る舞いを検証しないと間違うみたいな話し。</description><content>&lt;p>3時に寝て6時半に起きた。朝起きたら github actions のリソース上限に達しているという連絡が slack に書き込まれていて週末に移行作業して1500分ぐらいは浪費しましたと事後報告した。&lt;/p>
&lt;h2 id="ワークフロー移行後の説明">ワークフロー移行後の説明&lt;/h2>
&lt;p>週末に移行した新しい ci/cd の仕組みを開発者に説明した。開発のワークフローも大きく変わる。いくつか要望をもらいつつ、とくに混乱も誤解もなく受け入れられた。github actions の管理画面からボタンでデプロイ実行できるため、本番環境にデプロイできるユーザーは制限したいと言われて次のようなステップを追加した。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yml" data-lang="yml">&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">デプロイユーザーを確認&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">if&lt;/span>: &lt;span style="color:#ae81ff">${{ env.DEPLOYMENT_ENV == &amp;#39;prod&amp;#39; }}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">run&lt;/span>: |&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> [[ &amp;#34;${{ contains(fromJSON(env.DEPLOYABLE_USERS), github.actor) }}&amp;#34; == &amp;#34;true&amp;#34; ]] &amp;amp;&amp;amp; exit 0
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> echo &amp;#34;デプロイ権限のあるユーザーではありません&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> exit 1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">env&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">DEPLOYABLE_USERS&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;[&amp;#34;user1&amp;#34;, &amp;#34;user2&amp;#34;, &amp;#34;app-bot&amp;#34;]&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>expressions の &lt;a href="https://docs.github.com/en/actions/learn-github-actions/expressions#functions">Functions&lt;/a> に組み込みの関数がいくつか紹介されている。それらを組み合わせるとうまくいきそうと思って書いてみた。たしかにちょっと楽に実装はできるけど、github actions の expression とシェルの文字列との境界が、yaml のコード上では曖昧なため、真偽値などはとくにわかりにくい。例えば、次のコード。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[[&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>{ contains(fromJSON(env.DEPLOYABLE_USERS), github.actor) &lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">}&amp;#34;&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#34;true&amp;#34;&lt;/span> &lt;span style="color:#f92672">]]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>${{ ... }}&lt;/code> で囲まれたところは github の expression なので boolean として評価できるが、それをシェルにもってくると文字列になってしまうので文字列で比較しないといけない。普通にコードを書いていて気づきにくいので実行して振る舞いを検証しないと間違うみたいな話し。&lt;/p></content></item><item><title>もっとさいきょうのでぷろい</title><link>/diary/posts/2022/0306/</link><pubDate>Sun, 06 Mar 2022 02:58:35 +0900</pubDate><guid>/diary/posts/2022/0306/</guid><description>ぼくのかんがえたもっとさいきょうのでぷろい 昨日 ぼくのかんがえたさいきょうのでぷろい を実装したんだけど、その後、残っていた残課題に対応しているうちにもっと最強のデプロイ方法があることに気付いた。結論から言って GitHub Deployments を使う必要がなかった。GitHub Deployments で過去のリビジョンを指定したときは次のような 409 エラーが発生する。
gh: Conflict merging main into f0cff65c94c4a242efebc79c8fb1e31d58d2f592. (HTTP 409) これを回避するためにどんな手段があるかなと workflow dispatch event をみていて inputs というパラメーターがあることに気付いた。あれ？workflow dispatch ってパラメーターを受け取ることができたんだっけ？と調べたら2020年7月ぐらいからできるようになってた。
GitHub Actions: Manual triggers with workflow_dispatch GitHub Actions: Input types for manual workflows github actions の web ui とも連動していて画面からもパラメーターを渡せるようになっていた。jenkins で言うところのパラメーター付きビルドと呼ばれる機能。カスタムアクションの inputs と同じような使い勝手で利用できる。workflow dispatch がパラメーターを受け取れるなら GitHub Deployments を使うメリットって何があるっけ？と思ったら何もなかった。GitHub Deployments を使うことで無駄にリソースを浪費してパイプライン処理を複雑化させるデメリットしかなかった。inputs に渡す型に environment を指定すると、環境の制限や権限、protected branch などにも応用できるらしい。但し、この environment は public リポジトリか、github enterprise でしか高度な設定はできないみたい。GitHub Deployments 経由でリソースの作成自体はできる。</description><content>&lt;h2 id="ぼくのかんがえたもっとさいきょうのでぷろい">ぼくのかんがえたもっとさいきょうのでぷろい&lt;/h2>
&lt;p>昨日 &lt;a href="/diary/diary/posts/2022/0305/#ぼくのかんがえたさいきょうのでぷろい">ぼくのかんがえたさいきょうのでぷろい&lt;/a> を実装したんだけど、その後、残っていた残課題に対応しているうちにもっと最強のデプロイ方法があることに気付いた。結論から言って &lt;a href="https://docs.github.com/en/rest/reference/deployments">GitHub Deployments&lt;/a> を使う必要がなかった。GitHub Deployments で過去のリビジョンを指定したときは次のような 409 エラーが発生する。&lt;/p>
&lt;pre tabindex="0">&lt;code>gh: Conflict merging main into f0cff65c94c4a242efebc79c8fb1e31d58d2f592. (HTTP 409)
&lt;/code>&lt;/pre>&lt;p>これを回避するためにどんな手段があるかなと &lt;a href="https://docs.github.com/en/rest/reference/actions#create-a-workflow-dispatch-event">workflow dispatch event&lt;/a> をみていて &lt;code>inputs&lt;/code> というパラメーターがあることに気付いた。あれ？workflow dispatch ってパラメーターを受け取ることができたんだっけ？と調べたら2020年7月ぐらいからできるようになってた。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.blog/changelog/2020-07-06-github-actions-manual-triggers-with-workflow_dispatch/">GitHub Actions: Manual triggers with workflow_dispatch&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.blog/changelog/2021-11-10-github-actions-input-types-for-manual-workflows/">GitHub Actions: Input types for manual workflows&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>github actions の web ui とも連動していて画面からもパラメーターを渡せるようになっていた。jenkins で言うところのパラメーター付きビルドと呼ばれる機能。カスタムアクションの &lt;a href="https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions#inputs">inputs&lt;/a> と同じような使い勝手で利用できる。workflow dispatch がパラメーターを受け取れるなら GitHub Deployments を使うメリットって何があるっけ？と思ったら何もなかった。GitHub Deployments を使うことで無駄にリソースを浪費してパイプライン処理を複雑化させるデメリットしかなかった。inputs に渡す型に &lt;a href="https://docs.github.com/en/actions/deployment/targeting-different-environments/using-environments-for-deployment">environment&lt;/a> を指定すると、環境の制限や権限、protected branch などにも応用できるらしい。但し、この environment は public リポジトリか、github enterprise でしか高度な設定はできないみたい。GitHub Deployments 経由でリソースの作成自体はできる。&lt;/p>
&lt;figure>&lt;img src="/diary/diary/img/2022/0306_workflow-dispatch.png"/>
&lt;/figure></content></item><item><title>週末は休出</title><link>/diary/posts/2022/0305/</link><pubDate>Sat, 05 Mar 2022 18:55:18 +0900</pubDate><guid>/diary/posts/2022/0305/</guid><description>2時に寝て8時頃に起きた。前日に深夜まで開発してたせいか、朝起きたら頭痛かった。
ストレッチ お仕事に集中していて今週は1回しかストレッチができなかった。今日の開脚幅は開始前164cmで、ストレッチ後165cmだった。先週と同じぐらいかな。それでも毎週予定が入っているので必ず週に1回はちゃんとしたストレッチを受けられる。もう1年以上続けているのだけど、以前より体調のよい状態をずっと継続できている。私はなにかに集中すると他のことをしばらく放置してそればっかりやってしまう傾向があるから毎週の予約があることが継続的な体調管理に大きく役立っている。太ももの後ろの筋肉と腰のストレッチの2つを楽しみにしている。デスクワークをする人は基本的にこの2つに疲労が蓄積するので疲労が溜まるのは自然と言える。その度合いがどのぐらいかでその週の疲労感や調子がよくわかる。今日は先週よりもその2つはましになっていた。
ぼくのかんがえたさいきょうのでぷろい ここ2週間ほど、ビルドとデプロイの分離のための作業をしている。具体的には GitHub Deployments と GitHub Actions を組み合わせて、新たな開発のワークフローを作るといったもの。main, test, develop と3つのブランチで開発/運用しているのを main ブランチ1つに統合し、ビルドもデプロイも最小限に留めて継続的デリバリーを目指すというもの。移行時は開発を止めてしまうのでこの土日で作業する予定だった。準備は十分にやっていたので問題なく移行を完了させた。今日は単体リポジトリのテスト環境へのデプロイができるところまでできた。あとはデプロイツールや github actions の処理を洗練させていくだけ。テンションが上がっているのでこのまま明日も休出してできるだけ品質をあげていく。</description><content>&lt;p>2時に寝て8時頃に起きた。前日に深夜まで開発してたせいか、朝起きたら頭痛かった。&lt;/p>
&lt;h2 id="ストレッチ">ストレッチ&lt;/h2>
&lt;p>お仕事に集中していて今週は1回しかストレッチができなかった。今日の開脚幅は開始前164cmで、ストレッチ後165cmだった。先週と同じぐらいかな。それでも毎週予定が入っているので必ず週に1回はちゃんとしたストレッチを受けられる。もう1年以上続けているのだけど、以前より体調のよい状態をずっと継続できている。私はなにかに集中すると他のことをしばらく放置してそればっかりやってしまう傾向があるから毎週の予約があることが継続的な体調管理に大きく役立っている。太ももの後ろの筋肉と腰のストレッチの2つを楽しみにしている。デスクワークをする人は基本的にこの2つに疲労が蓄積するので疲労が溜まるのは自然と言える。その度合いがどのぐらいかでその週の疲労感や調子がよくわかる。今日は先週よりもその2つはましになっていた。&lt;/p>
&lt;h2 id="ぼくのかんがえたさいきょうのでぷろい">ぼくのかんがえたさいきょうのでぷろい&lt;/h2>
&lt;p>ここ2週間ほど、ビルドとデプロイの分離のための作業をしている。具体的には &lt;a href="https://docs.github.com/en/rest/reference/deployments">GitHub Deployments&lt;/a> と &lt;a href="https://docs.github.com/en/actions">GitHub Actions&lt;/a> を組み合わせて、新たな開発のワークフローを作るといったもの。main, test, develop と3つのブランチで開発/運用しているのを main ブランチ1つに統合し、ビルドもデプロイも最小限に留めて継続的デリバリーを目指すというもの。移行時は開発を止めてしまうのでこの土日で作業する予定だった。準備は十分にやっていたので問題なく移行を完了させた。今日は単体リポジトリのテスト環境へのデプロイができるところまでできた。あとはデプロイツールや github actions の処理を洗練させていくだけ。テンションが上がっているのでこのまま明日も休出してできるだけ品質をあげていく。&lt;/p></content></item><item><title>継続的デリバリーへの第一歩</title><link>/diary/posts/2022/0224/</link><pubDate>Thu, 24 Feb 2022 08:15:56 +0900</pubDate><guid>/diary/posts/2022/0224/</guid><description>0時に寝て6時に起きた。
docker object labels と git リビジョン 継続的デリバリーのために snapshot jar のマニフェストから取得した git のリビジョンを docker イメージの labels に追加するサンプルコードを jib-sample に実装してみた。jib の gradle プラグインを作って簡略化すれば便利かもしれない。</description><content>&lt;p>0時に寝て6時に起きた。&lt;/p>
&lt;h2 id="docker-object-labels-と-git-リビジョン">docker object labels と git リビジョン&lt;/h2>
&lt;p>継続的デリバリーのために snapshot jar のマニフェストから取得した git のリビジョンを docker イメージの &lt;a href="https://docs.docker.com/config/labels-custom-metadata/">labels&lt;/a> に追加するサンプルコードを &lt;a href="https://github.com/t2y/jib-sample">jib-sample&lt;/a> に実装してみた。jib の gradle プラグインを作って簡略化すれば便利かもしれない。&lt;/p></content></item><item><title>java アプリケーションの継続的デリバリー</title><link>/diary/posts/2022/0223/</link><pubDate>Wed, 23 Feb 2022 08:21:39 +0900</pubDate><guid>/diary/posts/2022/0223/</guid><description>0時に寝て3時に起きて6時ぐらいまでだらだらして寝て7時に起きた。
snapshot jar と継続的デリバリー 昨日 jar に git のリビジョン番号を含める ことについて書いた。jar から git のリビジョン番号を取得できれば、docker イメージを生成するときに labels に jar の artifact id と git のリビジョン番号のラベルを追加して、docker イメージからもソースコードの追跡ができるようになる。いまデプロイは docker イメージのみで運用しているため、maven のバージョン管理ができなくても docker イメージの追跡可能性さえあれば現実の運用で問題にならないのではないかと考えた。つまり、snapshot jar で開発したものをそのまま本番環境にデプロイするということを意味する。こうすれば特定のバージョン番号を付けるだけのビルドとデプロイが不要になって、テスト環境にデプロイされた docker イメージのテストを完了すれば、そのイメージをいつでも本番環境にデプロイできるようになる。デプロイするタイミングでビルドする必要がなくなるので継続的デリバリーに近づくのではないかと考えた。
今日、開発の偉い人やインフラ担当者も含めて、みんなでわいわい打ち合わせして、現状の開発では、インターフェースや互換性の変更にあわせてバージョン番号を付けていないし、古いバージョンに戻すことも現実にはなく、保守は常に最新のリビジョンを更新していくから maven でバージョン管理できなくなっても snapshot jar の運用でがんがん開発していけばいいんちゃうという合意を得られた。
実際にこのやり方がうまくいくかどうか、私も初めての試みなのでやってみないとわからないが、この運用によるワークフローの効率化のメリットも大きいので、引き続き、イニシアティブをもって取り組んでいきたい。</description><content>&lt;p>0時に寝て3時に起きて6時ぐらいまでだらだらして寝て7時に起きた。&lt;/p>
&lt;h2 id="snapshot-jar-と継続的デリバリー">snapshot jar と継続的デリバリー&lt;/h2>
&lt;p>昨日 &lt;a href="/diary/diary/posts/2022/0222/#jar-ファイルと-git-のリビジョン">jar に git のリビジョン番号を含める&lt;/a> ことについて書いた。jar から git のリビジョン番号を取得できれば、docker イメージを生成するときに &lt;a href="https://docs.docker.com/config/labels-custom-metadata/">labels&lt;/a> に jar の artifact id と git のリビジョン番号のラベルを追加して、docker イメージからもソースコードの追跡ができるようになる。いまデプロイは docker イメージのみで運用しているため、maven のバージョン管理ができなくても docker イメージの追跡可能性さえあれば現実の運用で問題にならないのではないかと考えた。つまり、snapshot jar で開発したものをそのまま本番環境にデプロイするということを意味する。こうすれば特定のバージョン番号を付けるだけのビルドとデプロイが不要になって、テスト環境にデプロイされた docker イメージのテストを完了すれば、そのイメージをいつでも本番環境にデプロイできるようになる。デプロイするタイミングでビルドする必要がなくなるので継続的デリバリーに近づくのではないかと考えた。&lt;/p>
&lt;p>今日、開発の偉い人やインフラ担当者も含めて、みんなでわいわい打ち合わせして、現状の開発では、インターフェースや互換性の変更にあわせてバージョン番号を付けていないし、古いバージョンに戻すことも現実にはなく、保守は常に最新のリビジョンを更新していくから maven でバージョン管理できなくなっても snapshot jar の運用でがんがん開発していけばいいんちゃうという合意を得られた。&lt;/p>
&lt;p>実際にこのやり方がうまくいくかどうか、私も初めての試みなのでやってみないとわからないが、この運用によるワークフローの効率化のメリットも大きいので、引き続き、イニシアティブをもって取り組んでいきたい。&lt;/p></content></item></channel></rss>