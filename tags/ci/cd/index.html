<!doctype html><html lang=en><head><title>Ci/Cd :: </title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=/diary/tags/ci/cd/><link rel=stylesheet href=/diary/styles.css><link rel=stylesheet href=/diary/style.css><link rel="shortcut icon" href=/diary/favicon.ico><meta name=twitter:card content="summary"><meta name=twitter:site content="t2y"><meta name=twitter:creator content><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:title" content="Ci/Cd"><meta property="og:description" content><meta property="og:url" content="/diary/tags/ci/cd/"><meta property="og:site_name" content><meta property="og:image" content="/diary/favicon.ico"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><link href=/diary/tags/ci/cd/index.xml rel=alternate type=application/rss+xml title></head><body class=green><div class="container full headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/diary><div class=logo>forest nook</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/diary/about>自己紹介</a></li><li><a href=/diary/dates>月別一覧</a></li><li><a href=/diary/tags>タグ一覧</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/diary/about>自己紹介</a></li><li><a href=/diary/dates>月別一覧</a></li><li><a href=/diary/tags>タグ一覧</a></li></ul></nav></header><div class=content><h1>Posts for: #Ci/Cd</h1><div class=posts><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2023/1219/>結合テストのデバッグ</a></h1><div class=post-meta><time class=post-date>2023-12-19</time></div><span class=post-tags>#<a href=/diary/tags/gitlab/>gitlab</a>&nbsp;
#<a href=/diary/tags/ci/cd/>ci/cd</a>&nbsp;
#<a href=/diary/tags/mongodb/>mongodb</a>&nbsp;
#<a href=/diary/tags/testing/>testing</a>&nbsp;</span><div class=post-content><p>1時に寝て5時半に起きて7時半に起きた。なんか週の前半からバテている。</p><h2 id=gitlab-cicd-の-dind-で-mongodb-のレプリカセット接続ができない>gitlab ci/cd の dind で mongodb のレプリカセット接続ができない</h2><p>先日対応した <a href=/diary/posts/2023/1214/>mongodb のレプリカセット対応</a> で残った最後の課題。ローカルで実行すれば結合テストは動くが、gitlab ci/cd 環境では動作しないという問題が残っていた。<a href=/diary/posts/2023/1218/>gitlab-runner をローカルで実行できる</a> ようにして、設定やパラメーターを変えたり、デバッグコードを埋め込んだり、コンテナに attach して振る舞いを確認したり、いろいろデバッグして原因はレプリカセット接続におけるホスト名の解決がコンテナ間でできていなかったことがわかった。</p><p>mongodb の結合テストは <a href=https://github.com/ory/dockertest>dockertest</a> を使って実装している。これを gitlab ci/cd で動かすには dind を有効にする必要がある。dind 環境では2つのコンテナを使って結合テストが実行されるわけだが、テストが実行されるコンテナと mongodb コンテナが起動するコンテナの2つが生成される。このときにテストが実行されるコンテナから実際に mongodb が起動するコンテナのホスト名の解決と、mongodb が起動するコンテナ上での自分のホスト名の解決の2つが成立していないとレプリカセット接続ができない。要は1台のローカルホスト上で結合テストを実行するのと、2つのコンテナ上で実行されるのでは設定を変更する必要があるということに気付いた。</p><p>具体的には dockertest の次のパラメーターを、実行環境から解決するホスト名を考慮して設定すればよいと気付いた。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>pool</span>.<span style=color:#a6e22e>RunWithOptions</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>dockertest</span>.<span style=color:#a6e22e>RunOptions</span>{
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span> 
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Hostname</span>:   <span style=color:#a6e22e>executor</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Env</span>: []<span style=color:#66d9ef>string</span>{
</span></span><span style=display:flex><span>        <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Sprintf</span>(<span style=color:#e6db74>&#34;MONGODB_ADVERTISED_HOSTNAME=%s&#34;</span>, <span style=color:#a6e22e>executor</span>),
</span></span><span style=display:flex><span>        <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><p>たったこれだけの修正だし、現状の動作の振る舞いが分かればすぐに直せるものではあるけれど、このデバッグにはまた2-3時間を費やした。mongodb のレプリカセット接続はなかなか大変。</p></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2023/1218/>gitlab ci/cd のローカルデバッグ</a></h1><div class=post-meta><time class=post-date>2023-12-18</time></div><span class=post-tags>#<a href=/diary/tags/gitlab/>gitlab</a>&nbsp;
#<a href=/diary/tags/ci/cd/>ci/cd</a>&nbsp;
#<a href=/diary/tags/debug/>debug</a>&nbsp;</span><div class=post-content><p>23時頃から寝始めて3時に起きて5時半に起きて8時過ぎに起きた。久しぶりに寝坊した。</p><h2 id=gitlab-runner-のデバッグ>gitlab-runner のデバッグ</h2><p>mongodb のレプリカセット対応して、ローカルでは結合テストが動くものの、gitlab ci/cd 環境では動かなくなった。gitlab ci/cd は <a href=https://docs.gitlab.com/runner/>GitLab Runner</a> によって提供されている。そのデバッグのため、ローカルに gitlab-runner をインストールして調査した。</p><p><a href=https://docs.gitlab.com/runner/install/>GitLab Runner のインストール</a> ドキュメントにそれぞれの OS 向けのドキュメントがある。Debian/Ubuntu/Mint 向けのインストール手順を行う。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ curl -L <span style=color:#e6db74>&#34;https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh&#34;</span> | sudo bash
</span></span><span style=display:flex><span>$ sudo apt-get install gitlab-runner
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ gitlab-runner --version
</span></span><span style=display:flex><span>Version:      16.6.1
</span></span><span style=display:flex><span>Git revision: f5da3c5a
</span></span><span style=display:flex><span>Git branch:   16-6-stable
</span></span><span style=display:flex><span>GO version:   go1.20.10
</span></span><span style=display:flex><span>Built:        2023-11-24T21:11:36+0000
</span></span><span style=display:flex><span>OS/Arch:      linux/amd64
</span></span></code></pre></div><p>.gitlab-ci.yml があるディレクトリへ移動して、ジョブを指定して実行する。ローカルでの変更内容を検証するときはブランチにコミットしないといけない。コミットしていないと次のワーニングが表示される。</p><pre tabindex=0><code>WARNING: You most probably have uncommitted changes. 
WARNING: These changes will not be tested.         
</code></pre><p>dind なジョブを実行するときは <code>--docker-privileged</code> で特権を付けて実行する。環境変数は <code>--env KEY=VALUE</code> で渡せるが、<code>CI_JOB_TOKEN</code> のような組み込みの環境変数は上書きできない。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cd path/to/repo
</span></span><span style=display:flex><span>$ gitlab-runner exec docker --docker-privileged <span style=color:#e6db74>${</span>ジョブ名<span style=color:#e6db74>}</span>
</span></span></code></pre></div></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2023/0828/>go の処理系も驚く sdk のコード生成</a></h1><div class=post-meta><time class=post-date>2023-08-28</time></div><span class=post-tags>#<a href=/diary/tags/go/>go</a>&nbsp;
#<a href=/diary/tags/design/>design</a>&nbsp;
#<a href=/diary/tags/openapi/>openapi</a>&nbsp;
#<a href=/diary/tags/ci/cd/>ci/cd</a>&nbsp;</span><div class=post-content><p>0時に寝て何度か起きて6時に起きた。そのまま7時過ぎまでだらだらしてた。しんどい。</p><h2 id=msgraph-sdk-go-のサイズ問題>msgraph-sdk-go のサイズ問題</h2><p>先週 <a href=/diary/posts/2023/0825/#msgraph-sdk-go-を使った開発>msgraph-sdk-go を使った開発</a> を終えてデプロイする段階になってライブラリのサイズが大きくて、コンパイル速度が遅くなったり、バイナリサイズが大きくなったりする弊害があることに気付いた。コンパイル速度は2-3倍遅くなり (3分が7-10分ぐらい)、バイナリサイズも2-3倍大きくなる (30 MiB が 100 MiB とか) 。たまたまこのリポジトリは他のツール類からも依存パッケージとして使われるものなので想定よりも影響が大きいことに気付いた。</p><p>朝からチームのメンバーとミーティングして、本来は qa に入ったこの時期にこんな変更をすべきではないが、これは放置するデメリットが大きいのでリポジトリ分割 (モジュール分割) しようと提案して了承を得た。私がやれば作業は1日もあれば完了するだろうと見積もって、見積もり通り、夕方には分割したモジュールをテスト環境にデプロイして当面の解決を得た。アプリケーションのモジュール構造をちゃんとレイヤー化して作ってあるから、今回みたいに急遽、モジュール分割が必要になってもほぼ変更する必要はなかった (たった1箇所だけ) 。</p><p>この本質的な問題は次の issue のコメントで説明されている。</p><ul><li><a href=https://github.com/microsoftgraph/msgraph-sdk-go/issues/129#issuecomment-1098028043>Issue with the size of the API surface of the models package #129</a></li></ul><p>ざっと機械翻訳してみる。</p><blockquote><p><strong>コンテキスト</strong></p><p>この SDK は <a href=https://github.com/microsoft/kiota>kiota</a> を使用してメタデータから自動的に生成されます。オリジナルのメタデータは、Microsoft Graph の配下にあるすべてのサービスチーム（v1用とベータ用）によって入力された CSDL です。この CSDL は最終的に OpenAPI のフォーマットに変換されますが、これは非常に大きなものです（1k 以上のエンドポイント、1.5k のモデル &mldr;）。API のサイズが大きいため、完全な API surface の SDK を手作りすることは実現不可能でしょう。</p><p>私たちは、SDK を複数のサブモジュール（ファイル用、メール用など）に &ldquo;スライス&rdquo; して、人々が関心のあるものだけを簡単に入手できるようにすることをしばらく考えてきました。実際、私たちは PowerShell でこれを実現しました。しかし、&ldquo;グラフ&rdquo; の性質（すべてのモデルは互いにある程度関連している）と構築されるアプリケーションの多様性により、スライスは誰にとっても &ldquo;正しい&rdquo; ものにはならない（大きすぎたり、小さすぎたり、モデルの重複につながったり&mldr;）。</p><p>そのような理由から、私たちは「完全なSDK」を提供することにしました。すべての人にとって理想的とは言えないかもしれませんが、Go開発者の中には「アプリケーションを作るためのSDKが欲しいだけ」という人もいると感じています（以下で説明する2つ目のオプションとは対照的です）。</p></blockquote><blockquote><p><strong>Go の欠点</strong></p><p>Go の探求を通して、いくつかの欠点に気づいた。現時点では、私たちのプロジェクトやパッケージが適切にセットアップされていないせいなのか、Go や大規模プロジェクトの制限のせいなのかはわからない：</p><p>go build は、変更されておらず、依存関係も変更されていないサブパッケージをリビルドすることが多い。go build が直前に実行されていても、go test がリビルドすることがよくあります。なぜある種のキャッシュに頼らないのでしょうか？同じ問題が go lint にもある。<br>私には、たくさんのサブパッケージがある大きなプロジェクトをビルドするコストは、依存関係が更新されたり、キャッシュが削除されたり、コードが変更されたりしない限り、「セッションごとに一度」だけ支払われるべきだと感じます。</p><p>私たちのプロジェクト構成／構造において、そのような状況を改善するための最適化について、自由に概説してください。また、Goコミュニティ（Goコンパイラを開発している人たちなど）と関わって、そのようなフィードバックを提供する方法があれば、喜んでそうします。私たちのプロジェクトは、その規模の大きさから、世の中にあるほとんどのGoパッケージと比べると、ちょっと変わり者だとわかっています。</p></blockquote><blockquote><p><strong>適切なサイズの SDK</strong></p><p>最後に、すべてのエンドポイントを備えた完全な SDK を持つことは、様々な理由からすべての人に適しているわけではないことを認識しています。私たちは新しい &ldquo;適切なサイズのセルフサービスSDKエクスペリエンス&rdquo; を可能にするために取り組んでいます。そこでは、APIユーザーは誰でも、この SDK と同じように見え、同じように感じる SDK を生成することができますが、完全な API サーフェスの代わりに、彼らのアプリケーションのために彼らが気にするエンドポイント/モデルのみが含まれています。
私たちは今、そのような取り組みに本当に早くから取り組んでいますが、それでもフィードバックをいただけるとうれしいです。大まかな手順はこんな感じだ：</p><ol><li>新しいgoプロジェクトを作成するか、既存のプロジェクトを特定する。</li><li>kiotaの依存関係を追加するか、msgraph-sdk-go-coreを追加します（これはKiotaの依存関係をプルし、いくつか追加します）。</li><li>グラフエクスプローラで必要なリソースを選択（左パネル、2番目のタブ、&mldr;、&ldquo;コレクションに追加&rdquo;）。</li><li>コレクションをプレビューをクリックし、postmanコレクションとしてエクスポートします。</li><li>hidi を postmanコレクションと先ほど共有したOpenAPIの完全な説明文と一緒に使って、&ldquo;フィルタリングされた&rdquo; OpenAPI フォーマットを生成する。</li><li>kiotaを使って、プロジェクトにMicrosoft Graph用のGoクライアントを生成する。</li><li>APIの呼び出しを開始する。</li></ol><p>この時点で、私たちはこれらのステップをすべて文書化し、効率化するために取り組んでいます（おそらくステップ4～5を圧縮しています）。このアプローチの素晴らしいところは、ステップ5から7までが、Microsoft Graphだけでなく、呼び出したいOpenAPIで記述されたAPIで動作することだ。<br>繰り返しますが、この最後の提案はまだ初期段階です。自由に試して、様々な場所でフィードバックを提供してください。</p><p>この長い投稿で、私たちがどこに向かっているのかが明らかになり、Goコミュニティからこれらの側面すべてについてさらにフィードバックが得られると本当に助かる！</p></blockquote><p>簡単に言えば、ms graph api の体系が巨大過ぎて、その定義は <a href=https://raw.githubusercontent.com/microsoftgraph/msgraph-metadata/master/openapi/v1.0/openapi.yaml>openapi.yaml</a> にあるが、この定義からすべてコード生成すると巨大なモデル定義をもつ sdk が出来上がってしまったという話しである。後半に書いてあるワークアラウンドとして kiota で必要なモデルだけを選択して専用 sdk を生成すればサイズを小さくできるとある。しかし、それはそれで <a href=https://developer.microsoft.com/en-us/graph/graph-explorer>graph explorer</a> で選択しないといけなかったりして面倒そうではある。次のドキュメントでもその手順について書いてある。</p><ul><li><a href=https://devblogs.microsoft.com/microsoft365dev/building-go-applications-with-the-microsoft-graph-go-sdk/#create-a-smaller-and-tailored-microsoft-graph-go-client-library>Create a smaller and tailored Microsoft Graph Go client library</a></li></ul><p>うちの用途ではモジュール分割により、局所化したのでひとまずこの問題は大きな影響をもたないようになった。また余裕があるときにモデルを選択して専用 sdk を自動的に生成する仕組みを構築できるならそれに挑戦してもよいかもしれない。</p></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2023/0825/>msgraph-sdk-go のビルド問題</a></h1><div class=post-meta><time class=post-date>2023-08-25</time></div><span class=post-tags>#<a href=/diary/tags/go/>go</a>&nbsp;
#<a href=/diary/tags/ci/cd/>ci/cd</a>&nbsp;
#<a href=/diary/tags/infrastructure/>infrastructure</a>&nbsp;</span><div class=post-content><p>1時に寝て何度か起きて7時に起きた。昨日は少し早めにお仕事を終えて家で休んでいたので少し回復した。</p><h2 id=msgraph-sdk-go-を使った開発>msgraph-sdk-go を使った開発</h2><p><a href=/diary/posts/2023/0824/#msgraph-sdk-go-を使った開発>昨日の続き</a> 。前日に作ったマージリクエストをチームのメンバーにレビューしてもらっていくつか修正して、マージを終えた。一段落。</p><p>さらにこの sdk を使うことで8月の前半に開発していた差分比較のところも変更しないといけないことに気付いた。public な構造体のメンバーにアクセスして差分比較する処理を実装していたが、この sdk は getter で構造体のメンバーにアクセスしないといけないことに気付いた。reflectoin の処理に追加で実装を入れるだけなのでそんなに難しくはない。そういった修正をしていたら1日終わってしまった。開発していると時間が過ぎるのは早い。</p><p>たまたま ci/cd ジョブの実行時間の上限を10分にしていて超えるときがあってジョブが失敗した。
調べてみると、msgraph-sdk-go の api が巨大過ぎてメモリを浪費したりコンパイルに時間がかかったりするという issue をみつけた。</p><ul><li><a href=https://github.com/microsoftgraph/msgraph-sdk-go/issues/436>Memory Leak when creating msgraph client #436</a></li></ul><p>私のローカル環境で測ってみると、約36秒で完了していたテストが2分23秒かかるようになっていた。テストの実行が4-5倍ぐらい遅くなった。さらにコンテナイメージのサイズは 36 MiB から 109 MiB と3倍ほど増えた。無駄に開発を遅らせる環境要因になっているのでこれは別途調査して対応しないといけないことに気付いた。</p></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2023/0427/>docker image のマルチプラットフォーム対応</a></h1><div class=post-meta><time class=post-date>2023-04-27</time></div><span class=post-tags>#<a href=/diary/tags/docker/>docker</a>&nbsp;
#<a href=/diary/tags/ci/cd/>ci/cd</a>&nbsp;</span><div class=post-content><p>22時に寝て0時に起きてやや吐き気で苦しんで4時に起きて7時に起きた。夜遅くに食べてないのに調子悪かった。</p><h2 id=docker-image-のマルチプラットフォーム対応>docker image のマルチプラットフォーム対応</h2><p>やぎさんが <a href=https://blog.ayakumo.net/entry/2023/04/21/004712>docker buildx でマルチプラットフォームのイメージを作成する</a> の記事を書いてて <a href=https://github.com/docker/buildx>buildx</a> プラグインがあることを知った。ちょうどいまお仕事でコンテナベースのプロダクトを開発している。まずはオンプレミス向けが対象なので amd64 でビルドしていた。今後はクラウド向けにも提供していくので arm64 ビルドもいずれ追加しないといけないと考えていた。ちょうどリリースを終えて調査時間の余裕があるのでこの機会に buildx について調べてみることにした。</p><p><a href=https://docs.docker.com/engine/release-notes/23.0/>Docker Engine 23.0 release notes</a> をみると次のように書いてある。</p><blockquote><ul><li>Set Buildx and BuildKit as the default builder on Linux. moby/moby#43992<ul><li>Alias docker build to docker buildx build. docker/cli#3314</li><li>The legacy builder can still be used by explicitly setting DOCKER_BUILDKIT=0.</li><li>There are differences in how BuildKit and the legacy builder handle multi-stage builds. For more information, see Multi-stage builds.</li></ul></li></ul></blockquote><p>23 からデフォルトのビルダーとして buildx が使われるようになっているらしい。<a href=https://github.com/docker/buildx#building-multi-platform-images>Building multi-platform images</a> を一通り読んで試してみた。</p><p>buildx ではカスタムビルダーを定義して複数プラットフォーム向けの docker image を一緒にビルドできる。このとき個々のビルド環境を <em>builder instance</em> と呼び、ビルド環境を抽象した概念として扱われている。マルチプラットフォーム対応の文脈で言えば amd64 や arm64 のビルド環境をそれぞれに作る。例えば amd64 のマシン上で arm64 のビルド環境を作るときは <a href=https://www.qemu.org/>qemu</a> を使ってエミュレーションしたビルド環境を用意したりもできる。builder instance はカスタムビルダーで制御する。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ docker buildx create --name mybuilder --platform linux/amd64,linux/arm64
</span></span><span style=display:flex><span>$ docker buildx ls
</span></span><span style=display:flex><span>NAME/NODE    DRIVER/ENDPOINT             STATUS   BUILDKIT PLATFORMS
</span></span><span style=display:flex><span>mybuilder    docker-container
</span></span><span style=display:flex><span>  mybuilder0 unix:///var/run/docker.sock inactive          linux/amd64*, linux/arm64*
</span></span></code></pre></div><p>ここで作ったカスタムビルダーの driver は、デフォルトビルダーの <code>docker</code> ではなく、<code>docker-container</code> になる。おそらく builder instance の実体であるビルド環境がコンテナ上に構築されるのだと思う。これらの builder instance を使ってビルドされる。カスタムビルダーをデフォルトで使うには次のように実行する。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ docker buildx use mybuilder
</span></span></code></pre></div><p>このカスタムビルダーを使って docker image をビルドする。カスタムビルダー側にプラットフォームの設定をもっているので <code>--platform</code> は指定しなくてもよいけど、明示した方がわかりやすいだろう。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ docker buildx build --platform linux/amd64,linux/arm64 -t myimage:latest .
</span></span></code></pre></div><p>ビルドの処理は進んでいたが、正常終了しなかったので途中でやめた。なにか設定の漏れがあるかもしれないが、だいたいの雰囲気はつかめた。</p><p>ここでいま gitlab ci/cd 環境では <a href=https://github.com/GoogleContainerTools/kaniko>kaniko</a> というツールを使って docker image をビルドしている。そもそも kaniko と buildx の違いもわからなくなって README を読み返すと次のようなことが書いてあった。</p><blockquote><p>kaniko は Docker デーモンに依存せず、Dockerfile 内の各コマンドを完全にユーザースペースで実行します。これにより、標準的な Kubernetes クラスタのように、Docker デーモンを簡単かつ安全に実行できない環境でもコンテナイメージを構築することができます。</p></blockquote><p>ローカルで検証しているとしばしば忘れてしまうが、docker cli を使うには docker daemon を起動しておかないといけない。ci/cd におけるビルド環境がそもそも dokcer で動いていたりすると docker daemon を使えるかどうか (dind: docker in docker) はセキュリティ上の大きな違いになってくる。ci/cd 環境によっては docker daemon が使えないという状況はありえる。そういった環境でも docker image をビルドできるのが kaniko のメリットと言える。</p><p>kaniko はマルチプラットフォーム対応なビルドができるのかどうか？issue でもそういった質問がいくつかみつかる。</p><ul><li><a href=https://github.com/GoogleContainerTools/kaniko/issues/786>how to build multi-arch image using kaniko #786</a></li><li><a href=https://github.com/GoogleContainerTools/kaniko/issues/1746>Multi architecture build with only Kaniko #1746</a></li></ul><p>結論から言うと、kaniko そのものはマルチプラットフォーム対応のビルド機能をもっていない。アーキテクチャごとのビルド環境があればそれぞれビルドするだけになる。しかし、マルチプラットフォーム対応の docker image というのは <a href=https://docs.docker.com/engine/reference/commandline/manifest/>manifest list</a> というのを作ってコンテナレジストリに push すればよいという仕組みらしい。この manifest を作るためのツールとして <a href=https://github.com/estesp/manifest-tool>manifest-tool</a> というのがある。このツールと組み合わせれば、kaniko でもマルチプラットフォーム対応の docker image をコンテナレジストリに登録できる。実際に試したわけではないので想像で書くが次のような手順だと推測する。</p><ol><li>kaniko でそれぞれのプラットフォームの docker image をビルドする<ol><li>amd64 向けにビルドする => latest-amd64</li><li>arm64 向けにビルドする => latest-arm64</li></ol></li><li>ビルドされた複数プラットフォームの docker image に対して manifest-tool でコンテナレジストリに push する<ol><li><code>latest-</code> prefix のタグをもつ docker image の manifest list を作る</li><li>manifest list を使ってコンテナレジストリへ push する</li></ol></li></ol><p>ci/cd 環境でこういった手順のパイプライン処理やジョブを定義して実行すれば kaniko でもマルチプラットフォーム対応な docker image を push できると思う。</p></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2023/0329/>gitlab packages api の使い方</a></h1><div class=post-meta><time class=post-date>2023-03-29</time></div><span class=post-tags>#<a href=/diary/tags/gitlab/>gitlab</a>&nbsp;
#<a href=/diary/tags/ci/cd/>ci/cd</a>&nbsp;
#<a href=/diary/tags/packaging/>packaging</a>&nbsp;</span><div class=post-content><p>0時に寝て何度か起きて6時半に起きた。先週より少し早く起きれるようになってきた。</p><h2 id=gitlab-cicd-で別プロジェクト-リポジトリ-の成果物を取得する>gitlab ci/cd で別プロジェクト (リポジトリ) の成果物を取得する</h2><p>gitlab では複数のパッケージリポジトリに対応しているが、それらに当てはまらない汎用の成果物向けに <a href=https://docs.gitlab.com/ee/user/packages/generic_packages/>GitLab Generic Packages Repository</a> というものがある。zip でもバイナリファイルでも何でも置くためのリポジトリと言える。但し、同じパッケージ名でバージョン管理するといった作りにはなっていなくて、同じパッケージ名でアップロードしても別のパッケージ id が割り当てられて管理される。他バージョンとの紐付け自体はできているので、おそらく歴史的経緯でそういう仕様なのだと思う。そのために、あるパッケージの最新のバージョンを取得したいときは作成日の降順でソートして最初のパッケージを取得するといったコードを書かないといけない。それは <a href=https://docs.gitlab.com/ee/api/packages.html>Packages API</a> を駆使して簡単なスクリプトを書くことになる。</p><p>もう1つ分からないことにトークンの使い分けがある。なるべく ci/cd での処理は <a href=https://docs.gitlab.com/ee/ci/jobs/ci_job_token.html>GitLab CI/CD job token</a> を使いたいところだが、どうも Packages API の呼び出しはできなくて別途プロジェクトでアクセストークンを作成して呼び出すようにしている。これはもしかしたら別の設定で CI/CD job token でも呼び出しできるかもしれない。rest api への呼び出し権限そのものがないのかもしれない。</p><p>最終的には次のようなスクリプトで任意のプロジェクトの generic リポジトリの最新の成果物を取得できた。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>rm -rf <span style=color:#e6db74>${</span>TARGET_DIR<span style=color:#e6db74>}</span>
</span></span><span style=display:flex><span>mkdir -p <span style=color:#e6db74>${</span>TARGET_DIR<span style=color:#e6db74>}</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> project in $PROJECTS
</span></span><span style=display:flex><span><span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  prj<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>echo <span style=color:#e6db74>&#34;</span>$project<span style=color:#e6db74>&#34;</span> | jq -Rr @uri<span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span>  base<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>CI_API_V4_URL<span style=color:#e6db74>}</span><span style=color:#e6db74>/projects/</span><span style=color:#e6db74>${</span>prj<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>  pkg<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>curl -s -H <span style=color:#e6db74>&#34;PRIVATE-TOKEN: </span>$PROJECT_ACCESS_TOKEN<span style=color:#e6db74>&#34;</span> <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>base<span style=color:#e6db74>}</span><span style=color:#e6db74>/packages?order_by=created_at&amp;sort=desc&amp;per_page=1&#34;</span> | jq <span style=color:#e6db74>&#39;.[0]&#39;</span><span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span>  pkg_id<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>echo $pkg | jq -r .id<span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span>  pkg_name<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>echo $pkg | jq -r .name<span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span>  pkg_version<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>echo $pkg | jq -r .version<span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span>  file_names<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>curl -s -H <span style=color:#e6db74>&#34;PRIVATE-TOKEN: </span>$PROJECT_ACCESS_TOKEN<span style=color:#e6db74>&#34;</span> <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>base<span style=color:#e6db74>}</span><span style=color:#e6db74>/packages/</span><span style=color:#e6db74>${</span>pkg_id<span style=color:#e6db74>}</span><span style=color:#e6db74>/package_files&#34;</span> | jq -r <span style=color:#e6db74>&#39;.[].file_name&#39;</span><span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> file_name in $file_names
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>    dw_endpoint<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>base<span style=color:#e6db74>}</span><span style=color:#e6db74>/packages/generic/</span><span style=color:#e6db74>${</span>pkg_name<span style=color:#e6db74>}</span><span style=color:#e6db74>/</span><span style=color:#e6db74>${</span>pkg_version<span style=color:#e6db74>}</span><span style=color:#e6db74>/</span><span style=color:#e6db74>${</span>file_name<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>    curl -s -H <span style=color:#e6db74>&#34;PRIVATE-TOKEN: </span>$PROJECT_ACCESS_TOKEN<span style=color:#e6db74>&#34;</span> <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>dw_endpoint<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span> -o <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>TARGET_DIR<span style=color:#e6db74>}</span><span style=color:#e6db74>/</span><span style=color:#e6db74>${</span>file_name<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>done</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>done</span>
</span></span><span style=display:flex><span>find <span style=color:#e6db74>${</span>TARGET_DIR<span style=color:#e6db74>}</span> -type f
</span></span></code></pre></div></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2023/0324/>コンテナの運用ツールを作る</a></h1><div class=post-meta><time class=post-date>2023-03-24</time></div><span class=post-tags>#<a href=/diary/tags/docker/>docker</a>&nbsp;
#<a href=/diary/tags/ci/cd/>ci/cd</a>&nbsp;</span><div class=post-content><p>1時に寝て明け方に起きて7時に起きた。あまり眠れてない雰囲気がある。</p><h2 id=dockercompose-の運用>docker/compose の運用</h2><p>いま作っているアプリケーションは <a href=https://docs.docker.com/compose/>docker compose</a> で構成している。マージ単位で gitlab ci/cd から docker image をビルドしていて、テスト環境のデプロイスクリプトで最新の docker image を取得してコンテナを再作成するようにしている。デプロイスクリプトは docker cli と docker compose cli の2つを組み合わせてシェルスクリプトで実装しているが、複数のアプリケーションやミドルウェアがあるのでそれらを統合的に扱うことはできないし、さまざまな状況を想定して動くようにもなっていない。がんばれば doccker/compose cli と jq とシェルスクリプトで細かい要件を実装することもできるけど、それをお客さんの本番環境においても使うには一定の cli 操作に慣れが必要な上、docker/compose の知識やスキルも要求してしまう。少なくとも頻繁にある運用作業として docker image の更新やコンテナの再作成が想定される。ローリングアップデートまでは実装しないけど、アプリケーションの要件にあわせた docker image の更新とコンテナの再作成 (アプリケーションの再起動) ぐらいはまとめてやってしまってよいと思う。</p><p>github.com/docker/docker は <a href=https://github.com/moby/moby>github.com/moby/moby</a> にリダイレクトされる。docker は開発ツール、moby はインフラやライブラリという住み分けでそれぞれに関心のあることに注力するようにモジュール構成を分離している。それが2019年に行われていまもおそらくまだ途上だと思う。あと docker のモジュール群は go modules に対応していない。大きなプロジェクトが移行するのが大変なのは理解できるけれど、依存解決のような複雑なところを放置するのはまったく賛成できない。そこが不健全だと依存ライブラリの整理やモジュール分割がうまく進まない気がする。docker の client は <a href=https://github.com/moby/moby/tree/master/client>https://github.com/moby/moby/tree/master/client</a> に定義されていて、readme のサンプルコードにあるようにすぐに使えるようになっている。一方で compose の spec は <a href=https://github.com/compose-spec/compose-go>github.com/compose-spec/compose-go</a> で定義されていて、<a href=https://github.com/docker/compose>github.com/docker/compose</a> はまだライブラリとして使いやすいようにはなっていない。仕様と実装が混在していて動いている状態。そういう issue もあげられている。</p><ul><li><a href=https://github.com/docker/compose/issues/9602>Using compose as library #9602</a></li></ul><p>testcontainers-go というアプリケーションが compose をライブラリとして使う実装をしている。このコードをみれば compose をどう使えばよいのかはわかる。</p><ul><li><a href=https://golang.testcontainers.org/features/docker_compose/>Using Docker Compose</a></li></ul><p>自分で compose を実装してもよいけれど、compose の service を扱うための project やオプションの設定が煩雑なことも伺える。仕様と実装が混在しているというのはそこら変の整理ができていないようにみえるからだ。testcontainers-go も自前の client を用意して使いやすいようにしているのでそれを再利用した方が運用ツールを作るのは簡単になる。testcontainers-go の compose client 経由で compose の up/down を制御する。その他のコンテナの操作は docker client を直接使って実装する。この組み合わせで自分たちのアプリケーション向けの運用ツールを作ろうと思う。</p><blockquote class=twitter-tweet><p lang=ja dir=ltr>コンテナを操作する運用ツールを作るために docker をライブラリとして使ってツールを作っている。関連するところの docker のソースを読んでいて、感覚的にあまり洗練されていない印象をうける。依存解決も意味不明な所感。</p>&mdash; Tetsuya Morimoto (@t2y) <a href="https://twitter.com/t2y/status/1639233150357471233?ref_src=twsrc%5Etfw">March 24, 2023</a></blockquote><script async src=https://platform.twitter.com/widgets.js></script></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2023/0322/>プライベートリポジトリの go アプリケーションの依存解決</a></h1><div class=post-meta><time class=post-date>2023-03-22</time></div><span class=post-tags>#<a href=/diary/tags/go/>go</a>&nbsp;
#<a href=/diary/tags/ci/cd/>ci/cd</a>&nbsp;
#<a href=/diary/tags/coworking/>coworking</a>&nbsp;
#<a href=/diary/tags/event/>event</a>&nbsp;</span><div class=post-content><p>0時に寝て6時半に起きた。面倒なお仕事を朝から集中して片づけた。</p><h2 id=gomod-のプライベートリポジトリの依存解決>go.mod のプライベートリポジトリの依存解決</h2><p>非公開のプライベートリポジトリで開発している go アプリケーションを他のリポジトリから依存ライブラリとして使う方法を調べた。go modules は基本的に公開されたパブリックなリポジトリを前提としている。go.mod のワークフローで他の依存ライブラリと同様にバージョン管理ができるようにするには、プライベートリポジトリであることを go.mod に認識させ、トークンなどを使って認証する必要がある。</p><p><a href=https://go.dev/doc/go1.13>go 1.13</a> から <code>GOPROXY</code> と <code>GOPRIVATE</code> という環境変数が追加された。デフォルトでは GOPROXY は <a href=https://proxy.golang.org>https://proxy.golang.org</a> に設定されており、このプロキシサーバー経由で依存ライブラリを取得する。これは公開リポジトリを、ある日、作者が急に削除したり非公開にしたときにビルドできないといった問題を防ぐために依存ライブラリのリポジトリをキャッシュしてくれる役割を担っている。</p><p>一方でインターネット上のプロキシサーバーからはプライベートリポジトリへアクセスできないので <code>GOPRIVATE</code> を設定してアクセスできないサイトを go.mod へ教えてあげる必要がある。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ go env -w GOPRIVATE<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;private.repo.jp&#34;</span>
</span></span><span style=display:flex><span>$ go env | grep GOPRIVATE
</span></span><span style=display:flex><span>GOPRIVATE<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;private.repo.jp&#34;</span>
</span></span></code></pre></div><p>通常 go.mod は https で依存ライブラリをリポジトリから取得 (クローン) しようとする。このときに git の設定を変更することで特定のサイトへのアクセスを ssh 経由に変更できる。次の例では <code>https://private.repo.jp</code> へのアクセスをすべて <code>ssh://git@private.repo.jp</code> でクローンできる。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ git config --global url.<span style=color:#e6db74>&#34;ssh://git@private.repo.jp&#34;</span>.insteadOf <span style=color:#e6db74>&#34;https://private.repo.jp&#34;</span><span style=color:#e6db74>`</span>
</span></span><span style=display:flex><span>$ tail -n <span style=color:#ae81ff>2</span> ~/.gitconfig
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>url <span style=color:#e6db74>&#34;ssh://git@gitlab.osstech.co.jp&#34;</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>        insteadOf <span style=color:#f92672>=</span> https://gitlab.osstech.co.jp
</span></span></code></pre></div><p>これで git リポジトリのクローンは ssh で行われるようになるが、go.mod のワークフローでは https でもアクセスする処理があるようにみえる。https でもアクセスできるように PAT などのトークンを取得して次のように <code>~/.netrc</code> に https でプライベートリポジトリへアクセスするための認証設定を追加する。</p><pre tabindex=0><code>machine private.repo.jp
login t2y 
password ${PERSONAL_ACCESS_TOKEN}
</code></pre><ul><li><a href=https://www.digitalocean.com/community/tutorials/how-to-use-a-private-go-module-in-your-own-project>How to Use a Private Go Module in Your Own Project</a></li><li><a href=https://erwinvaneyk.nl/private-repositories-with-go-mod/>How to use private repositories with Go modules</a></li></ul><h2 id=コワーキングのオンラインイベント>コワーキングのオンラインイベント</h2><p>月例のカフーツさんのオンラインイベントに参加した。<a href=/diary/posts/2023/0215/#コワーキングのオンラインイベント>先月の所感はここ</a> 。いとうさんの近況を把握していないが、どうやらバリ島 (インドネシア) のコワーキングスペースをいくつか訪問してきたらしい。その旅程を写真をみながらふりかえるようなイベントだった。バリ島の自然や建物の雰囲気が伺えてとてもおもしろかった。</p><p>いとうさんからバリ島はデジタルノマドの先進的な取り組みをしているように聞いていた。例えば <a href=https://cosmicalz.com/indonesianomadvisaunderconsideration>バリ島でリモートも可能!?インドネシアのノマドビザは最長5年を検討中</a> にあるように最長5年のビザを用意しているという話しが日本で盛り上がっているが、現地ではまだ正式にそのようなビザがあるようには存在が確認されていないらしい。それに近い長期のビザを取得するには、一定の金融資産があることを証明しないといけないらしく、日本円だと数千万円程度ないとビザを取得できないのではないか？といった話題もあったと思う。基本的にインドネシア政府は海外から金持ちを呼び込みたいらしく、金持ち向けに待遇のよいビザを整備するのではないかとのこと。ビザの話しはともかく、ここ2-3年でバリ島のコワーキングスペースもいくつか廃業しているらしい。それは利用者の大半が外国人であったため、コロナ禍により、インドネシア政府からの要請もあって外国人に帰国を促したという。外国人利用者の半分ぐらいが自分たちの国に帰ってしまい、施設の運用コストを維持できなくなった。バリ島は今後の成長が見込まれていることから数年前から外資が入ってきて土地や家賃が急騰しているために利用者が激減すると運用コストを維持できなくなったとのこと。</p><p>肝心のバリ島のコワーキングスペースの雰囲気を聞いていると、利用者は外国人が大半で、感覚的にはヨーロッパから来ている人が多そうだといとうさんが話された。バリ島のコワーキングスペースでいとうさんが見学していたときには、現地の人たちと外国人のコミュニティが活発に活動しているようにはあまりみえなかったらしい。利用者もそう多くはなかったし、その人たちも静かにただ作業しているだけのように映ったという。いとうさんはコワーキングスペースとはコミュニティやコラボレーションが重要という話しをよくしているけれど、バリ島のコワーキングスペースに関しては裕福な外国のデジタルノマドを呼び込むのに成功しただけのような、もしかしたらコロナ禍でそのコミュニティが破壊されてしまったのかもしれないが、普段このイベントで話しているような高い期待値に応えられるような状況ではないようにみえたという。</p><p>とはいえ、日本の田舎よりは遥かにデジタルノマドが集まる場所として世界的に認知されているところなので写真をみながら私もいつか行ってみたいと思えた。</p></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2023/0206/>集中のち寝不足</a></h1><div class=post-meta><time class=post-date>2023-02-06</time></div><span class=post-tags>#<a href=/diary/tags/gitlab/>gitlab</a>&nbsp;
#<a href=/diary/tags/ci/cd/>ci/cd</a>&nbsp;
#<a href=/diary/tags/go/>go</a>&nbsp;</span><div class=post-content><p>1時に帰ってきてそのまま寝ないで6時10分の新幹線に乗ってから2時間半ほど寝た。これはこれで時間の使い方が有意義な気がする。午前中は翌日の定例会議の準備を着々と進めて、ci/cd 環境の改善、午後からリファクタリングなどをやっていた。15時をまわると眠くなってきて散歩したりして気分転換しつつも体調悪いなと思って17時半にお仕事を終えてホテルへ戻って2-3時間ほど寝てた。その後、晩ご飯食べるかなと出掛けたものの、あまり食欲もなくて、2時間ほど付近を散歩して運動していた。たまにはそういうのもいいか。飲食店が多い地域なので外から眺めているだけでもわりと楽しい。</p><h2 id=ssh-経由のデプロイ>ssh 経由のデプロイ</h2><p>これまで ci/cd でテストして docker イメージをビルドしてコンテナレジストリに登録するところまでやっていた。実際にテスト環境にデプロイするときは、テスト環境にログインして更新用のスクリプトを私が手動実行していた。そんなに頻繁にテスト環境を更新する必要がなかったのでそれでも十分ではあるものの、ci/cd の完成形を目指すなら自動化すべきという考え方もあってデプロイの部分を作ることにした。</p><p>もっとも簡単な方法として <a href=https://docs.gitlab.com/ee/ci/ssh_keys/>Using SSH keys with GitLab CI/CD</a> をみながら、ssh でテスト環境にデプロイすることにした。すでに更新用のスクリプトがあって、テスト環境にログインして実行すればできる状態なので ssh さえ使えればすぐに移行できるという話しでもある。openssh-client を使うためにベースイメージを alpine から ubuntu にしてパッケージをインストールしないといけない。実行時間がややかかるというコスト以外には気にならないかな。ssh の秘密鍵を <code>file</code> 種別でもつのか通常の環境変数でもつのかで扱いが異なって、それに少しはまったぐらいですぐできた。今後は docker イメージのビルド単位に自動的にデプロイされるようになる。</p><h2 id=interface-の型エイリアスとしての-any>interface{} の型エイリアスとしての any</h2><p>go のコードをリファクタリングしていて json.Marshal の引数が <code>any</code> となっていることに気付いた。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Marshal</span>(<span style=color:#a6e22e>v</span> <span style=color:#a6e22e>any</span>) ([]<span style=color:#66d9ef>byte</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>go 1.18 以降で <code>interface{}</code> の型エイリアスとして <code>any</code> が定義されているらしい。任意の型を扱えるシグネチャとして、メソッドの振る舞いのみを規定する <code>interface{}</code> を使うというのは型システムとしては正しい。他言語でいえば object に相当するものが go はオブジェクト指向言語ではないのでそれがない。そういう間違っていないけど、わかりにくいなと思っていたものに <code>any</code> という名前の型エイリアスが導入されてとてもしっくりきた。プログラミングしていて、実務的にどうかというところをちゃんと改善していくところがみえるのは楽しい。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>any</span> = <span style=color:#66d9ef>interface</span>{}
</span></span></code></pre></div><ul><li><a href=https://zenn.dev/syumai/articles/c6q5un1j0msim0aj0ca0>Go 1.18 で interface{} の代わりに any が使えるようになる話</a></li></ul></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2023/0130/>思い立ったらドキュメントを公開</a></h1><div class=post-meta><time class=post-date>2023-01-30</time></div><span class=post-tags>#<a href=/diary/tags/document/>document</a>&nbsp;
#<a href=/diary/tags/ci/cd/>ci/cd</a>&nbsp;
#<a href=/diary/tags/docker/>docker</a>&nbsp;</span><div class=post-content><p>23時に寝て2時頃に少し吐いて起きた。夜遅めに日本酒飲んでいい気分で寝たものの、もう夜に食べたらダメな体になりつつある。4時ぐらいまで起きててそれから寝て7時に起きた。</p><h2 id=echo-の静的ファイルの扱い>echo の静的ファイルの扱い</h2><p>web api のドキュメントは <a href=/diary/posts/2022/1216/#openapi-勉強会>openapi スキーマを使って生成</a> している。本当はこのドキュメントを gitlab pages で公開させたいのだけど、まだそのインフラ構築ができていなくて先送りになっている。いつもローカルで gitlab ci/cd がビルドしたドキュメントをみていたのだけど、ある機能開発をするときにローカルで web api ドキュメントみるの飽きたなと思って、web api サーバーに同梱してしまえと思い立った。テスト環境の web api サーバーは常に動いているのだから、そこに web api のドキュメントが同梱されていて、なんの不都合があろうか？ (いや、なにもない) 。</p><p>次のドキュメントに echo で静的ファイルを扱う方法が書いてある。</p><ul><li><a href=https://echo.labstack.com/guide/static-files/>Static Files</a></li></ul><p>ミドルウェアで実装されているようで簡単に静的ファイルを返せる。指定したパスのディレクトリ配下を扱えるのが <code>Static</code> で、指定したパスのファイルを扱うのが <code>File</code> になる。web api ドキュメントのようなものならキャッシュしてもいいなとは思ったものの、次の issue によると v4 ではミドルウェアで自前実装しないといけないらしい。v5 ではその仕組みが echo の機能として入るかもしれない。</p><ul><li><a href=https://github.com/labstack/echo/issues/1902>TTL (Cache-Control header in response) for static files #1902</a></li></ul><p>その後、gitlab ci/cd で web api サーバーのビルド後、openapi.yml からドキュメント生成をして、任意の static ディレクトリに配置するように設定した。docker のマルチステージビルドを使うと簡単にできる。バックエンドやっていて、サーバーとインフラの両方に手を入れて機能を作っていくときの、うまくできると利便性と達成感の両方を得られるのが楽しい。web api サーバーがドキュメントを提供することは、要件に含まれるわけでも、誰かに指示されたわけでもない。私が勝手にローカルでドキュメントみるの飽きたと思って、勝手に作って、勝手に動くようにしただけ。こういう開発の遊びのゆとりや権限をチームのメンバーにも与えられるようにしていきたい。開発が楽しくて悪いことはなにもないと思うんよね。</p></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2022/1219/>dind をやってみた</a></h1><div class=post-meta><time class=post-date>2022-12-19</time></div><span class=post-tags>#<a href=/diary/tags/gitlab/>gitlab</a>&nbsp;
#<a href=/diary/tags/ci/cd/>ci/cd</a>&nbsp;
#<a href=/diary/tags/docker/>docker</a>&nbsp;
#<a href=/diary/tags/testing/>testing</a>&nbsp;</span><div class=post-content><p>3時に寝て7時半に起きた。最後なのでワールドカップの決勝戦をみてた。接戦で試合もおもしろかったしよかったと思う。</p><h2 id=gitlab-cicd-で-docker-in-docker>gitlab ci/cd で docker in docker</h2><p>ミドルウェアを伴う結合テストは <a href=https://github.com/ory/dockertest>dockertest</a> というツールを使って docker でミドルウェアを起動して実行している。デフォルトで作成した gitlab runner で docker を使おうとすると失敗する。これは gitlab runner が ci/cd ジョブを docker で動かすため docker in docker (これを <em>dind</em> と呼ぶらしい) のための設定が必要になる。大雑把に言えば gitlab runner にそのための権限を設定する必要がある。gitlab の次のドキュメントに詳細が書いてある。</p><ul><li><a href=https://docs.gitlab.com/ee/ci/docker/using_docker_build.html#use-docker-in-docker>Use Docker-in-Docker</a></li></ul><p>gitlab runner に権限を設定したら次のような job が動けば docker in docker は成功と言える。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#f92672>hello-dind</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>stage</span>: <span style=color:#ae81ff>test</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>image</span>: <span style=color:#ae81ff>docker:20.10.21</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>variables</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>DOCKER_HOST</span>: <span style=color:#ae81ff>tcp://docker:2375</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>DOCKER_TLS_CERTDIR</span>: <span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>services</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>docker:20.10.21-dind</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>allow_failure</span>: <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>before_script</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>docker info</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>script</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>docker run hello-world</span>
</span></span></code></pre></div><p>あとになって気付いたことだけど、dockertest の README にも <a href=https://github.com/ory/dockertest#running-dockertest-in-gitlab-ci>Running dockertest in Gitlab CI</a> としていくつか tips が紹介されている。dockertest で作成したリソースからホスト名とポート番号を取得するには次のようなユーティリティを使う必要がある。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>getHostPort</span>(<span style=color:#a6e22e>resource</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>dockertest</span>.<span style=color:#a6e22e>Resource</span>, <span style=color:#a6e22e>id</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>dockerURL</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Getenv</span>(<span style=color:#e6db74>&#34;DOCKER_HOST&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>dockerURL</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;&#34;</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>resource</span>.<span style=color:#a6e22e>GetHostPort</span>(<span style=color:#a6e22e>id</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>u</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>url</span>.<span style=color:#a6e22e>Parse</span>(<span style=color:#a6e22e>dockerURL</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		panic(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>u</span>.<span style=color:#a6e22e>Hostname</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;:&#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>resource</span>.<span style=color:#a6e22e>GetPort</span>(<span style=color:#a6e22e>id</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></article><div class=pagination><div class=pagination__buttons><a href=/diary/tags/ci/cd/page/2/ class="button next"><span class=button__text>過去の日記</span>
<span class=button__icon>→</span></a></div></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2024 Powered by <a href=https://gohugo.io>Hugo</a></span>
<span>:: <a href=https://github.com/panr/hugo-theme-terminal target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/diary/bundle.min.js></script></div></body></html>