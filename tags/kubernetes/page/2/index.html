<!doctype html><html lang=en>
<head>
<title>kubernetes :: forest nook</title>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content>
<meta name=keywords content>
<meta name=robots content="noodp">
<link rel=canonical href=/diary/tags/kubernetes/>
<link rel=stylesheet href=/diary/assets/style.css>
<link rel=stylesheet href=/diary/assets/green.css>
<link rel=stylesheet href=/diary/style.css>
<link rel=apple-touch-icon href=/diary/img/apple-touch-icon-192x192.png>
<link rel="shortcut icon" href=/diary/favicon.ico>
<meta name=twitter:card content="summary">
<meta name=twitter:site content="t2y">
<meta name=twitter:creator content>
<meta property="og:locale" content="en">
<meta property="og:type" content="website">
<meta property="og:title" content="kubernetes">
<meta property="og:description" content>
<meta property="og:url" content="/diary/tags/kubernetes/">
<meta property="og:site_name" content="forest nook">
<meta property="og:image" content="/diary/favicon.ico">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">
<link href=/diary/tags/kubernetes/index.xml rel=alternate type=application/rss+xml title="forest nook">
</head>
<body class=green>
<div class="container full headings--one-size">
<header class=header>
<div class=header__inner>
<div class=header__logo>
<a href=/diary>
<div class=logo>
forest nook
</div>
</a>
</div>
<div class=menu-trigger>menu</div>
</div>
<nav class=menu>
<ul class="menu__inner menu__inner--desktop">
<li><a href=/diary/about>自己紹介</a></li>
<li><a href=/diary/dates>月別一覧</a></li>
<li><a href=/diary/tags>タグ一覧</a></li>
</ul>
<ul class="menu__inner menu__inner--mobile">
<li><a href=/diary/about>自己紹介</a></li>
<li><a href=/diary/dates>月別一覧</a></li>
<li><a href=/diary/tags>タグ一覧</a></li>
</ul>
</nav>
</header>
<div class=content>
<div class=posts>
<div class="post on-list">
<h1 class=post-title>
<a href=/diary/posts/2022/0201/>wiki のドキュメント整理</a>
</h1>
<div class=post-meta>
<span class=post-date>
2022-02-01
</span>
</div>
<span class=post-tags>
#<a href=/diary/tags/datadog/>datadog</a>&nbsp;
#<a href=/diary/tags/kubernetes/>kubernetes</a>&nbsp;
</span>
<div class=post-content>
<p>23時に寝て4時半に起きた。昨日の帰りに自転車でこけて胸を強打してひたすら痛い。起き上がるのも痛い。安静にしてた。</p>
<h2 id=kubernetes-のログ管理と-datadog-agent-のログ連携不具合>kubernetes のログ管理と datadog-agent のログ連携不具合</h2>
<p>先日、<a href=/diary/posts/2022/0127/#ログ連携の不具合調査>datadog にログ連携されていない不具合</a> が発生していて、その1次調査を終えたことについて書いた。緊急対応としては datadog-agent を再起動することで改善することはわかっていたので、その後、kubernetes のログ管理と datadog-agent がどうやって kubernetes クラスター上で実行されているアプリケーションのログを収集しているかを調査していた。今日は wiki に調査してわかったことなどをまとめていた。</p>
<p>kubernetes クラスターはコンテナランタイムに docker を使っていて、アプリケーションの stdout/stderr を docker の logging driver にリダイレクトし、JSON Lines に設定された logging driver が kubernetes ノード上にログファイルとして出力する。datadog-agent は autodiscovery 機能で pod の情報を常にポーリングしていて、pod が新たにデプロイされたらログファイルを pod 内にマウントして、そのマウントしたログファイルを読み込んでログ収集していると思われる。datadog-agent から pod の情報を取得するには kubernetes のサービスアカウントを使っていて、その credential が projected volume としてマウントされて pod 内から利用できる。その credential を使って kubelet api にリクエストすることで pod の情報を取得している。</p>
<p>文章で書けばたったこれだけのことなんだけど、たったこれだけのことを理解するのに次のドキュメントを読んだ。実際の調査のときはわからなかったのでもっと多くのドキュメントを読んでいる。いま書いたことを理解するならこのドキュメントを読めば理解できるはず。</p>
<ul>
<li><a href=https://kubernetes.io/docs/concepts/overview/components/>https://kubernetes.io/docs/concepts/overview/components/</a></li>
<li><a href=https://kubernetes.io/docs/concepts/architecture/control-plane-node-communication/>https://kubernetes.io/docs/concepts/architecture/control-plane-node-communication/</a></li>
<li><a href=https://kubernetes.io/docs/concepts/cluster-administration/logging/>https://kubernetes.io/docs/concepts/cluster-administration/logging/</a></li>
<li><a href=https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/>https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/</a></li>
<li><a href=https://kubernetes.io/docs/concepts/storage/projected-volumes/>https://kubernetes.io/docs/concepts/storage/projected-volumes/</a></li>
<li><a href="https://docs.datadoghq.com/agent/kubernetes/log/?tab=helm">https://docs.datadoghq.com/agent/kubernetes/log/?tab=helm</a></li>
<li><a href="https://docs.datadoghq.com/getting_started/agent/autodiscovery/?tab=kubernetes">https://docs.datadoghq.com/getting_started/agent/autodiscovery/?tab=kubernetes</a></li>
</ul>
<p>ドキュメントに書いてあることを深く理解するために、kubernetes と datadog-agent のソースコードも読んだ。どちらも go 言語で実装されている。</p>
<ul>
<li><a href=https://github.com/kubernetes/kubernetes>https://github.com/kubernetes/kubernetes</a></li>
<li><a href=https://github.com/DataDog/datadog-agent>https://github.com/DataDog/datadog-agent</a></li>
</ul>
<p><code>kubectl logs</code> の振る舞いを確認するだけでも、ソースコードからは実際のログファイルを open してストリームを返しているところはわからなかった。api 呼び出しが連携されて抽象化されていて、コンポーネントの役割分担があって、何も知らずにコードを読んでいてもわからなかった。Kubernetes の低レイヤーのところは Container Runtime Interface (CRI) という標準化を行い、1.20 から docker は非推奨となり、将来的に CRI を提供する実装に置き換わるらしい。ログファイルを open する役割は CRI の実装が担うんじゃないかと思うけど、そこまでは調べきれなかった。また機会があれば CRI の実装も読んでみる。</p>
<figure><img src=/diary/img/2022/0201_kubectl-logs.png>
</figure>
</div>
</div>
<div class="post on-list">
<h1 class=post-title>
<a href=/diary/posts/2022/0131/>ヘルスチェックのレスポンスのステータスコード</a>
</h1>
<div class=post-meta>
<span class=post-date>
2022-01-31
</span>
</div>
<span class=post-tags>
#<a href=/diary/tags/kubernetes/>kubernetes</a>&nbsp;
</span>
<div class=post-content>
<p>1時に寝て6時に起きた。</p>
<h2 id=404-のレスポンスをヘルスチェック>404 のレスポンスをヘルスチェック</h2>
<p>ここ数日はお仕事でインフラ周りの調査をしていた。たまたまログをみていて、ELB のヘルスチェックが 404 になっているのを大量にみつけた。てっきりヘルスチェックを使ってないのだろうと思ってインフラ担当者に問い合わせたら、404 が返ってくることをヘルスチェックしているという。404 をチェックすることになんの意味もなく、ただ急ぎで設定する必要があったからとりあえず動かせるためにそう設定したという。一方でアプリケーション側は spring boot で開発していて、<a href=https://www.baeldung.com/spring-boot-actuators>Spring Boot Actuator</a> も導入されているので <code>/actuator/health</code> にアクセスすれば 200 が返ってくるようになっている。どういう経緯だったかはわからないけど、開発者に一言聞けば 404 のレスポンスをヘルスチェックすることは何もない状態でずっと運用されていたことがわかった。</p>
<p>アプリケーション側の <a href=https://kubernetes.io/docs/concepts/services-networking/ingress/>Kubernetes: Ingress</a> のマニフェストにもそういった設定が入っていて、インフラ側の CDK のコードにもそういったマニフェストがあって、両方の設定変更が必要なのか、アプリケーション側のものだけでいいのか、少し調査が必要ということになった。私も Ingress というのがなにものなのか、よくわかってないので調べて理解する機会としよう。</p>
</div>
</div>
<div class="post on-list">
<h1 class=post-title>
<a href=/diary/posts/2022/0127/>datadog-agent のログ連携の不具合調査</a>
</h1>
<div class=post-meta>
<span class=post-date>
2022-01-27
</span>
</div>
<span class=post-tags>
#<a href=/diary/tags/datadog/>datadog</a>&nbsp;
#<a href=/diary/tags/kubernetes/>kubernetes</a>&nbsp;
</span>
<div class=post-content>
<p>0時に寝て4時に起きた。朝から1時間ほどドラクエタクトやってた。</p>
<h2 id=ログ連携の不具合調査>ログ連携の不具合調査</h2>
<p>少し前に本番環境で <a href=https://github.com/DataDog/datadog-agent>datadog-agent</a> からログが (クラウドの) datadog に連携されていないことがわかった。kubectl logs のコマンドで確認すると、アプリケーションのログは出力されているので datadog-agent から datadog にログを送信するところの問題であるように推測された。たまたま今日、同じような現象をテスト環境で確認できた。ちょうどスクラムのプランニングでログ調査のための作業をするチケットの承認を得たところだった。満を持して発生したような障害だったので私が調査すると明言して調査してた。半日ぐらい調査して、pod 内の credential 情報が置き換わってしまうことが原因っぽいと特定できたが、なぜ置き換わってしまうのかはまだわからない。もう少し調査して解決したら会社のテックブログにいいなと思ったので、日記に書いてた内容を移行することにした。</p>
</div>
</div>
<div class="post on-list">
<h1 class=post-title>
<a href=/diary/posts/2021/1205/>頭文字Dを読了</a>
</h1>
<div class=post-meta>
<span class=post-date>
2021-12-05
</span>
</div>
<span class=post-tags>
#<a href=/diary/tags/life/>life</a>&nbsp;
#<a href=/diary/tags/commic/>commic</a>&nbsp;
#<a href=/diary/tags/tax/>tax</a>&nbsp;
#<a href=/diary/tags/dapr/>dapr</a>&nbsp;
#<a href=/diary/tags/kubernetes/>kubernetes</a>&nbsp;
</span>
<div class=post-content>
<p>0時に寝て7時に起きてだらだらやってて午前中は <a href=https://ja.wikipedia.org/wiki/%E9%A0%AD%E6%96%87%E5%AD%97D>頭文字D</a> のアニメをみてた。漫画 (アニメも？) はすでに完結しているのでいつか読もうと思いつつ最後まで読んでいない。ゴッドフットやゴッドアームが出てくるぐらいまでは読んだ気がする。その後どうなったのかを知らない。イニシャルDをみていると、ストーリーも絵も演出もまったく派手さはなくて普通なんだけど、なぜかおもしろくて続きをみてしまうという人間の娯楽の本質をついている気がしてくる。なんでなんだろうなぁ。</p>
<h2 id=頭文字d>頭文字D</h2>
<p>たまたま思い出したので夜に漫画喫茶行って頭文字Dを最後まで読んできた。全48巻で、31巻ぐらいから読み始めて3-4時間ぐらいで読み終えた。漫画なので仕方ないけど、対戦相手がどんどん強くなっていって勝ち方が玄人好みというのか、単純に抜いた・抜かれたの話しではなく、タイヤマネージメントがどうこうとか、恐怖に対する心理がどうこうとか、ドライバーと車のセッティングも含めた駆け引きが強くなっていって、どちらが速いかというよりは戦略通りの展開にもっていって最後はそれがうまくはまるみたいな、これまでもずっとそうだったんだけど、ここからはよりトップレベルのほんの僅かな差が勝敗を分けるといった描き方になっていったように思う。それはそれで現実に近い気はするけど、漫画的には派手な演出にならないので玄人好みなストーリーになっていった気がする。但し、そこまでやってきて最後の対戦相手だけは、個人的には納得感がなくて、ここまで緻密に作り上げてきた理論や個々のドライバーの修練の積み重ねが圧倒的天才の前にひれ伏すみたいな切り口が急展開していて、頭の切り替えができなかった感じがした。とはいえ、最後まで読み終えられてよかったし、作品としてはすごくおもしろかった。作者はモータースポーツが本当に好きなんだろうなというのが伝わってくる漫画だと思う。</p>
<h2 id=ふるさと納税>ふるさと納税</h2>
<p>あまり欲しいものもないし、ふるさと納税の行政手続きも一通り理解したから今年はやらなくてもいいかとも思っていた。しかし、<a href=https://www.satofull.jp/static/campaign/202112_pcp.php>paypayボーナスキャンペーン</a> をみてやってみるかという気になった。paypay はいろんなものと連携していて見かけるたびにすごいなと思う。お得だからと必要もないものを買うことはないけど、ふるさと納税はやらなかったとしても、どのみち納税は必要なものなので還元があるということは節税につながるのかな？理屈はよくわからないけど、言いたいことは paypay はすごいという話でした。</p>
<h2 id=dapr-の-api-トークンを使った認証>dapr の api トークンを使った認証</h2>
<p><a href=https://docs.dapr.io/operations/security/api-token/>Enable API token authentication in Dapr</a> を一通り読んだ。内容はとくに難しくなく、こんな風に dapr の manifest を書けば <a href=https://jwt.io/>JWT</a> トークンを設定できますということを書いてある。私はずっとサーバーサイドばっかりやってきたからフロントエンドで使われる技術や仕組みに弱い。JWT トークンもその1つで、自分でちゃんと実装したことがないからちゃんとよく分かってない。これが OAuth2 なら provider を実装したこともあるからその仕組みも意図も理解できる。一度どこかで自分で JWT も実装してみないといけないのだろうな。</p>
<p>少し前にお仕事で kubernetes の secret の移行作業をやった。既存の secret にキーバリューを追加するときは patch を使う。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ kubectl patch secret mydata -p<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;{&#34;stringData&#34;:{&#34;mykey&#34;: &#34;myvalue&#34;}}&#39;</span>
</code></pre></div><p>secret の内容を確認するときも2つのやり方がある。キーだけを確認するならこれでよい。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ kubectl describe secrets mydata
</code></pre></div><p>キーに対応する値もデコードして確認するならこうする。但し、閲覧注意。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ kubectl get secret mydata -o json | jq <span style=color:#e6db74>&#39;.data | map_values(@base64d)&#39;</span>
</code></pre></div>
</div>
</div>
<div class="post on-list">
<h1 class=post-title>
<a href=/diary/posts/2021/1122/>kustomize のパッチ適用の違い</a>
</h1>
<div class=post-meta>
<span class=post-date>
2021-11-22
</span>
</div>
<span class=post-tags>
#<a href=/diary/tags/kubernetes/>kubernetes</a>&nbsp;
#<a href=/diary/tags/writing/>writing</a>&nbsp;
</span>
<div class=post-content>
<p>22時ぐらいには寝て6時半に起きた。昨日はお出かけしてきてバテたんで19時頃からうたた寝を繰り返してずっと寝てた。実家に帰っていた期間を除いて、土日のどちらかを休むのはここ3ヶ月はなかったと思うし、土日の2日間ほとんど仕事をしなかったのは半年ぐらいはなかったと思う。久しぶりに土日に仕事しなかったなという印象で、その理由は業務委託のお仕事の契約が決まって余裕があるからだと思う。</p>
<h2 id=kustomize-の-inline-patch>kustomize の Inline Patch</h2>
<p><a href=https://kubectl.docs.kubernetes.io/guides/example/inline_patch/>Inline Patch</a> に次の3つのやり方が説明されている。</p>
<blockquote>
<ul>
<li>patchesStrategicMerge: Strategic Merge Patch として解析されるパッチファイルのリスト</li>
<li>patchesJSON6902: 1つのターゲットリソースのみに適用可能な JSON Patch として解析されるパッチと関連付けされるターゲットのリスト</li>
<li>patches: 関連付けされるターゲットとパッチのリスト。このパッチは複数のオブジェクトに適用でき、パッチが Strategic Merge Patch なのか JSON Patch かは自動的に検出</li>
</ul>
</blockquote>
<p>patches は patchesStrategicMerge と patchesJSON6902 の両方を記述できる。運用上は patchesStrategicMerge か patchesJSON6902 を適用したいパッチの内容によって使い分けることになる。おそらく前者は base にない要素を追加したり、base の要素をすべて置き換えたりするときに使う。後者は base にある map や list の一部の要素のみを限定して置き換えたり、削除したりするときに使う。ちなみに patchesJSON6902 の 6902 というのは <a href=https://datatracker.ietf.org/doc/html/rfc6902>RFC 6902 JavaScript Object Notation (JSON) Patch</a> に由来する。</p>
<p>patchesJson6902 の例として次のような設定にパッチを適用する。base から読まれた metadata の要素から namespace のみを削除したり、spec.metadata の1番目のリストの secretKeyRef が参照する Secret を my-secret で置き換えたりできる。こういったパッチを patchesStrategicMerge で実現することはできないのではないかと思う (詳しくないので私が間違っているかもしれない) 。</p>
<h5 id=baseyml>base.yml</h5>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>apps/v1</span>
<span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Component</span>
<span style=color:#f92672>metadata</span>:
  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-component</span>
  <span style=color:#f92672>namespace</span>: <span style=color:#ae81ff>default</span>
<span style=color:#f92672>spec</span>:
  <span style=color:#f92672>metadata</span>:
  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>username</span>
    <span style=color:#f92672>value</span>: <span style=color:#ae81ff>user</span>
  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>password</span>
    <span style=color:#f92672>secretKeyRef</span>:
      <span style=color:#f92672>name</span>: <span style=color:#ae81ff>base-secret</span>
      <span style=color:#f92672>key</span>: <span style=color:#ae81ff>password</span>
</code></pre></div><h5 id=kustomizationyml>kustomization.yml</h5>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>...
<span style=color:#f92672>patchesJson6902</span>:
  - <span style=color:#f92672>path</span>: <span style=color:#ae81ff>my-patch.yaml</span>
    <span style=color:#f92672>target</span>:
      <span style=color:#f92672>group</span>: <span style=color:#ae81ff>apps</span>
      <span style=color:#f92672>version</span>: <span style=color:#ae81ff>v1</span>
      <span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Component</span>
      <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-component</span>
...
</code></pre></div><h5 id=my-patchyaml>my-patch.yaml</h5>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>- <span style=color:#f92672>op</span>: <span style=color:#ae81ff>remove</span>
  <span style=color:#f92672>path</span>: <span style=color:#ae81ff>/metadata/namespace</span>
- <span style=color:#f92672>op</span>: <span style=color:#ae81ff>replace</span>
  <span style=color:#f92672>path</span>: <span style=color:#ae81ff>/spec/metadata/1/secretKeyRef/name</span>
  <span style=color:#f92672>value</span>: <span style=color:#ae81ff>my-secret</span>
</code></pre></div><h2 id=リーンキャンバスレビュー-前半>リーンキャンバスレビュー (前半)</h2>
<p><a href=/diary/posts/2021/1114/#リーンキャンバス>前に作ったリーンキャンバス</a> を使って友だちにプロダクトの設計をレビューしてもらった。私がリーンキャンバスを作ったことがなかったので、この項目にはどういった内容を書くか、それぞれの項目がどういった関連付けや粒度で整理するかといった、リーンキャンバスの書き方そのものも含めて教えてもらった。</p>
<p>私が設計のために作った40枚のスライドを話すと2時間必要とするが、リーンキャンバスを使えば要点のみ15分で話せるようになるのが狙いになるみたい。とはいえ、リーンキャンバスの書いてある内容の半分を確認するだけで今日は2時間弱かかってしまった。議事録を取りながらだったので話すだけならもっと短くなったかもしれないし、その背景や根拠を細かくツッコミしていくとそれなりの時間はかかるのかもしれない。リーンキャンバス上は数枚の付箋で簡潔に書いてあるが、これどういうこと？みたいな問いになると詳細を説明しないといけないので時間がかかったように思う。リーンキャンバスの精度や品質が上がれば、読み手が詳細を確認しなくても意図を理解しやすくて詳細のツッコミが不要になるのかもしれない。これまで使ったことがないツールでおもしろいので週末に後半を行う。課題管理の背景には実践知、認知心理学、情報共有、組織論といった様々な分野にまたがるのでそのコンテキストを共有するのはなかなか難しいのではないかという思いもある。</p>
</div>
</div>
<div class="post on-list">
<h1 class=post-title>
<a href=/diary/posts/2021/1115/>お仕事しかしなかった一日</a>
</h1>
<div class=post-meta>
<span class=post-date>
2021-11-15
</span>
</div>
<span class=post-tags>
#<a href=/diary/tags/kubernetes/>kubernetes</a>&nbsp;
</span>
<div class=post-content>
<p>2時に寝て6時半に起きた。寝る前にウォーキングしてくるとよく眠れる気がする。お仕事で簡単に終わると思ってた作業にちょっとはまってトラブルシューティングしてたら疲れた。原因はわかって自己解決できたのはよかったけど、消耗して早くお仕事を終えて帰ってくつろいでた。</p>
<h2 id=ローカル開発環境の整備>ローカル開発環境の整備</h2>
<p>お仕事でローカルの k8s 環境の保守の作業をしている。<a href=https://minikube.sigs.k8s.io/docs/>minikube</a> でローカルの k8s クラスターを作成して <a href=https://kubernetes.io/docs/reference/kubectl/overview/>kubectl</a> コマンドで制御する。k8s の yaml の設定ファイルのことをマニフェストと呼ぶのかな？そのテンプレート？ジェネレーター的なツールに <a href=https://kustomize.io/>kustomize</a> を使っている。先週から1週間触っていたので cli の操作にはだいぶ慣れてきた。</p>
<p>まだ基本的な delete & apply みたいなことしかやってないけど、また余裕のあるときに細かいコマンドやロールバックのやり方なども学習しようと思う。デプロイで一番重要なのはロールバック、次にローリングアップデート、ローリングアップデートができればカナリアリリースもできるかな？その2つがあれば運用は大幅にコスト削減できるし、開発のアジリティも上げられる。たぶん k8s を使えば簡単にできるんだろうなというのは delete & apply だけみてもそう受け取れる。k8s クラスターさえマネージドならよく出来た仕組みだなと感心した。</p>
</div>
</div>
<div class="post on-list">
<h1 class=post-title>
<a href=/diary/posts/2021/1108/>Kubernetes 使い始めの雑感</a>
</h1>
<div class=post-meta>
<span class=post-date>
2021-11-08
</span>
</div>
<span class=post-tags>
#<a href=/diary/tags/kubernetes/>kubernetes</a>&nbsp;
</span>
<div class=post-content>
<p>1時に寝て7時に起きた。夜にウォーキングし始めてからよく眠れるようになった気がする。</p>
<h2 id=udemy-kubernetes入門>udemy: Kubernetes入門</h2>
<p><a href=/diary/posts/2021/1107/#udemy-kubernetes入門>昨日</a> の続き。今日はセクション6から最後まで。CI/CD のセクションだけスキップして、他は一通り目を通した。</p>
<h3 id=セクション6-kubernetes実践>セクション6 Kubernetes実践</h3>
<p>1つずつ書くのは大変だけど、数をこなして徐々に覚えていけばよい。手で書くのもよいが、別のやり方としてクライアント側で dry run すると、設定のひな型を作ってくれるのでそれに必要な設定を足すのもよい。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ kubectl create deploy mysql --image<span style=color:#f92672>=</span>mysql:5.7 --dry-run<span style=color:#f92672>=</span>client -o yaml
</code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ kubectl exec -n database -it mysql-787f86d65c-nflxx -- mysql -uroot -ppassword
</code></pre></div><p>データベースとアプリケーションを異なる namespace にデプロイして、それらが通信できるような設定を行う。基本的には <code>--dry-run=client</code> でひな型を作りつつ、必要な設定を追加していくやり方が簡単そうにみえた。とはいえ、実際に設定していくときはどういう設定を追加するとどういう振る舞いになるかを調べながら作業すると思うのでこんな簡単にはできないとは思う。次のようなアプリケーションをデプロイする一覧の流れを理解できた。</p>
<ol>
<li>namespace 作成</li>
<li>Deployment 作成</li>
<li>ConfigMap 作成</li>
<li>Secret 作成</li>
<li>Deployment, ConfigMap, Secret 適用</li>
<li>Service 適用</li>
<li>port-forward でローカルからアクセス</li>
<li>(作成したリソースをすべて削除)</li>
</ol>
<h3 id=セクション7-kubernetesのdebug>セクション7 KubernetesのDebug</h3>
<p>基本は pod のステータスを確認しながら問題があれば、その箇所を追いかけていって原因を調査する。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ kubectl get pod -A
$ kubectl get pod -A --selector run<span style=color:#f92672>=</span>nginx
</code></pre></div><p>k8s 上で実行しているアプリケーションの依存先へ接続できない場合は Service の確認が必要となる。kubectl の get, describe, logs などのサブコマンドをあれこれみながらエラーの原因を把握して、yaml の設定を変更していく。k8s のアーキテクチャとコマンドを覚えていないとなかなか難しそう。</p>
<p>とりあえず動かした後にまとめて全部削除できるのがテストやデバッグに便利そう。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ kubectl delete -f .
</code></pre></div><p>もしくは開発用に独自の namespace を作成して、あとで丸ごと namespace を削除するのでもよさそう。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ kubectl delete ns mynamespace
</code></pre></div><h2 id=k8s-の調査>k8s の調査</h2>
<p>業務のアプリケーションを minikube で作ったローカル k8s クラスターで動かしてみた。ローカルの開発環境の構築方法をメンテナンスして、自分でも一通り k8s の yaml を書いて、デプロイして、振る舞いを確認したりしていた。最初なのでおもしろい。自分で一通りやってみて、k8s が難しいとみんなが言っているのは k8s クラスターを自前で構築するのが難しいのだとようやく理解できた。k8s クラスターがすでにある状態なら kubectl の使い方を覚えるだけで全く難しくない。GKE や EKS を使って運用するなら k8s の運用コストは大したことがないと理解できた。k8s クラスター向けの yaml はたくさん書かないといけないけど、どうせ ECS や EC2 でやっていても CDK や Terraform などのインフラ設定を書くのは同じなのでそこはあまり差がない。k8s はコンテナオーケストレーションをやってくれるメリットが大きいので minikube と EKS の環境の差異があまり問題にならないようなアプリケーション開発であれば、普通に使っていって問題ないように思えた。ローカルで環境作るのが大変なんじゃないかという先入観があったけど、全然そんなことはなかった。コンテナのイメージをビルドしないといけないのが追加のコストかな。</p>
</div>
</div>
<div class="post on-list">
<h1 class=post-title>
<a href=/diary/posts/2021/1107/>普通の休日の翌日</a>
</h1>
<div class=post-meta>
<span class=post-date>
2021-11-07
</span>
</div>
<span class=post-tags>
#<a href=/diary/tags/bizpy/>bizpy</a>&nbsp;
#<a href=/diary/tags/kubernetes/>kubernetes</a>&nbsp;
</span>
<div class=post-content>
<p>5時に寝て10時に起きた。昨日は夕方に2-3時間寝てたのでその分、夜に調べものをしていた。休みたい気持ちもあるけど、調べるものが多過ぎて全然時間が足りない。</p>
<h2 id=bizpy-勉強会の資料作り>bizpy 勉強会の資料作り</h2>
<p><a href=/diary/posts/2021/1106/#slack-apps-の調査>昨日</a> の続き。昨日サンプルコードを実装したので、その設定や要点を <a href=https://github.com/t2y/python-study/tree/master/BizPy/slack/20211027>資料</a> に作成した。現時点で <a href=https://bizpy.connpass.com/event/229091/>Python で Slack のインテグレーションをやってみる勉強会 #2</a> の参加者は10人。連続シリーズは回を重ねるごとに減っていくものなのでこんなもんかな。あともう1回やったら終わりにする。</p>
<h2 id=udemy-kubernetes入門>udemy: Kubernetes入門</h2>
<p>友だちから udemy の k8s のコースがよいと聞いたんだけど、そのコースはいまは提供されていなくて、せっかくなので適当に検索してヒットした <a href=https://www.udemy.com/course/kubernetes-basics-2021/>Kubernetes入門</a> を受講することに決めた。本当は英語の本格的なコースを受講した方がよいのだろうけど、余裕のあるときはそれでいいけど、いま数日で概要を把握して使えるようにしたいので日本語のコースにしてみた。</p>
<ul>
<li><a href=https://blog.ayakumo.net/entry/2018/01/27/010000>Udemy の Learning Docker and Kubernetes by Lab がとてもよい</a></li>
<li><a href=https://blog.ayakumo.net/entry/2018/02/15/232918>Docker, Kubernetes 学習とツールとコンピュータサイエンス</a></li>
</ul>
<p>昨日インストールした minikube のクラスターを使って「Kubernetes入門」のセクション1からセクション5までやった。だいたい半分ぐらい。所感としては、全く何も知らない人には要点をかいつまんで教えてくれるのと、最初に覚えるとよい基本的な CLI のコマンドとその振る舞いや設定を紹介してくれるのでよかった。初めて k8s に挑戦する自分にとってはちょうどよいレベル感だった。全体像の概念を捉えてコンテキストに沿って順番にハンズオン形式で学習していくスタイル。<a href=https://github.com/nakamasato/kubernetes-basics>nakamasato/kubernetes-basics</a> を使って自分でも CLI でコマンドを打ちながら進めてみた。yaml ファイルを定義するのもこれはこれで面倒だけど、この辺は慣れの問題かな？とも思う。いくつか学んだことを整理しておく。</p>
<h3 id=セクション1-introduction>セクション1 Introduction</h3>
<p>k8s には2つのコンポーネントがあり、これを k8s クラスターと呼んでいる。</p>
<ul>
<li>Control Plane (API サーバー)</li>
<li>複数の Worker (Kubelet)</li>
</ul>
<p>yaml で設定する Desired State (理想状態) と呼ばれる設定が登録されると、Control Plane の API サーバーと Worker の kubelet が通信してそれを実現しようとする。pod とは k8s のデプロイの最小単位となる。コンテナ、ポート、レプリカ数などを設定する。pod をそれぞれの Worker にデプロイしたり、Worker がダウンしたときに別の Worker で起動させたりする。</p>
<h3 id=セクション2-kubernets-概要>セクション2 Kubernets 概要</h3>
<p>k8s はコンテナ化したアプリケーションのデプロイ、スケーリング、管理を行うためのオープンソースのコンテナオーケストレーションシステムである。</p>
<ul>
<li>コンテナ
<ul>
<li>独立した環境でアプリケーションを実行する仕組み</li>
<li>コンテナの実態はプロセス</li>
<li>Kernel Namespaces を利用し、プロセスID、ネットワークインターフェース、リソースなどを分離してコンテナ間で干渉しない</li>
<li>ホストマシンへの依存度を最小化してアプリケーションをどこでも実行可能にする
<ul>
<li>従来のやり方の最大の違いはライブラリがホストマシンにインストールされるのではなく、コンテナの内部にインストールされる</li>
</ul>
</li>
</ul>
</li>
<li>オーケストレーション
<ul>
<li>デプロイ、スケーリング、管理などの仕組み</li>
</ul>
</li>
</ul>
<p>1つのアプリケーションは複数のマシン上で動かすことで可用性を高めたいが、コンテナを動かすために考えることが増えていくと管理コストも増えていく。コンテナオーケストレーション機能により次のようなシステム管理者が行っていたことが自動化される。</p>
<ul>
<li>デプロイメント</li>
<li>スケジューリング</li>
<li>オートスケーリング
<ul>
<li>負荷に応じてコンテナ数やマシン数を増減させる</li>
</ul>
</li>
<li>ネットワーク</li>
<li>リソースマネジメント</li>
<li>セキュリティ
<ul>
<li>ネットワークポリシーやリソースの権限定義</li>
</ul>
</li>
</ul>
<p>k8s クラスターの構造は次になる。</p>
<ul>
<li>Control Plane
<ul>
<li>api: kubelet と通信するサーバー</li>
<li>etcd: 設定などを格納するキーバリューストア</li>
<li>shed: kube スケジューラー</li>
<li>c-m: コントロールマネージャー</li>
<li>c-c-m: クラウドプロバイダと api 連携する
<ul>
<li>ローカルで使うときは必要ない</li>
</ul>
</li>
</ul>
</li>
<li>Worker ノードはコンテナランタイムをいインストールしておく必要がある
<ul>
<li>kubelet は Control Plane と通信するためのエージェントとして動作する</li>
</ul>
</li>
</ul>
<p>一番需要なこととして、k8s は理想状態と現実状態を比較して、理想状態に近づけようとする。app.yaml の理想状態を kubectl を用いて api サーバーを介して etcd に格納する。現実状態は kubelet から api サーバーを介して etcd に格納される。c-m は理想状態と現実状態のチェックを行い、異なっていれば理想状態に近づけることをしていく。</p>
<h3 id=セクション4-kubectl>セクション4 kubectl</h3>
<p>minikube で最初に起動しているのは Control Plane を起動していることが理解できた。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ minikube start
$ kubectl config current-context
minikube
</code></pre></div><p>同時に ~/.kube/config に kubectl の設定も追加される。<code>minikube</code> という名前でクラスター、ユーザー、コンテキストが設定される。</p>
<p>リソース一覧の確認。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ kubectl api-resources
</code></pre></div><p>出力フォーマットも様々。例えば、デフォルトの表示は次になる。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ kubectl get node
NAME       STATUS   ROLES                  AGE     VERSION
minikube   Ready    control-plane,master   7m21s   v1.22.2

$ kubectl get node -o wide
NAME       STATUS   ROLES                  AGE     VERSION   INTERNAL-IP    EXTERNAL-IP   OS-IMAGE             KERNEL-VERSION      CONTAINER-RUNTIME
minikube   Ready    control-plane,master   8m38s   v1.22.2   192.168.49.2   &lt;none&gt;        Ubuntu 20.04.2 LTS   5.11.0-38-generic   docker://20.10.8
</code></pre></div><p>より詳細な情報をそれぞれのフォーマットで表示する。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ kubectl get node -o json
$ kubectl get node -o yaml
</code></pre></div><p>namespace を確認する。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ kubectl get namespace
NAME              STATUS   AGE
default           Active   10m
kube-node-lease   Active   10m
kube-public       Active   10m
kube-system       Active   10m
</code></pre></div><p>namespace を指定して pod 一覧を取得する。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ kubectl get pod --namespace kube-system
NAME                               READY   STATUS    RESTARTS      AGE
coredns-78fcd69978-qxqbn           1/1     Running   <span style=color:#ae81ff>0</span>             11m
etcd-minikube                      1/1     Running   <span style=color:#ae81ff>0</span>             11m
kube-apiserver-minikube            1/1     Running   <span style=color:#ae81ff>0</span>             11m
kube-controller-manager-minikube   1/1     Running   <span style=color:#ae81ff>0</span>             11m
kube-proxy-g55hg                   1/1     Running   <span style=color:#ae81ff>0</span>             11m
kube-scheduler-minikube            1/1     Running   <span style=color:#ae81ff>0</span>             11m
storage-provisioner                1/1     Running   <span style=color:#ae81ff>1</span> <span style=color:#f92672>(</span>10m ago<span style=color:#f92672>)</span>   11m
</code></pre></div><p>グローバルな CLI のオプションを確認する。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ kubectl options
</code></pre></div><p>ノードの詳細を表示する。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ kubectl describe node
</code></pre></div><p>describe は名前の接頭辞を指定できるので namespace ならこんな感じに実行できる。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ kubectl describe namespace kube-
</code></pre></div><h3 id=セクション5-kubernetes-リソース>セクション5 Kubernetes リソース</h3>
<p>pod とは k8s 上のデプロイの最小単位である。</p>
<ul>
<li>1つまたは複数のコンテナをもつ</li>
<li>ネットワークやストレージを共有リソースとしてもつ</li>
<li>コンテナの実行方法に関する仕様をもつ</li>
</ul>
<p>pod が使えなくなった場合に他のノードにデプロイされることもある。1つのアプリケーションを複数の pod でデプロイすることが多い。なるべく複数のアプリケーションを1つの pod に入れない。個別の pod を直接操作しない。</p>
<p>共有コンテキスト</p>
<ul>
<li>同一 pod 内のコンテナは同じストレージにアクセスできる</li>
<li>同一 pod 内のコンテナは ip アドレスとポートを含むネットワーク名前空間を共有する</li>
</ul>
<p>k8s オブジェクト</p>
<ul>
<li>クラスタの状態を表現する</li>
<li>2つのフィールドをもつ
<ul>
<li>spec: 理想状態 (desired status)</li>
<li>status: 現実状態 (current status)</li>
</ul>
</li>
</ul>
<p>pod の作成は k8s オブジェクトを作成している。オブジェクト作成時の必須フィールドが4つある。</p>
<ul>
<li>apiVersion</li>
<li>kind</li>
<li>metadata</li>
<li>spec</li>
</ul>
<p>namespace は同一クラスター上で複数の仮想クラスターの動作をサポートする。</p>
<ul>
<li>仮想クラスターとは、物理的には同じマシンで動いているかもしれないが、仮想的に環境を分離している
<ul>
<li>1つのクラスターを論理的にわける</li>
<li>チームや部署ごとにわけて使い分けたりすることも多い</li>
</ul>
</li>
</ul>
<p>namespace を使うメリットは次になる。</p>
<ul>
<li>pod やコンテナのリソースの範囲設定</li>
<li>namespace 全体の総リソース制限</li>
<li>権限管理</li>
</ul>
<p>初期の namespace として4つあるが、初心者は最初の2つだけをまず覚えておく。</p>
<ul>
<li>default:</li>
<li>kube-system:</li>
<li>kube-public:</li>
<li>kube-node-lease</li>
</ul>
<p>namespace と cluster の違い。</p>
<ul>
<li>Namespace-scoped リソース
<ul>
<li>namespace に属しているリソース</li>
</ul>
</li>
<li>Cluster-scoped リソース
<ul>
<li>クラスター全体で使われるもの</li>
</ul>
</li>
</ul>
<p>次のコマンドで確認できる。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ kubectl api-resources --namespaced<span style=color:#f92672>=</span>true 
</code></pre></div><p>namespace の作成</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ kubectl create namespace my-namespace
</code></pre></div><p>ワークロードリソースとは複数の pod を作成・管理するためのリソース。ワークロードリソースは pod テンプレートを使って pod を作成する。</p>
<ul>
<li>ReplicaSet
<ul>
<li>常に指定したレプリカ数の pod を保つ</li>
</ul>
</li>
<li>Deployment
<ul>
<li>ローリングアップデートやロールバックなどのアップデート機能を提供</li>
<li>ReplicaSet のロールアウト</li>
<li>不安定な場合の前のバージョンへロールバック</li>
<li>使用頻度が高い
<ul>
<li>ほとんどのアプリケーションは Deployment で管理</li>
</ul>
</li>
</ul>
</li>
<li>Secret
<ul>
<li>機密情報を保存・管理し、Pod から参照可能</li>
<li>主な使用方法としてコンテナの環境変数の設定
<ul>
<li>アプリケーションの DB のパスワードなどに使う</li>
</ul>
</li>
</ul>
</li>
<li>Service
<ul>
<li>pod の集合を抽象化して公開する
<ul>
<li>pod の集合に対する DNS 名</li>
<li>pod の集合に対する負荷分散</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div class=pagination>
<div class=pagination__buttons>
<span class="button previous">
<a href=/diary/tags/kubernetes/>
<span class=button__icon>←</span>
<span class=button__text>最近の日記</span>
</a>
</span>
</div>
</div>
</div>
</div>
<footer class=footer>
<div class=footer__inner>
<div class="copyright copyright--user">
<span>© 2021 Tetsuya Morimoto</span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span>
</div>
</div>
</footer>
<script src=/diary/assets/main.js></script>
<script src=/diary/assets/prism.js></script>
</div>
</body>
</html>