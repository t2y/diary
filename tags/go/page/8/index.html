<!doctype html><html lang=en><head><title>go :: forest nook</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=/diary/tags/go/><link rel=stylesheet href=/diary/styles.css><link rel=stylesheet href=/diary/style.css><link rel="shortcut icon" href=/diary/favicon.ico><meta name=twitter:card content="summary"><meta name=twitter:site content="t2y"><meta name=twitter:creator content><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:title" content="go"><meta property="og:description" content><meta property="og:url" content="/diary/tags/go/"><meta property="og:site_name" content="forest nook"><meta property="og:image" content="/diary/favicon.ico"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><link href=/diary/tags/go/index.xml rel=alternate type=application/rss+xml title="forest nook"></head><body class=green><div class="container full headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/diary><div class=logo>forest nook</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/diary/about>自己紹介</a></li><li><a href=/diary/dates>月別一覧</a></li><li><a href=/diary/tags>タグ一覧</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/diary/about>自己紹介</a></li><li><a href=/diary/dates>月別一覧</a></li><li><a href=/diary/tags>タグ一覧</a></li></ul></nav></header><div class=content><div class=posts><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2023/0601/>わかりにくさと能動的</a></h1><div class=post-meta><time class=post-date>2023-06-01 (Thu.) ::</time></div><span class=post-tags>#<a href=/diary/tags/ldap/>ldap</a>&nbsp;
#<a href=/diary/tags/go/>go</a>&nbsp;
#<a href=/diary/tags/noh/>noh</a>&nbsp;
#<a href=/diary/tags/book/>book</a>&nbsp;
#<a href=/diary/tags/communication/>communication</a>&nbsp;</span><div class=post-content><p>22時に寝て何度か起きて7時に起きた。たまには早く寝てみた。</p><h2 id=チャンネルを用いた-ldap-検索の-api>チャンネルを用いた ldap 検索の api</h2><p>うちらの要件に足りない機能が go-ldap にある。私が機能拡張についての issue を作ったときにある開発者が先にこの機能が必要だとコメントしてくれた。もともと draft pr で実装されたコードがあったのでそれをベースに検証したら普通に動いた。あとは go のエンジニアリングとして開発者が使いやすいように、私の経験からのアレンジを加えて pr とした。テストも実装した。なにか問題があればレビューで指摘さえしてくれれば私がすぐ修正してマージできるはずと考えている。はてさて、どうなることやら。</p><ul><li><a href=https://github.com/go-ldap/ldap/pull/440>Add search with channels with context #440</a></li></ul><h2 id=能650年続いた仕掛けとは>能―650年続いた仕掛けとは―</h2><p><a href=https://www.shinchosha.co.jp/book/610732/>能―650年続いた仕掛けとは―</a> を読んでいる続き。世阿弥の紹介をしている第五章に感化された。</p><h3 id=第四章-能にはこんな仕掛けが隠されていた>第四章 能にはこんな仕掛けが隠されていた</h3><p>能はシテ (主役) の役柄や内容で5種類にわけられる。</p><ol><li>初番目物 神: 神様が登場して颯爽 (さっそう) と舞う</li><li>二番目物 男: 修羅物とも呼ばれ、武将が修羅道に落ちた苦しみを描く</li><li>三番目物 女: 鬘物 (かずらもの) とも呼ばれ、優雅な美しいものが多い</li><li>四番目物 狂: 雑能とも呼ばれ、他の4つに分類されないもの</li><li>五番目物 鬼: 切能 (きりのう) とも呼ばれ、鬼や妖怪、精霊、霊獣などがシテになる</li></ol><p>さらにこの5つの分類に入らない翁という演目もある。翁を最初に置き、この順番に上演しながら、能と能の間に狂言を演じ、最後に祝言の短い能を演じるのがかつての正式な上演だったらしい。これだけ演じると朝から晩までかかってしまうので忙しい現代ではなかなかみれなくなってしまっているという。</p><p>ひと昔前は結婚式で仲人さんや親戚が謡を謡っていたという。たしかに古風な結婚式ではそうだったような、、、と私もうっすらとそういう記憶があるような気もする。</p><p>能の身体的な特徴の1つに摺り足がある。摺り足には重い二本の刀を腰に差して腰痛にならないという効能があるらしい。ほんとかな？</p><p>世阿弥が能の構造は序破急にせよと書いている。序はワキの登場、破はシテが登場して話をして去る、急は再びシテが姿を変えて登場するといった構造になる。水戸黄門や暴れん坊将軍のような時代劇の最後の展開が急に相当する。水戸黄門で例えると次になる。</p><ul><li>序: 現状把握と善人の窮状</li><li>破: 善人が騙される／襲われる</li><li>急: 印籠を出す</li></ul><p>そして、この後に書いてあることが個人的におもしろかった。水戸黄門は番組開始時点では印籠を出すようなシーンはなくて、当初は助さん角さんが敵をたたき斬っていただけだったという。そもそも印籠を出したぐらいで本物の水戸黄門かどうか分かるわけもなく悪人がひれ伏すはずがないw あるときから印籠を出すという急を作って、序破急が安定したことで人気が出て長寿番組となったと書いてある。ほんとかな？</p><h3 id=第五章-世阿弥はこんなにすごかった>第五章 世阿弥はこんなにすごかった</h3><p>能の大成に大きな影響を及ぼした世阿弥についていろいろ書いてある。</p><p><a href=https://db2.the-noh.com/jdic/2010/02/post_172.html>夢幻能</a> という能のジャンルを完成させた。念が残る、思いが残っているといった残念を昇華させる物語の構造になっている。世阿弥は特に敗者の無念をみせる舞台構造を作ることに成功したという。もともと日本人は死者を尊ぶ習慣があったことも要因としてあげている。</p><p>世阿弥は世襲で継いでいくという家元制度を作った。これは後世に必ず継ぐシステムを作ったと言える。現代まで能が継続されている背景の1つに家元制度はたしかにあげられると私も思う。しかし、現代では基本的人権 (職業選択の自由) に反することから家元制度の批判もあるようだ。著者はこの仕組みを称賛しているが、私は現代の感覚からすると個人の自由を制限して成り立っている古い制度のように感じてあまり著者の意見に同意できなかった。</p><blockquote><p>陰陽の和するところの境を成就とは知るべし</p></blockquote><p>昼や晴れた日には観客の気分が盛り上がり過ぎているので控え目に演じなさい。曇りや雨の日には逆に観客の気持ちが萎えているので派手目に演じなさいといったことを言っている。要は客の状態を見て演じ方を変えなさいと言っている。これは言うは易し、行うは難しだという。能ではこれを楽器の構造から音の力で解決していると説明がある。</p><blockquote><p>時に用ゆるをもて花と知るべし</p></blockquote><p>ともすれば絶対的な善し悪しがあるように思い込み、そのようなものを追求しがちであるが、実際はそのようなものはない。あるのは時との関係性だけだという。易経の時中も引用している。いまがどのような「時」であるかを知り、それがもっとも適合した時期であるか、行動できるか、それこそが「花」であるという。</p><blockquote><p>花と面白きと珍しきと、これ三つは同じ心なり</p></blockquote><p>現代の言葉とはちょっと意味が異なる。</p><ul><li>面白き: 目の前がパッと明るくなること</li><li>珍しき (愛ず): 愛らしいこと、まったく普通のことに感嘆を抱かせる工夫など</li><li>花: 秘すれば花、秘密にすることで偉大な働きをすること</li></ul><p>能では、演者はあまり観客に働きかけない。よくわからないことで、逆に観る人が能動的になり、見えないものが見え、聞こえない音が聞こえるようになる。これも秘することによって咲く花だという。師匠が弟子に教えないというのも、簡単なことでも秘することで、弟子が散々苦しみ抜いた上でその助言の価値に気付くこともあるという。</p><p>「老後の初心」という考え方。どの歳になっても初心はあるが、歳をとって体力が劣っていくからこそやることも変えていく。第一章にも出てきた能における「初心」という言葉の概念は本当におもしろい。能では体が動かなくなっていくのだから「しないというやり方も方法としてありえる」と考える。演じないことで演じる、歳を取ったときの表現方法がある。高齢な能楽師でしか演じられない境地があるから能楽師は歳を取ることを楽しみにする。この考え方はいまの時代にとてもあうように私は思えた。</p></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2023/0529/>エラーのラップと型階層</a></h1><div class=post-meta><time class=post-date>2023-05-29 (Mon.) ::</time></div><span class=post-tags>#<a href=/diary/tags/go/>go</a>&nbsp;
#<a href=/diary/tags/design/>design</a>&nbsp;
#<a href=/diary/tags/founding/>founding</a>&nbsp;</span><div class=post-content><p>0時に寝て何度か起きて7時に起きた。署名・押印を完了した相続の書類を朝一で郵便局へ言って送付した。これで後は弁護士さんや司法書士さんが残りの手続きをやっておいてくれるのかな？少し気が楽になった。</p><h2 id=ラップしたエラーのチェック>ラップしたエラーのチェック</h2><p>java でいうところの <a href=https://docs.oracle.com/javase/tutorial/essential/exceptions/chained.html>Chained Exceptions</a> を go では <a href=https://go.dev/blog/go1.13-errors>Wrap</a> という概念で表現する。Unwrap する interface を提供することで事実上の Chained Exceptions と同じようにオリジナルのエラーを辿ることができる。<a href=/diary/posts/2023/0527/#go-の学び直し>go はオブジェクト指向言語ではない</a> と先日の勉強会でも念押し確認してエラーの型階層という概念はないが、Wrap をみていると型階層の方が自然じゃない？と考えられなくもない。言語の設計を考えるよいお題だと思えた。</p><p>エラーチェックについては次の記事がわかりやすかった。</p><ul><li><a href=https://zenn.dev/msksgm/articles/20220325-unwrap-errors-is-as>Go の自作エラーを errors.Is と errors.As で wrap 元のエラーと識別するときには、Unwrap も実装しよう</a></li></ul><p>カスタムのエラーを定義する。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>MyError</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>message</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>err</span>     <span style=color:#66d9ef>error</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>e</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>MyError</span>) <span style=color:#a6e22e>Error</span>() <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>message</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;: &#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>err</span>.<span style=color:#a6e22e>Error</span>()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>e</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>MyError</span>) <span style=color:#a6e22e>Unwrap</span>() <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>このチェックのために <a href=https://pkg.go.dev/errors>errors</a> パッケージに次の2つの関数がある。</p><ul><li>errors.Is: エラーのインスタンスが同じかどうか</li><li>errors.As: エラーの型に代入可能かどうか (事実上はインスタンスの型が同じかどうか？)</li></ul><p>たしかにこれでもすぐに実装できた。型階層なんかなくてもこれで十分でしょというのが go の意見かな。</p><h2 id=隔週の雑談>隔週の雑談</h2><p>顧問のはらさんと隔週の打ち合わせ。今日の議題はこれら。</p><ul><li><a href=/diary/posts/2023/0522/#サイトデザイン打ち合わせ>サイトデザインの話し</a></li><li>能をみにいく話し</li><li><a href=/diary/posts/2023/0526/#開発合宿の日程確定>冬の開発合宿の話し</a></li></ul><p>週末は勉強会と実家に帰るので余裕がなかったのであまりネタがなかった。能の話しをしていて、子どものときに関心がなかったものを大人になって受け取り方が変わるものがあるのはなぜか？という話題で雑談した。はらさんも落語がわかるようになったという話しをされていた。この話しはストレッチのトレーナーさんとも盛り上がった。</p><blockquote><p>子どもだともっている情報が少な過ぎて情報を理解できないのではないか？</p></blockquote><p>情報や知識を蓄積することで対象への解像度があがるにつれて、みる視点が変わったり、興味が変わったりすることはあるかもしれないなと聞いていて思えた。課題管理の話しをしても、多くの開発者は無関心だったり共感を得られなかったりするが、そこにも通じるものがあるのかもしれないとなにかしらの取っ掛かりになるかもしれないと思えた。</p></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2023/0527/>go のジェネリクスと型の集合</a></h1><div class=post-meta><time class=post-date>2023-05-27 (Sat.) ::</time></div><span class=post-tags>#<a href=/diary/tags/life/>life</a>&nbsp;
#<a href=/diary/tags/go/>go</a>&nbsp;
#<a href=/diary/tags/design/>design</a>&nbsp;
#<a href=/diary/tags/programming/>programming</a>&nbsp;</span><div class=post-content><p>0時に寝て何度か起きて7時に起きた。22時頃に素麺を食べたら夜に吐き気がして食べるんじゃなかった。</p><h2 id=ストレッチ>ストレッチ</h2><p>今週はいつも通りの普通の1週間を過ごした感じ。休養していたわけでもなく負荷が高かったわけでもない。私の感覚的には右太もも後ろの筋と右腰の張りが強かった。トレーナーさん的には腰は大丈夫そうに言っていて、股関節全体の硬さは常態化しているものだけど、すねの筋もやや張りがあったように話していた。私の感覚とトレーナーさんの感覚がちょっとズレていた。今日の開脚幅は開始前154cmで、ストレッチ後158cmだった。一時期の3-4月の疲弊した状態ではないので一番悪い時期は脱したようにもみえる。</p><h2 id=go-の学び直し>go の学び直し</h2><p><a href=https://tenntenn.connpass.com/event/282717/>Gopher塾 #5 - ジェネリクスが書けるようになろう</a> に参加した。</p><p>すでにうちのプロダクトはジェネリクスを使った開発を行ってはいるけれど、私自身まだ曖昧なところがあったり、どういった設計がよいのかの手探り状態である。go はオブジェクト指向言語ではない (それ自体は構わない) ところが java のジェネリクスとは異なっていて、なにがその根本的な違いになっているのかを、私の中ではまだ理解できていなかった。その答えがこの勉強会に出てわかった気がする。もう少し独学して理論的に理解する必要はあるが、私に足りなかった知識が参加前よりも明確になったのでこの後の学習は容易に思える。</p><p>イベントではワークシートに自分で理解したメモや課題の回答を書き出すよう tenntenn さんが促していた。私はメモを自社の課題管理システムに書いていたのでワークシートには書いていないが、自分の理解を書き出すことの重要性は同意できる。tenntenn さんは次のように説明していた。</p><blockquote><p>概念や理解したことを自分の言葉で表現できるか？を確認するために書くことは大事。</p><p>もし書いた内容が間違っていても、間違ったことを認識できることにも意味がある。</p><p>つまり、学んだことを書くことは正しくても間違っていても得られるものがある。</p></blockquote><p>この考え方は私が提唱する課題管理にも通じている。なぜ書くかの理由の1つは自分の理解を整理するためでもある。そして、その文章を外部から監視できることで上長が助言できる。私にとっては習慣として身に付いた事柄ではあるけれど、改めてこういうことをチームのメンバーに啓蒙したり、開発ガイドに書いておくとよいように思えた。go の勉強会に参加して課題管理で学ぶことがあるとは思わなかった。よいこと尽くめだ。</p><p>閑話休題。本題のジェネリクスについて3割ぐらい知らないことがあった。私が java のジェネリクスと比べて go のジェネリクスを完全に理解できていなかったところの要因は <a href=https://go.dev/blog/intro-generics>型の集合 (Type sets)</a> の概念を理解できていなかったところに起因する。go ではジェネリクスを導入するにあたってインターフェースに型の集合という概念を導入した。それまでのインターフェースはメソッドの集合を管理するだけだったが、型の集合も管理できるようになった。また go には <a href=https://go.dev/ref/spec#Underlying_types>Underlying types</a> という概念が当初から存在したが、それを意識してプログラミングすることはなかった。これを日本語にすると「基底型」となるが、オブジェクト指向言語で言うところの基底型とはまったく異なる。なにせ継承できないのだから。インターフェースに型の集合として次の記述ができるようになった。Underlying types はこれまで概念としてしか存在していなかったのがチルダを用いた文法で表現できるようになったため、その理解も強いられるようになった。</p><p><a href=https://zenn.dev/nobishii/articles/99a2b55e2d3e50>Go の &ldquo;Type Sets&rdquo; proposal を読む</a> によると、現時点での型の集合とは次の2つを指す。</p><ul><li>~T approximation element (近似要素)</li><li>T | U union element (合併要素)</li></ul><p>union 型のようなものは他言語でもある概念なのでイメージしやすいが、Underlying types をチルダを使って指定するのは go 独自？の概念なので新たに学び直す必要がある。</p></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2023/0522/>初めてのコントリビュート経験</a></h1><div class=post-meta><time class=post-date>2023-05-22 (Mon.) ::</time></div><span class=post-tags>#<a href=/diary/tags/go/>go</a>&nbsp;
#<a href=/diary/tags/ldap/>ldap</a>&nbsp;
#<a href=/diary/tags/web-design/>web design</a>&nbsp;</span><div class=post-content><p>4時過ぎに寝て7時に起きた。3時前まで相続手続きの書類作業して帰ってきてから本を読んでたら寝るのが遅くなった。</p><h2 id=メンバーの-oss-へのコントリビュート>メンバーの oss へのコントリビュート</h2><p>チームのメンバーがプロダクトで使っているライブラリにコントリビュートした。土日にライブラリのメンテナーからコメントがあって、その指摘にもすぐに対応して日曜日にマージされていた。ライブラリ側のレビューもすぐに終わってすごくうまくいったと言える。</p><ul><li><a href=https://github.com/go-ldap/ldap/pull/436>feat: enable DirSync control in search operation #436</a></li></ul><p>もともとうちらが欲しい機能を作りかけた pr があったものの、作業途中でマージされずにクローズされていた。その残骸を参考にうちらの要件を満たせるかどうかの調査から始めた。調査を進めているうちにうちらの要件には足りない機能があってそれを拡張するようにも指示していた。すぐに出来たというのでライブラリにコントリビュートするように私が指示していた。</p><p>その後メンバーに聞いてみると、oss のライブラリにコントリビュートしたのは今回が初めてだという。開発者なら初めて oss にコントリビュートしたときのことを覚えているだろうか？私は、、、何だったか覚えてないが、おそらく linux distributor で働いているときに簡単なパッチを送った気がする。昔はメールや課題管理システムにパッチを投稿していたのが、いまは pr で気軽にパッチを送れる。若いメンバーがうまくコントリビュート経験を積めたことの背景に github がもたらしたパッチを送る簡単さがあるようにも思えた。oss にコントリビュートする機会は普通に oss を使って開発していればいくらでもある。マネージャーがその機会を見逃さず、ちゃんとメンバーにアサインしてあげることの大事さもあると思う。メンバーにはこの成功体験を活かして今後とも活躍してほしい。</p><h2 id=サイトデザイン打ち合わせ>サイトデザイン打ち合わせ</h2><p>先日の <a href=/diary/posts/2023/0508/#ワイヤーフレームのレビュー>ワイヤーフレームのレビュー</a> の続き。顧問のはらさんとデザイナーさんと私の3人でデザイン案をみながらレビュー会をした。素人の私からみたら十分によいものが出来つつあるように思えるのでデザイナーさんのモチベーションを削がないようにサポートできればと思う。はらさんはデザインの専門家なので細かいところの確認や気付きをあげていてさすがという印象。きっとデザイナーさんのモチベーションも上がるのではないかと推測する。私はこれまでデザインの打ち合わせに出たことがなかったので参考になることが多々ある。サイトのトップは普通は会社の紹介があるものらしいけど、私がそれはいらないとデザイナーさんに伝えたのでトップで会社紹介を一切しない稀な構成のサイトのデザインが出来上がった。その後、社名ぐらいあった方がよいのではないかという話しもあってこれから変えるかもしれない。私の会社情報を書かない理由は次になる。</p><ul><li>一見さんの訪問客がみるようなサイト (会社) ではない</li><li>知人やうちの会社の関係者がみて近況を手早く分かるようにしたい</li><li>デザインはシンプルな構成にしたい</li></ul></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2023/0515/>goleak と context によるキャンセル制御</a></h1><div class=post-meta><time class=post-date>2023-05-15 (Mon.) ::</time></div><span class=post-tags>#<a href=/diary/tags/rabbitmq/>rabbitmq</a>&nbsp;
#<a href=/diary/tags/go/>go</a>&nbsp;</span><div class=post-content><p>0時に寝て何度か起きて7時に起きた。いつもなら日曜日は徹夜して翌日の早朝に出掛けるのが月曜日は行かなくて済むのでちょっと楽になった。</p><h2 id=amqp091-go-の-context-制御>amqp091-go の context 制御</h2><p>goroutine リークを検出するツールに <a href=https://github.com/uber-go/goleak>uber-go/goleak</a> がある。ずっと前から余裕のあるときに結合テストの導入しようという issue を作っていたものの、適当なタイミングがなかった。先週末に少し手が空いたので着手した。goleak は個別のテストメソッドにも TestMain にも両方に対応している。結合テストの TestMain に入れた方が保守コストが下がるのでそういった用途がよいのではないかと思う。</p><p>go の TestMain がこういうものかもしれないが、defer 文を使う終了処理があるとそのコードを直接 TestMain には実装できない。関数で wrap して m.Run() を実行した結果を返すようにしないといけない。そこに goleak を入れる場合、goleak.Cleanup を何もしない関数に置き換えて m.Run() の結果を返せばよいのではないかと思う。そして VerifyTestMain() は m.Run() を実行してからすぐに goroutine が動いていないかをチェックする。ここで結合テストを動かすための、環境構築のために http サーバーを goroutine で起動するとか、テストのための goroutine が動いているとそれも検出してしまうのでそれらの goroutine は無視できるよう、2つのオプションが用意されている。</p><ul><li>IgnoreTopFunction: 明示的に無視してよい goroutine のトップ関数を指定する</li><li>IgnoreCurrent: オプションを登録した時点で稼働している goroutine を無視する</li></ul><p>これらを踏まえて TestMain で goleak を使うと次のようなコードになった。しかし、おそらくこの使い方はあまりよくない。いくつか goroutine を無視する設定を追加したために、そこに意図しない goroutine リークが隠蔽されてしまう懸念がある。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>(<span style=color:#a6e22e>m</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>M</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>myTearDown</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>code</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>goleak</span>.<span style=color:#a6e22e>VerifyTestMain</span>(
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>m</span>,
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>goleak</span>.<span style=color:#a6e22e>Cleanup</span>(<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>exitCode</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;skip goleak cleanup&#34;</span>, <span style=color:#a6e22e>exitCode</span>)
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>code</span> = <span style=color:#a6e22e>exitCode</span>
</span></span><span style=display:flex><span>		}),
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>goleak</span>.<span style=color:#a6e22e>IgnoreTopFunction</span>(<span style=color:#e6db74>&#34;net/http.(*persistConn).readLoop&#34;</span>),
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>goleak</span>.<span style=color:#a6e22e>IgnoreTopFunction</span>(<span style=color:#e6db74>&#34;net/http.(*persistConn).writeLoop&#34;</span>),
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>goleak</span>.<span style=color:#a6e22e>IgnoreTopFunction</span>(<span style=color:#e6db74>&#34;internal/poll.runtime_pollWait&#34;</span>),
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>goleak</span>.<span style=color:#a6e22e>IgnoreCurrent</span>(),
</span></span><span style=display:flex><span>	)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>code</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TestMain</span>(<span style=color:#a6e22e>m</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>M</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Exit</span>(<span style=color:#a6e22e>main</span>(<span style=color:#a6e22e>m</span>))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>さらにこの調査をしているときに amqp091-go の api も context 受け取った方がシンプルでいいんじゃない？と思って提案の pr を送ってみた。context 使わなくても自前でキャンセルする api は提供されているため、開発者の考え方によってこの提案を拒否するのも妥当な判断だと思える。次のメジャーバージョンとか、互換性を維持しなくてよいタイミングから取り入れようという考え方もあるかもしれない。</p><ul><li><a href=https://github.com/rabbitmq/amqp091-go/pull/192>Add Channel.ConsumeWithContext to be able to cancel delivering #192</a></li></ul></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2023/0418/>unix crypt(3) をよくわかってなかった</a></h1><div class=post-meta><time class=post-date>2023-04-18 (Tue.) ::</time></div><span class=post-tags>#<a href=/diary/tags/auth/>auth</a>&nbsp;
#<a href=/diary/tags/go/>go</a>&nbsp;</span><div class=post-content><p>0時に寝て2回ほど起きて7時に起きた。わりと気分がよい方。</p><h2 id=unix-の-crypt3-というライブラリ実装>unix の crypt(3) というライブラリ実装</h2><p>google の Admin console の api の <a href="https://developers.google.com/admin-sdk/directory/reference/rest/v1/users?hl=ja">REST Resource: users</a> で <code>hashFunction</code> として crypt を選択してハッシュ化したパスワードを連携できる。</p><blockquote><p>crypt - C crypt ライブラリに準拠しています。DES、MD5（ハッシュ プレフィックス $1$）、SHA-256（ハッシュ プレフィックス $5$）、SHA-512（ハッシュ プレフィックス $6$）ハッシュ アルゴリズムをサポートします。</p></blockquote><p>この crypt というのは単純に sha256 や sha512 でハッシュ化すればよいわけではなく、歴史的経緯でそれぞれの os ごとにある crypt ライブラリの実装に依存しているらしい。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ man <span style=color:#ae81ff>3</span> crypt
</span></span></code></pre></div><p>おそらく google のドキュメントがいう C crypt ライブラリというのは glibc のことを指していると考えてよいと思うが、go の準標準パッケージである <a href=https://pkg.go.dev/golang.org/x/crypto>golang.org/x/crypto</a> を探してもその実装は存在しない。これも推測だが、仕様が曖昧なものを go の開発者は実装しようとしないのだと思う。とはいえ、c の crypt ライブラリをラップして go から使うのも面倒と言えば面倒なので誰かが crypt ライブラリを真似て野良実装して、それが一部で使われていたりするようにみえる。しかし、なぜかそのオリジナルを作った開発者はそのコードのリポジトリを削除していて、ソースコードのコピーがまわりまわって、いま <a href=https://github.com/GehirnInc/crypt>github.com/GehirnInc/crypt</a> で保守されているらしい。このライブラリを使ってエンコードすると c の crypt ライブラリの出力と一致することは確認できた。この実装をみれば、単純にエンコードすればよいといったものではないことが伺えるので pure go のライブラリとして共有されているのは有り難い。</p><p>このライブラリを使ってハッシュ化した文字列と c 言語のコードも chatgpt に書いてもらっていくつか一致することは検証できた。デバッグしていて、もう1つ salt を生成も特定の文字しか使えないのでうっかり乱数を使って文字列生成していると間違ってしまう。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>saltChars</span> = []byte(<span style=color:#e6db74>&#34;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789./&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>GenerateSalt</span>(<span style=color:#a6e22e>method</span> <span style=color:#a6e22e>Method</span>) []<span style=color:#66d9ef>byte</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>b</span> = make([]<span style=color:#66d9ef>byte</span>, <span style=color:#ae81ff>16</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>charsLength</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>saltChars</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>b</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>b</span>[<span style=color:#a6e22e>i</span>] = <span style=color:#a6e22e>saltChars</span>[<span style=color:#a6e22e>rand</span>.<span style=color:#a6e22e>Intn</span>(<span style=color:#a6e22e>charsLength</span>)]
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>salt</span> []<span style=color:#66d9ef>byte</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>method</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>SHA256</span>:
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>salt</span> = append([]byte(<span style=color:#e6db74>&#34;$5$&#34;</span>), <span style=color:#a6e22e>b</span><span style=color:#f92672>...</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>SHA512</span>:
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>salt</span> = append([]byte(<span style=color:#e6db74>&#34;$6$&#34;</span>), <span style=color:#a6e22e>b</span><span style=color:#f92672>...</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>default</span>:
</span></span><span style=display:flex><span>		panic(<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Sprintf</span>(<span style=color:#e6db74>&#34;unsupported salt method: %s&#34;</span>, <span style=color:#a6e22e>method</span>))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>salt</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>ここで生成した salt を使って github.com/GehirnInc/crypt を使うとこんな感じで crypt を使って google のユーザーアカウント連携ができる。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Crypt</span>(<span style=color:#a6e22e>password</span>, <span style=color:#a6e22e>salt</span> []<span style=color:#66d9ef>byte</span>) (<span style=color:#66d9ef>string</span>, <span style=color:#66d9ef>error</span>) {                              
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>salt</span>) &lt; <span style=color:#ae81ff>3</span> {                                                           
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;&#34;</span>, <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;invalid salt: %s&#34;</span>, string(<span style=color:#a6e22e>salt</span>))                  
</span></span><span style=display:flex><span>    }                                                                            
</span></span><span style=display:flex><span>                                                                                 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>crypter</span> <span style=color:#a6e22e>crypt</span>.<span style=color:#a6e22e>Crypter</span>                                                    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>switch</span> string(<span style=color:#a6e22e>salt</span>[<span style=color:#ae81ff>0</span>:<span style=color:#ae81ff>3</span>]) {                                                   
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#34;$5$&#34;</span>:                                                                  
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>crypter</span> = <span style=color:#a6e22e>crypt</span>.<span style=color:#a6e22e>SHA256</span>.<span style=color:#a6e22e>New</span>()                                             
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#34;$6$&#34;</span>:                                                                  
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>crypter</span> = <span style=color:#a6e22e>crypt</span>.<span style=color:#a6e22e>SHA512</span>.<span style=color:#a6e22e>New</span>()                                             
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>default</span>:                                                                     
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;&#34;</span>, <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;unsupported salt prefix: %s&#34;</span>, string(<span style=color:#a6e22e>salt</span>[<span style=color:#ae81ff>0</span>:<span style=color:#ae81ff>3</span>]))  
</span></span><span style=display:flex><span>    }                                                                            
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>hashed</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>crypter</span>.<span style=color:#a6e22e>Generate</span>(<span style=color:#a6e22e>password</span>, <span style=color:#a6e22e>salt</span>)                                
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>crypter</span>.<span style=color:#a6e22e>Verify</span>(<span style=color:#a6e22e>hashed</span>, <span style=color:#a6e22e>password</span>)                                      
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>hashed</span>, <span style=color:#a6e22e>err</span>                                                           
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>ハッシュ化した文字列が正しいかどうかは実際に google にログインしてみないと判別できないのでわりとデバッグや検証に時間がかかった。</p><h3 id=リファレンス>リファレンス</h3><ul><li><a href=https://blog.amedama.jp/entry/unix-crypt-3>色々な Unix 系 OS の crypt(3) について調べたら面白かった話</a></li><li><a href=https://yosida95.com/2015/07/25/120000.html>/etc/shadow などで使われるハッシュ関数、 crypt(3) を Go 言語で実装しました</a></li></ul></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2023/0410/>サーバーサイド開発とセマフォ</a></h1><div class=post-meta><time class=post-date>2023-04-10 (Mon.) ::</time></div><span class=post-tags>#<a href=/diary/tags/go/>go</a>&nbsp;
#<a href=/diary/tags/rabbitmq/>rabbitmq</a>&nbsp;</span><div class=post-content><p>0時に寝て7時に起きた。</p><h2 id=web-api-サーバーへの負荷テスト>web api サーバーへの負荷テスト</h2><p>web api サーバーへ数百から数千件の同時リクエストを送ってエラーが発生しないことを確認する。チームのメンバーがテストを実施していたら producer がメッセージを送信するときに rabbitmq との接続エラーがいくつか発生した。いくつか対応方法を考えられるが、既存のコードを大きく変更せず解決するものとしてセマフォを導入してみた。自分で作っても難しいものではないが、<a href=https://pkg.go.dev/golang.org/x/sync/semaphore>golang.org/x/sync/semaphore</a> で準標準パッケージとして提供されている。次のように簡単に使える。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>sem</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>semaphore</span>.<span style=color:#a6e22e>NewWeighted</span>(<span style=color:#a6e22e>maxConcurrentSessions</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Background</span>()
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sem</span>.<span style=color:#a6e22e>Acquire</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#ae81ff>1</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>sem</span>.<span style=color:#a6e22e>Release</span>(<span style=color:#ae81ff>1</span>)
</span></span></code></pre></div><p>これで rabbitmq との同時接続数を制御する。rabbitmq 側もどのぐらいの接続を受け付けるかは <a href=https://www.rabbitmq.com/networking.html>Networking and RabbitMQ</a> を参照して設定で制御できる。デフォルトは 128 となっているので 1024 ぐらいまで増やしてみた。</p><p>サーバーサイド開発のおもしろさの1つとしてボトルネックは移動するという概念がある。必ずどこかにニーポイント (ボトルネック) は現れるので意図したパフォーマンスや負荷を耐えるようにリソース制限をしてサーバーが堅牢になるよう調整する。この手の作業はサーバーサイドエンジニアをやってきた私の得意とするところ。</p></div></article><div class=pagination><div class=pagination__buttons><a href=/diary/tags/go/page/7/ class="button previous"><span class=button__icon>←</span>
<span class=button__text>最近の日記</span></a>
<a href=/diary/tags/go/page/9/ class="button next"><span class=button__text>過去の日記</span>
<span class=button__icon>→</span></a></div></div></div></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>© 2021 Tetsuya Morimoto</span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script type=text/javascript src=/diary/bundle.min.js></script></div></body></html>