<!doctype html><html lang=en><head><title>container :: forest nook</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=/diary/tags/container/><link rel=stylesheet href=/diary/styles.css><link rel=stylesheet href=/diary/style.css><link rel="shortcut icon" href=/diary/favicon.ico><meta name=twitter:card content="summary"><meta name=twitter:site content="t2y"><meta name=twitter:creator content><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:title" content="container"><meta property="og:description" content><meta property="og:url" content="/diary/tags/container/"><meta property="og:site_name" content="forest nook"><meta property="og:image" content="/diary/favicon.ico"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><link href=/diary/tags/container/index.xml rel=alternate type=application/rss+xml title="forest nook"></head><body class=green><div class="container full headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/diary><div class=logo>forest nook</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/diary/about>自己紹介</a></li><li><a href=/diary/dates>月別一覧</a></li><li><a href=/diary/tags>タグ一覧</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/diary/about>自己紹介</a></li><li><a href=/diary/dates>月別一覧</a></li><li><a href=/diary/tags>タグ一覧</a></li></ul></nav></header><div class=content><div class=posts><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2023/1211/>owner/permission の違うファイルとリポジトリ管理</a></h1><div class=post-meta><time class=post-date>2023-12-11 (Mon.) ::</time></div><span class=post-tags>#<a href=/diary/tags/mongodb/>mongodb</a>&nbsp;
#<a href=/diary/tags/infrastructure/>infrastructure</a>&nbsp;
#<a href=/diary/tags/container/>container</a>&nbsp;
#<a href=/diary/tags/event/>event</a>&nbsp;
#<a href=/diary/tags/blog/>blog</a>&nbsp;</span><div class=post-content><p>23時に寝て2時に起きて6時に起きて7時過ぎに起きた。なんか微妙な寝方をした。</p><p>先日の <a href=/diary/posts/2023/1207/>mongodb のレプリカセットの調査</a> の整理をしてマージリクエストを作成した。共通鍵の keyFile をどう扱えばいいのか、わからなくて、一旦コンテナ内の tmp 領域にコピーして、それを entrypoint スクリプトでコピーしてから owner/permission を変更するというやり方で、リポジトリ管理で共有しやすいようにしてみた。entrypoint スクリプトは root 権限で実行されることも理解した。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>volumes</span>:
</span></span><span style=display:flex><span>  - <span style=color:#ae81ff>./mongo/keyfile:/var/tmp/keyfile.orig</span>
</span></span><span style=display:flex><span><span style=color:#f92672>command</span>:
</span></span><span style=display:flex><span>  - <span style=color:#ae81ff>mongod</span>
</span></span><span style=display:flex><span>  - --<span style=color:#ae81ff>keyFile</span>
</span></span><span style=display:flex><span>  - <span style=color:#ae81ff>/data/keyfile</span>
</span></span><span style=display:flex><span>  - --<span style=color:#ae81ff>replSet</span>
</span></span><span style=display:flex><span>  - <span style=color:#e6db74>&#34;myrs&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>entrypoint</span>:
</span></span><span style=display:flex><span>  - <span style=color:#ae81ff>bash</span>
</span></span><span style=display:flex><span>  - -<span style=color:#ae81ff>c</span>
</span></span><span style=display:flex><span>  - |<span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    if [[ ! -f /data/keyfile ]]; then
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      cp /var/tmp/keyfile.orig /data/keyfile
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      chmod 400 /data/keyfile
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      chown mongodb:mongodb /data/keyfile
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    fi
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    exec docker-entrypoint.sh $$@</span>    
</span></span></code></pre></div><h2 id=テックブログを読む会>テックブログを読む会</h2><p>昨日、西原さんに教えてもらった <a href=/diary/posts/2023/1210/>テックブログを読むイベント</a> を探したら毎週月曜日に行われているようだった。早速 <a href=https://blogreading.connpass.com/event/304979/>テックブログ一気読み選手権20231211杯</a> に参加した。HackMD で <a href=https://hackmd.io/kefgM317StqiBSCF7kWPDA>読んだメモ</a> を管理している。記事を選択して、読んで、所感をまとめて、他の人たちと共有する。ただそれだけのイベント。ちょうど30分で終わって、自分の勉強にもなったし、他の人の話しも聞いて参考になった。たった30分でも、なにもやらないよりずっとよい。1ヶ月ほど参加してやり方を学んだらチームにも展開してみようかと考えている。</p></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2023/1207/>mongodb のレプリカセットのデプロイ調査</a></h1><div class=post-meta><time class=post-date>2023-12-07 (Thu.) ::</time></div><span class=post-tags>#<a href=/diary/tags/mongodb/>mongodb</a>&nbsp;
#<a href=/diary/tags/infrastructure/>infrastructure</a>&nbsp;
#<a href=/diary/tags/container/>container</a>&nbsp;
#<a href=/diary/tags/go/>go</a>&nbsp;
#<a href=/diary/tags/testing/>testing</a>&nbsp;</span><div class=post-content><p>4時前に寝て6時半に起きた。1時過ぎまで作業して、帰って少しゲームして、うまく眠れなくてだらだらしていた。</p><h2 id=mongodb-のレプリカセットの調査>mongodb のレプリカセットの調査</h2><p>以前 <a href=/diary/posts/2023/1101/#mongo-とトランザクションとレプリカセット>mongodb でトランザクションを使うときにレプリカセットが必要</a> なことがわかった。他機能の開発途中だったので一旦後回しにしていたものを回収している。状況によってはメンバーに委譲してもよかったんだけど、私が遊撃で出張ってみることにした。実際に調べてみてコンテナの運用も考慮するとけっこう難しいことがわかってきた。</p><p><a href=https://www.mongodb.com/docs/mongodb-shell/>mongosh</a> からは <a href=https://www.mongodb.com/docs/v7.0/reference/method/js-replication/>Replication Methods</a> を使ってレプリカセットの操作ができる。これはユーティリティのようなもので mongodb としての低レベルのコマンド操作は <a href=https://www.mongodb.com/docs/manual/reference/command/nav-replication/>Replication Commands</a> になる。<a href=https://github.com/mongodb/mongo-go-driver>mongo-go-driver</a> はレプリカセット向けのユーティリティを提供していないため、Replication Commands を RunCommand() の低レベル API を使って自分で実装しないといけない。</p><p>例えば、レプリカセットの初期化をするときは次のように <code>replSetInitiate</code> というコマンドを適切なパラメーターで呼び出す。あまりドキュメントで丁寧に説明されていないので試行錯誤でエラーメッセージをみながら実装することになる。とくにはまるのが mongod のサーバーは <code>--replSet myrs</code> のようにレプリカセットを指定して起動させるものの、初期化コマンドを実行するときはまだレプリカセットを設定していないため、レプリカセットを指定せず、且つ <code>direct</code> パラメーターをセットしないと mongod サーバーに接続できない。この微妙な設定を把握するのにはまった。これが正しい手順かどうかもわからないが、ググったりしているとフォーラムでそういったコメントが散見されたりする。おそらく mongosh の Replication Methods を使うと、クライアントからサーバー接続は裏方でよしなにやってくれるのでそっちの方が簡単ではある。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>ReplicaSet</span>) <span style=color:#a6e22e>Initiate</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>config</span> <span style=color:#a6e22e>bson</span>.<span style=color:#a6e22e>M</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>client</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>connectDirect</span>(<span style=color:#a6e22e>ctx</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;failed to connect with direct: %w&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>client</span>.<span style=color:#a6e22e>Disconnect</span>(<span style=color:#a6e22e>ctx</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>result</span> <span style=color:#a6e22e>bson</span>.<span style=color:#a6e22e>M</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>cmd</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bson</span>.<span style=color:#a6e22e>D</span>{{<span style=color:#a6e22e>Key</span>: <span style=color:#e6db74>&#34;replSetInitiate&#34;</span>, <span style=color:#a6e22e>Value</span>: <span style=color:#a6e22e>config</span>}}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>client</span>.<span style=color:#a6e22e>Database</span>(<span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>db</span>).<span style=color:#a6e22e>RunCommand</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>cmd</span>).<span style=color:#a6e22e>Decode</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>result</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;failed to run replSetInitiate(): %w&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>PrettyPrint</span>(<span style=color:#e6db74>&#34;completed to initiate&#34;</span>, <span style=color:#a6e22e>result</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>ReplicaSet</span>) <span style=color:#a6e22e>connectDirect</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>mongo</span>.<span style=color:#a6e22e>Client</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>opts</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>options</span>.<span style=color:#a6e22e>Client</span>().
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>SetAuth</span>(<span style=color:#a6e22e>options</span>.<span style=color:#a6e22e>Credential</span>{
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>Username</span>: <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>User</span>,
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>Password</span>: <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>Passwd</span>.<span style=color:#a6e22e>String</span>(),
</span></span><span style=display:flex><span>		}).
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>SetHosts</span>(<span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>Hosts</span>).
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>SetDirect</span>(<span style=color:#66d9ef>true</span>) <span style=color:#75715e>// must be true
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>mongo</span>.<span style=color:#a6e22e>Connect</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>opts</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>InitSingleReplicaSet</span>(
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>cfg</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>MongoDB</span>,
</span></span><span style=display:flex><span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>rs</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>NewReplicaSet</span>(<span style=color:#a6e22e>cfg</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>initConfig</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bson</span>.<span style=color:#a6e22e>M</span>{
</span></span><span style=display:flex><span>		<span style=color:#e6db74>&#34;_id&#34;</span>: <span style=color:#a6e22e>cfg</span>.<span style=color:#a6e22e>ReplicaSet</span>,
</span></span><span style=display:flex><span>		<span style=color:#e6db74>&#34;members&#34;</span>: []<span style=color:#a6e22e>bson</span>.<span style=color:#a6e22e>M</span>{
</span></span><span style=display:flex><span>			{<span style=color:#e6db74>&#34;_id&#34;</span>: <span style=color:#ae81ff>0</span>, <span style=color:#e6db74>&#34;host&#34;</span>: <span style=color:#e6db74>&#34;localhost:27017&#34;</span>},
</span></span><span style=display:flex><span>		},
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>rs</span>.<span style=color:#a6e22e>Initiate</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>initConfig</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>さらに mongod サーバーを起動するときに <code>--replSet</code> と <code>--keyFile</code> (認証が必要な場合のみ？) という2つのパラメーターを指定する必要がある。<code>--replSet</code> はレプリカセットの識別子を指定する。そして <code>--keyFile</code> は共通鍵を指定する。この共通鍵を生成するには次のようにする。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ openssl rand -base64 <span style=color:#ae81ff>756</span> &gt; my-mongo-keyfile
</span></span><span style=display:flex><span>$ chown mongodb:mongodb my-mongo-keyfile
</span></span><span style=display:flex><span>$ chmod <span style=color:#ae81ff>400</span> my-mongo-keyfile
</span></span></code></pre></div><p>普通のサーバーインスタンスならすぐできることだが、コンテナの運用において面倒なのが owner とパーミッションを設定しないといけないところ。mongo のコンテナは mongodb ユーザーで起動するため、root でマウントされたファイルシステムには書き込みできなかったりして keyFile の配置をどう扱えばよいのかが難しい。docker hub の mongo の issues でもどうやって設定したらいいの？って議論が発散している。mongo 本体が公式のスクリプトや仕組みを提供していれば済む話しだけど、どうもそうではないみたい。だから泥臭い方法で自分でなんとかしないといけないようにみえる。</p><ul><li><a href=https://github.com/docker-library/mongo/issues/246>Creating a mongo image set with &ndash;replSet #246</a></li><li><a href=https://github.com/docker-library/mongo/issues/339>Cannot configure replica sets with entrypoint-initdb #339</a></li></ul><p>dockertest でもレプリカセットの設定について次の issue として登録されている。mongo のコンテナを使ったテストの場合、dockertest のレイヤーが挟まるのでさらにわかりにくくなっている。テストを動かすためにどういった設定が必要かは把握できたのでなにかよい方法を考えてコントリビュートしたい。</p><ul><li><a href=https://github.com/ory/dockertest/issues/480>Create an example for starting mongodb as a replica set #480</a></li></ul></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2023/1002/>インフラの式年遷宮</a></h1><div class=post-meta><time class=post-date>2023-10-02 (Mon.) ::</time></div><span class=post-tags>#<a href=/diary/tags/container/>container</a>&nbsp;
#<a href=/diary/tags/docker/>docker</a>&nbsp;
#<a href=/diary/tags/infrastructure/>infrastructure</a>&nbsp;</span><div class=post-content><p>1時に寝て何度か起きて5時に起きた。それからだらだらして寝てまた7時に起きた。</p><h2 id=テスト環境の再整備と-rootless-コンテナ>テスト環境の再整備と rootless コンテナ</h2><p>インフラの式年遷宮のようなことをしていて、テスト環境をリファクタリングして再整備していた。これまで root でコンテナを実行していたが、最近は rootless コンテナがセキュリティ強化の観点から望ましいということで次のドキュメントをみながら設定した。</p><ul><li><a href=https://docs.docker.com/engine/install/linux-postinstall/>Linux post-installation steps for Docker Engine</a></li></ul><p>設定はとくに難しくないが、dockerd や containerd の起動を systemd のユーザーインスタンスに依存することになる。systemd のユーザーインスタンスは基本的にユーザーがログインしたときに生成されるものなので OS が再起動したときなどに困る。OS 再起動時にも systemd のユーザーインスタンスを生成するには linger という仕組みを有効にすればよいらしい。systemd &ndash;user の扱いと linger のことまで理解していれば、たぶん大丈夫なのかな？これで運用がうまくいくことを祈りたい。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ sudo loginctl enable-linger ucidm
</span></span></code></pre></div></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2023/0829/>コンテナー間のデータ通信と named pipe</a></h1><div class=post-meta><time class=post-date>2023-08-29 (Tue.) ::</time></div><span class=post-tags>#<a href=/diary/tags/container/>container</a>&nbsp;
#<a href=/diary/tags/linux/>linux</a>&nbsp;
#<a href=/diary/tags/go/>go</a>&nbsp;</span><div class=post-content><p>22時頃から寝ていて2回起きて3時に起き出して、4時までネットみたりしていて、また寝て6時に起きた。生活のリズムがおかしい。</p><h2 id=コンテナー間のデータのやり取り>コンテナー間のデータのやり取り</h2><p>昨日 <a href=/diary/posts/2023/0828/>モジュール分割</a> したことにより、いままで1つのモジュールで管理していたが、モジュールを分割したのでそれぞれのバージョンを取得できるとよいという話題が出た。コンテナー内にアプリケーションのバイナリがあり、バイナリを実行するとバージョン情報を取得できる。それぞれのモジュールは独立したコンテナで動いてるため、コンテナー間でその情報を受け渡す方法が必要になる。ググってみると次の so がヒットして named pipe がプラクティスだという。</p><ul><li><a href=https://stackoverflow.com/questions/32163955/how-to-run-shell-script-on-host-from-docker-container>How to run shell script on host from docker container?</a></li></ul><p>ホスト os 上の named pipe をコンテナーの volumes でマウントして、それぞれのコンテナーが読み書きすればよい。構築時に named pipe さえ作ったらコンテナー内での読み書きでデータ通信を実現できるため、シンプルでよいんじゃないかと思えた。</p><p>mypipe という named pipe を作る。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ mkfifo mypipe
</span></span></code></pre></div><p>読み込み用コンテナーのための read-Dockerfile を作る。tail コマンドで named pipe を読む。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ vi read-Dockerfile
</span></span><span style=display:flex><span>From bash:latest
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ENTRYPOINT <span style=color:#f92672>[</span> <span style=color:#e6db74>&#34;tail&#34;</span>, <span style=color:#e6db74>&#34;-f&#34;</span>, <span style=color:#e6db74>&#34;/app/mypipe&#34;</span> <span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>$ docker build -t mypipe-read:latest -f read-Dockerfile .
</span></span></code></pre></div><p>named pipe をマウントして読み込み用コンテナーを起動する。</p><pre tabindex=0><code>$ docker run --rm --mount type=bind,source=&#34;$(pwd)&#34;/mypipe,target=/app/mypipe,readonly mypipe-read
</code></pre><p>書き込み用のエントリーポイントのスクリプトはちょっと工夫がいる。おそらく Dockerfile 内で直接リダイレクトの操作ができない (やり方がわからなかった) 。シェルスクリプトを呼び出す形にして、シェルスクリプト内部でリダイレクトにより、named pipe に書き込みする。</p><p>エントリーポイントのスクリプトは次のような感じ。<code>eval "$@"</code> で任意のコード実行できるようにちょっと細工。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ vi myentrypoint.sh
</span></span><span style=display:flex><span><span style=color:#75715e>#!/bin/sh</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cleanup<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    echo <span style=color:#e6db74>&#34;cleanup ...&#34;</span>
</span></span><span style=display:flex><span>    exit <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>trap cleanup INT TERM
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> true
</span></span><span style=display:flex><span><span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>    echo <span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>$(</span>date<span style=color:#66d9ef>)</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>    eval <span style=color:#e6db74>&#34;</span>$@<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>    sleep <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>done</span>
</span></span></code></pre></div><p>書き込み用コンテナーのための write-Dockerfile を作る。先の myentrypoint.sh を <code>ENTRYPOINT</code> として起動させる。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ vi write-Dockerfile
</span></span><span style=display:flex><span>From bash:latest
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>COPY myentrypoint.sh /app/
</span></span><span style=display:flex><span>RUN chmod +x /app/myentrypoint.sh
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ENTRYPOINT <span style=color:#f92672>[</span> <span style=color:#e6db74>&#34;/app/myentrypoint.sh&#34;</span> <span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>$ docker build -t mypipe-write:latest -f write-Dockerfile .
</span></span></code></pre></div><p>適当に乱数を生成する cli を eval 実行させる。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ docker run --rm --mount type<span style=color:#f92672>=</span>bind,source<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>$(</span>pwd<span style=color:#66d9ef>)</span><span style=color:#e6db74>&#34;</span>/mypipe,target<span style=color:#f92672>=</span>/app/mypipe mypipe-write <span style=color:#e6db74>&#34;tr -dc 0-9 &lt; /dev/urandom | fold -w 8 | head -1  &gt; /app/mypipe&#34;</span>
</span></span></code></pre></div><p>読み込み用コンテナーで乱数を表示できるはず。</p><p>なにも難しくなく、linux の標準の機能を使ってコンテナー間のデータ通信を実現できたことにちょっと驚いた。</p><p>go で named pipe を読むときは linux ならば <code>syscall.O_NONBLOCK</code> を指定することで書き込みしていなくてもブロックせずに読める。値を取得できない可能性はあるけど、それが許される要件ならこれで済む。またテックブログにまとめたい。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>readNamedPipe</span>(<span style=color:#a6e22e>path</span> <span style=color:#66d9ef>string</span>) ([]<span style=color:#66d9ef>byte</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>flag</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>O_RDONLY</span> | <span style=color:#a6e22e>syscall</span>.<span style=color:#a6e22e>O_NONBLOCK</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>pipe</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>OpenFile</span>(<span style=color:#a6e22e>path</span>, <span style=color:#a6e22e>flag</span>, <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>ModeNamedPipe</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;failed to open path: %w&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>pipe</span>.<span style=color:#a6e22e>Close</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>reader</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bufio</span>.<span style=color:#a6e22e>NewReader</span>(<span style=color:#a6e22e>pipe</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>b</span>, <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reader</span>.<span style=color:#a6e22e>ReadLine</span>()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;failed to read line: %w&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>b</span>, <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2023/0519/>issue を作るとストレスが軽減する</a></h1><div class=post-meta><time class=post-date>2023-05-19 (Fri.) ::</time></div><span class=post-tags>#<a href=/diary/tags/issue-management/>issue management</a>&nbsp;
#<a href=/diary/tags/writing/>writing</a>&nbsp;
#<a href=/diary/tags/container/>container</a>&nbsp;</span><div class=post-content><p>お酒飲んで新幹線乗ったせいか、新幹線の中であまり寝られなくて暑くていつもより移動に疲れた。その後1時に寝て何度か起きて7時に起きた。2日酔いではないが、寝起きの気分はよくなかった。</p><h2 id=issue-を作ることによるストレス軽減>issue を作ることによるストレス軽減</h2><p>昨日の打ち合わせのメモから議事録を作ったり、そこから新しい issue を作ったりしながら来週の打ち合わせの資料作りをしていた。資料を作っている途中、割り込みでメンバーのコードレビューが入ったりして、あまり資料作りは進捗しなかった。</p><p>打ち合わせした内容から issue を作る作業を、私は好きだったりする。何をやってよいかわからない状況というのは苦しい。issue を作ること、要件を言語化したり、背景を調べたり、他の issue との関連付けしたり、そういった手を動かすことがきっかけになって、その issue を明確化していく作業を積み重ねれば時間の経過とともに課題が解決するということを経験的に理解しているからだ。</p><p>大雑把に言えば、私にとって、issue さえ作れればその課題解決は優先順位付けと (解決までの) 時間の問題に置き換えられる。あれやらなきゃ、これもやらなきゃ、なにか抜け・漏れがあるんじゃないかと頭の中でもやもやしているものを issue という概念に変換することで考えなくて済むようになっていく過程がストレスを軽減している気もする。</p><h2 id=コンテナ勉強会>コンテナ勉強会</h2><p><a href=/diary/posts/2023/0516/#テックブログ公開>先日公開したテックブログ</a> とプラスアルファで勉強会をした。コンテナという汎用的な話題だったので CTO から社内向けにアナウンスされて (半業務命令っぽい雰囲気で) いつもより参加者は多かったように思える。10人前後は参加されていた。40分ぐらいで話し終えて20分ほど雑談の時間をとって盛り上がりは微妙だったけど、いくつか意見や質問が出たのでよかったのではないかと思う。</p><p>チームのメンバーが発表するときは私がモデレーターの役割をしている。私が発表するときはモデレーター兼発表者になってしまう。モデレーターと発表者を兼任するのはとても難しい。おそらく脳の集中力を向ける先が異なるからではないかと思う。モデレーターは質問者の質問を広げたり、コミュニケーションがうまくいくように手伝ったりする。回答から次の質問を考えたりもする。一方で発表者は自分の調べたことや伝えたいことを聴衆にわかりやすく伝えることのみに注力する。</p><p>モデレーターと発表者が同じになってしまうと、自分の説明のどこが伝わっていないのか、質問者の意図を組むにはどうすればいいかといったモデレーターの視点がなくなってしまう。以前 <a href=/diary/posts/2023/0401/#個人カンファレンス>tenntenn さんの個人カンファレンス</a> に参加したときに1人2役でパネルディスカッションをされていて、そのときに同僚からあまりやり過ぎると人格崩壊するから気をつけた方よいといった忠告を受けたと冗談で話されていた意味が理解できた。役者が他人になりきるように、これは兼任じゃなくて1人で2つの人格を演じないといけない。そんな器用なことはそうそうできない。</p></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2023/0517/>出張の中日</a></h1><div class=post-meta><time class=post-date>2023-05-17 (Wed.) ::</time></div><span class=post-tags>#<a href=/diary/tags/event/>event</a>&nbsp;
#<a href=/diary/tags/container/>container</a>&nbsp;
#<a href=/diary/tags/book/>book</a>&nbsp;
#<a href=/diary/tags/workcation/>workcation</a>&nbsp;</span><div class=post-content><p>0時に寝て何度か起きて5時半に起きてテレビで朝のニュースを聞き流しながら7時に起きた。</p><h2 id=資料作成>資料作成</h2><p>今日はメンバーの1人が休暇だったため、打ち合わせはなしで資料ばかり作っていた。今週のチーム勉強会の発表は私が担当するのでその資料を作ったり、リリースを終えて社内向けにプロダクトの説明のための資料を準備したりしていた。これまでたくさんの資料を作ってきてるので改めて作るというよりは、過去に作ったものを洗練させたり、集めてきて補足する程度の作業になりそうな雰囲気だけわかってきた。</p><h2 id=aws-app-runner-の情報収集>aws app runner の情報収集</h2><p><a href=https://aws-startup-community.connpass.com/event/282015/>App Runner Night !!</a> にオンラインで参加した。<a href=https://aws-startup-community.connpass.com/>AWS Startup Community</a> というコミュニティがあることも知らなかった。顧問のはらさんが LT 発表すると聞いていたのでそれをみようと思ってながらで聞いていたので他の発表はあまりちゃんとみていてない。特別に目新しいことはなかったし、発表の中でもいくつかちょっとそこ怪しいんじゃない？とか思いながら他の作業をしていた。</p><p>私も余裕があれば app runner でサービスを動かしてみてその勘所を把握しておきたい。ecs がやりたいことに比べて使いにくいという印象は私もずっと思っていた。実質 k8s 以外のコンテナプラットフォームは aws しかないので app runner がよいものかどうかに関心をもっている。</p><h2 id=コワーキングのオンラインイベント>コワーキングのオンラインイベント</h2><p>月例のカフーツさんのオンラインイベントに参加した。<a href=/diary/posts/2023/0419/#コワーキングのオンラインイベント>先月の所感はここ</a> 。今日は「移動」というテーマでいつも通りいとうさんがわーっと話をしていた。この2ヶ月に新しい官民の取り組みが始まったらしい。なんか空気だけでダメそうにみえる。</p><ul><li><a href=https://www.mlit.go.jp/kankocho/workation-bleisure/news/230218/>「テレワーク・ワーケーション官民推進協議会」を設立しました！</a></li></ul><p>このサイトでは次の2つの用語を定義している。ブレジャーを初めて知ったけど、発音しにくくて語呂が悪いだろとか思えた。</p><ul><li>ワーケーション (Work + Vacation)</li><li>ブレジャー (Business + Leisure)</li></ul><p>このサイトにあるワーケーションの実施形態には共感するところもあって次の4つに分類している。IT 業界で多いのは合宿型とサテライトオフィス型かな。</p><ul><li>福利厚生型</li><li>地域課題解決型</li><li>合宿型</li><li>サテライトオフィス型</li></ul><p>あとどういう文脈だったか忘れてしまったが、<a href=https://www.shunjusha.co.jp/book/9784393436400.html>身体感覚で「芭蕉」を読みなおす。 『おくのほそ道』謎解きの旅</a> という本を紹介された。能の探求者が書いた独特の視点から松尾芭蕉を取り上げた本らしくて、なんかおもしろそうにみえたのですぐに購入してみた。紙の文庫本しかなかった。読んでみる。</p></div></article><div class=pagination><div class=pagination__buttons></div></div></div></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>© 2021 Tetsuya Morimoto</span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script type=text/javascript src=/diary/bundle.min.js></script></div></body></html>