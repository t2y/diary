<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Container on forest nook</title><link>/diary/tags/container/</link><description>Recent content in Container on forest nook</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>© 2021 Tetsuya Morimoto</copyright><lastBuildDate>Fri, 15 Dec 2023 08:34:04 +0900</lastBuildDate><atom:icon>/diary/favicon.ico</atom:icon><icon>/diary/favicon.ico</icon><atom:link href="/diary/tags/container/index.xml" rel="self" type="application/rss+xml"/><item><title>おいしい 🦀 を食べに行く</title><link>/diary/posts/2023/1215/</link><pubDate>Fri, 15 Dec 2023 08:34:04 +0900</pubDate><guid>/diary/posts/2023/1215/</guid><description>22時頃に寝てしまって1時に起きて5時に起きて6時過ぎに起きた。とくになにもしていないのにバテている気がする。今週はずっと mongodb のレプリカセットの調査やインフラの移行作業などをやっていたせいか、普段よりもエネルギーを消費しているのかもしれない。朝から疲労困憊でオフィスへ向かった。
docker のコンテナネットワークの調査 docker のコンテナネットワークから解決できる名前がなになのか、よくわかってなくて、その調査のためにサンプルの compose サービスを作った。
https://github.com/t2y/docker-compose-sample myimage から nginx のコンテナの名前解決がどうなるかを試してみる。
c67a5ca94a77:/app# dig +short 00c719491558 192.168.240.3 c67a5ca94a77:/app# dig +short mynginx 192.168.240.3 c67a5ca94a77:/app# dig +short nginx 192.168.240.3 c67a5ca94a77:/app# dig +short yournginx 192.168.240.3 基本的にはサービス名、コンテナ名 (container_name)、コンテナー ID、ホスト名 (hostname) はすべて名前解決できる。hostname があるときはそのコンテナの /etc/hosts にその名前が追加され、ないときはコンテナ ID が追加されていた。
yourcontainer:/app# cat /etc/hosts 127.0.0.1 localhost ... 172.18.0.3 yourcontainer 冬の開発合宿の準備 日程を決めたのが5月末 で、うちの会社のワークスペースに slack のチャンネルを開設したのが10月。現時点で7人の参加者がいる。もうこのメンバーでいいかなと考えている。今回はコミュニティのワーケーションイベントというより、自社の開発合宿という体をとっている。スポンサーとしていくらか会社からお金も出す。その理由の1つは slack チャンネルにログを残したいという意図がある。コミュニティの slack だとフリープランになるので3ヶ月以上過去のログがみえなくなってしまう。それを解消するには自社の有料プランの slack チャンネルに置いておくのがもっともログを制御できて嬉しい。
城崎温泉では11月から 🦀 が解禁となって、今年は冬に行くので 🦀 を食べるというのも目的の1つ。チャンネルで盛り上げようと、たまに城崎温泉の記事を貼り付けたりしていた。そろそろ、メンバーと顔合わせの情報共有の打ち合わせをしようと思って調整さんを作った。他の人たちは、わざわざうちの slack のワークスペースにゲスト参加しているから、あまり無理強いをせずに情報共有できるようにしておきたい。たった1つの、ほとんどやり取りしないチャンネルのために slack のワークスペースをオープンしておかないといけないという用途はなかなか面倒だ。私が逆の立場でもそう思う。どうにか普段使っているワークスペースから、必要なときだけ連携できるような仕組みがないだろうか？</description><content>&lt;p>22時頃に寝てしまって1時に起きて5時に起きて6時過ぎに起きた。とくになにもしていないのにバテている気がする。今週はずっと mongodb のレプリカセットの調査やインフラの移行作業などをやっていたせいか、普段よりもエネルギーを消費しているのかもしれない。朝から疲労困憊でオフィスへ向かった。&lt;/p>
&lt;h2 id="docker-のコンテナネットワークの調査">docker のコンテナネットワークの調査&lt;/h2>
&lt;p>docker のコンテナネットワークから解決できる名前がなになのか、よくわかってなくて、その調査のためにサンプルの compose サービスを作った。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/t2y/docker-compose-sample">https://github.com/t2y/docker-compose-sample&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>myimage から nginx のコンテナの名前解決がどうなるかを試してみる。&lt;/p>
&lt;pre tabindex="0">&lt;code>c67a5ca94a77:/app# dig +short 00c719491558
192.168.240.3
c67a5ca94a77:/app# dig +short mynginx
192.168.240.3
c67a5ca94a77:/app# dig +short nginx
192.168.240.3
c67a5ca94a77:/app# dig +short yournginx
192.168.240.3
&lt;/code>&lt;/pre>&lt;p>基本的にはサービス名、コンテナ名 (container_name)、コンテナー ID、ホスト名 (hostname) はすべて名前解決できる。hostname があるときはそのコンテナの /etc/hosts にその名前が追加され、ないときはコンテナ ID が追加されていた。&lt;/p>
&lt;pre tabindex="0">&lt;code>yourcontainer:/app# cat /etc/hosts
127.0.0.1 localhost
...
172.18.0.3 yourcontainer
&lt;/code>&lt;/pre>&lt;h2 id="冬の開発合宿の準備">冬の開発合宿の準備&lt;/h2>
&lt;p>&lt;a href="/diary/diary/posts/2023/0526/#開発合宿の日程確定">日程を決めたのが5月末&lt;/a> で、うちの会社のワークスペースに slack のチャンネルを開設したのが10月。現時点で7人の参加者がいる。もうこのメンバーでいいかなと考えている。今回はコミュニティのワーケーションイベントというより、自社の開発合宿という体をとっている。スポンサーとしていくらか会社からお金も出す。その理由の1つは slack チャンネルにログを残したいという意図がある。コミュニティの slack だとフリープランになるので3ヶ月以上過去のログがみえなくなってしまう。それを解消するには自社の有料プランの slack チャンネルに置いておくのがもっともログを制御できて嬉しい。&lt;/p>
&lt;p>城崎温泉では11月から 🦀 が解禁となって、今年は冬に行くので 🦀 を食べるというのも目的の1つ。チャンネルで盛り上げようと、たまに城崎温泉の記事を貼り付けたりしていた。そろそろ、メンバーと顔合わせの情報共有の打ち合わせをしようと思って調整さんを作った。他の人たちは、わざわざうちの slack のワークスペースにゲスト参加しているから、あまり無理強いをせずに情報共有できるようにしておきたい。たった1つの、ほとんどやり取りしないチャンネルのために slack のワークスペースをオープンしておかないといけないという用途はなかなか面倒だ。私が逆の立場でもそう思う。どうにか普段使っているワークスペースから、必要なときだけ連携できるような仕組みがないだろうか？&lt;/p>
&lt;p>年末・年始の情報共有の打ち合わせへ向けて旅のしおりも準備していく。日々の業務に忙殺されて後回しにしがちなので自分を追い込むためにも予定を入れた。&lt;/p></content></item><item><title>コンテナイメージの移行</title><link>/diary/posts/2023/1214/</link><pubDate>Thu, 14 Dec 2023 08:32:58 +0900</pubDate><guid>/diary/posts/2023/1214/</guid><description>1時に寝て3時に起きて6時半に起きた。スマホで呪術廻戦のゲームを開いたまま寝てた。
サードパーティの mongodb コンテナへの移行 昨日の mongodb のサードパーティのコンテナイメージ調査 の続き。
レプリカセットの削除 基本的に一度作ったレプリカセットを削除することはないせいか、レプリカセットを削除するユーティリティは提供されていない。なんらかの理由でレプリカセットを再作成したいときは、レプリカセットの設定が保存されている local database を削除する。
またレプリカセットの稼働中に local database を削除することはできないため、mongod サーバーを --replSet を指定していない状態で起動させ、そのときに次のようにして local database を削除できる。
test&amp;gt; use admin admin&amp;gt; db.grantRolesToUser(&amp;#34;root&amp;#34;, [&amp;#34;__system&amp;#34;]); { ok: 1 } admin&amp;gt; use local switched to db local local&amp;gt; db.dropDatabase() { ok: 1, dropped: &amp;#39;local&amp;#39; } local&amp;gt; use admin switched to db admin admin&amp;gt; db.revokeRolesFromUser(&amp;#34;root&amp;#34;, [&amp;#34;__system&amp;#34;]); { ok: 1 } コンテナを使ったレプリカセットの初期設定 bitnami/mongodb を使うと、ローカルのシングルノードでレプリカセットを使うには次のような設定になる。
mongo: image: docker.io/bitnami/mongodb:7.0.1 user: root # デフォルトは非 root ユーザーで起動するのでローカルの開発環境なら root で実行した方が手間がない volumes: - .</description><content>&lt;p>1時に寝て3時に起きて6時半に起きた。スマホで呪術廻戦のゲームを開いたまま寝てた。&lt;/p>
&lt;h2 id="サードパーティの-mongodb-コンテナへの移行">サードパーティの mongodb コンテナへの移行&lt;/h2>
&lt;p>昨日の &lt;a href="/diary/diary/posts/2023/1211/">mongodb のサードパーティのコンテナイメージ調査&lt;/a> の続き。&lt;/p>
&lt;h3 id="レプリカセットの削除">レプリカセットの削除&lt;/h3>
&lt;p>基本的に一度作ったレプリカセットを削除することはないせいか、レプリカセットを削除するユーティリティは提供されていない。なんらかの理由でレプリカセットを再作成したいときは、レプリカセットの設定が保存されている local database を削除する。&lt;/p>
&lt;p>またレプリカセットの稼働中に local database を削除することはできないため、mongod サーバーを &lt;code>--replSet&lt;/code> を指定していない状態で起動させ、そのときに次のようにして local database を削除できる。&lt;/p>
&lt;pre tabindex="0">&lt;code>test&amp;gt; use admin
admin&amp;gt; db.grantRolesToUser(&amp;#34;root&amp;#34;, [&amp;#34;__system&amp;#34;]);
{ ok: 1 }
admin&amp;gt; use local
switched to db local
local&amp;gt; db.dropDatabase()
{ ok: 1, dropped: &amp;#39;local&amp;#39; }
local&amp;gt; use admin
switched to db admin
admin&amp;gt; db.revokeRolesFromUser(&amp;#34;root&amp;#34;, [&amp;#34;__system&amp;#34;]);
{ ok: 1 }
&lt;/code>&lt;/pre>&lt;h3 id="コンテナを使ったレプリカセットの初期設定">コンテナを使ったレプリカセットの初期設定&lt;/h3>
&lt;p>&lt;a href="https://hub.docker.com/r/bitnami/mongodb">bitnami/mongodb&lt;/a> を使うと、ローカルのシングルノードでレプリカセットを使うには次のような設定になる。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">mongo&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">image&lt;/span>: &lt;span style="color:#ae81ff">docker.io/bitnami/mongodb:7.0.1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">user&lt;/span>: &lt;span style="color:#ae81ff">root &lt;/span> &lt;span style="color:#75715e"># デフォルトは非 root ユーザーで起動するのでローカルの開発環境なら root で実行した方が手間がない&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">volumes&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">./volumes/mongodb:/bitnami/mongodb&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">environment&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">MONGODB_ROOT_USER&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;${MONGO_USER}&amp;#34;&lt;/span> &lt;span style="color:#75715e"># 認証ユーザー&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">MONGODB_ROOT_PASSWORD&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;${MONGO_PASSWORD}&amp;#34;&lt;/span> &lt;span style="color:#75715e"># 認証ユーザーのパスワード&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">MONGODB_ADVERTISED_HOSTNAME&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;mongo-primary&amp;#34;&lt;/span> &lt;span style="color:#75715e"># レプリカセットのノードを ip アドレスではなくホスト名で指定する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">MONGODB_REPLICA_SET_NAME&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;myrs&amp;#34;&lt;/span> &lt;span style="color:#75715e"># レプリカセットの名前&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">MONGODB_REPLICA_SET_MODE&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;primary&amp;#34;&lt;/span> &lt;span style="color:#75715e"># プライマリノードとして設定&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">MONGODB_REPLICA_SET_KEY&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;my/replication/common/key123&amp;#34;&lt;/span> &lt;span style="color:#75715e"># キーファイルのコンテンツ (base64 でデコードできる値)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">MONGODB_SYSTEM_LOG_VERBOSITY&lt;/span>: &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#75715e"># ログレベル&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">hostname&lt;/span>: &lt;span style="color:#ae81ff">mongo-primary &lt;/span> &lt;span style="color:#75715e"># コンテナの内外から解決できるホスト名を指定&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">container_name&lt;/span>: &lt;span style="color:#ae81ff">mongo &lt;/span> &lt;span style="color:#75715e"># コンテナ名 (docker container ls で表示される名前)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">ports&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">27017&lt;/span>:&lt;span style="color:#ae81ff">27017&lt;/span> &lt;span style="color:#75715e"># レプリカセットを運用する場合はポート番号のマッピングを一致させる必要がある&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">restart&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;always&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この設定でレプリカセットを初期した場合、レプリカセットの initialize 処理は、次のような config/member をもつ。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">members&lt;/span>&lt;span style="color:#f92672">:&lt;/span> [{ &lt;span style="color:#a6e22e">_id&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#a6e22e">host&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;mongo-primary:27017&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">priority&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span> }]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>コンテナの内部からは mongo-primary というホスト名に対して、コンテナネットワーク内のローカル ip アドレスが解決される。&lt;/p>
&lt;pre tabindex="0">&lt;code>c67a5ca94a77:/app# dig +short mongo-primary
192.168.240.3
&lt;/code>&lt;/pre>&lt;p>ここで host os 上のアプリケーションから mongo コンテナに対してレプリカセット接続をする場合 &lt;code>replicaSet=${レプリカセットの名前}&lt;/code> のパラメーターを追加する。&lt;/p>
&lt;pre tabindex="0">&lt;code>mongodb://root:password@localhost:27017/?authMechanism=DEFAULT&amp;amp;replicaSet=myrs
&lt;/code>&lt;/pre>&lt;p>これは localhost:27017 にレプリカセットの接続を試行し、接続できるとレプリカセットのメンバーが返される。&lt;/p>
&lt;p>レプリカセットのメンバーには &lt;code>mongo-primary:27017&lt;/code> という設定が行われているため、mongo-primary というホスト名に対して host os 上で名前解決できる必要がある。そのために /etc/hosts に次の設定を行う。&lt;/p>
&lt;pre tabindex="0">&lt;code>$ sudo vi /etc/hosts
...
127.0.0.1 mongo-primary
&lt;/code>&lt;/pre>&lt;p>&lt;a href="https://www.mongodb.com/products/tools/compass">compass&lt;/a> で接続した場合、レプリカセット接続であれば、レプリカセットの名前が接続情報として表示される。&lt;/p>
&lt;h2 id="ダイニングテーブル引き取り">ダイニングテーブル引き取り&lt;/h2>
&lt;p>実は火曜日にも長机を引き取りに行ってきて、今日はダイニングテーブルを引き取りに行ってきた。この3日間で2つもテーブルが手に入った。いつも目ぼしいと思ったものは、すぐに他の人と取り引きが成立してしまうのに、たまたま続けて私と取り引きが成立した。車で20分ぐらいの距離のマンションまで引き取りに行った。20時の予定を、19時10分には着いてしまって、先方も快く対応してくれた。私よりも見た目すこし年配の方で人当たりのよい感じの方だった。ジモティのやり取りはその人の性格が出るもので、受け渡しだけささっとやって余計な話しはしないパターンもあれば、愛想よく話しながら受け渡しをするパターンもある。先方によると、大事に使っていたテーブルのようにみえるので私も離れのオフィススペースで大事に使おうと思う。&lt;/p></content></item><item><title>mongodb のサードパーティのコンテナイメージ</title><link>/diary/posts/2023/1213/</link><pubDate>Wed, 13 Dec 2023 20:35:00 +0900</pubDate><guid>/diary/posts/2023/1213/</guid><description>23時に寝て3時に起きて寝たかどうか覚えていないうちに6時半になっていて7時半に起きた。
json を介した go の bool 値のバリエーション go-playground/validator のバリデータには required というバリデーションオプションがある。しかし、このオプションは go のゼロ値でないことをチェックするという仕様になっている。bool のゼロ値は false となるため、リクエストした JSON データに false を設定していたのか、未設定だったのかの違いを検出できない。これはバリデータの問題ではなく、go の json ライブラリの制約のようなもので使い勝手のよい仕様とは言えない。私もこの振る舞いに起因する不具合に遭遇したこともあるし、こういうときにどうしたらよいかも過去に3回ぐらいは調べている気がする。
How to validate bool #142 現時点での私の最適化は次のコードになる。データ構造として *bool 型にすれば、ポインタ型のゼロ値は nil となるため、true, false, nil の3値でバリデーションできる。しかし、私はこのデータ構造を好ましく思わない。というのは、内部的には true/false の2値でしか管理しないメンバーを、json のバリデーションのためだけに nil も許容する3値にすることがよい設計だと私は思えない。そこでバリデータによるバリデーションは諦めて、json の Unmarshal 処理をフックしてバリデーション相当の処理を自分で実装する。このやり方のデメリットはメンバーが追加されたときに自分で UnmarshalJSON() メソッドを保守する必要がある点になる。しかし、メリットとして内部のデータ構造の型は bool 型で扱える。一概にどちらがよいとは言いにくいかもしれないし、設計上の好みかもしれない。
type reqMyData struct { Name string `json:&amp;#34;name&amp;#34;` View *bool `json:&amp;#34;view&amp;#34;` } type MyData struct { Name string `json:&amp;#34;name&amp;#34;` View bool `json:&amp;#34;view&amp;#34;` } func (d *MyData) UnmarshalJSON(data []byte) error { var tmp reqMyData if err := json.</description><content>&lt;p>23時に寝て3時に起きて寝たかどうか覚えていないうちに6時半になっていて7時半に起きた。&lt;/p>
&lt;h2 id="json-を介した-go-の-bool-値のバリエーション">json を介した go の bool 値のバリエーション&lt;/h2>
&lt;p>&lt;a href="https://github.com/go-playground/validator">go-playground/validator&lt;/a> のバリデータには &lt;a href="https://pkg.go.dev/github.com/go-playground/validator/v10#hdr-Required">required&lt;/a> というバリデーションオプションがある。しかし、このオプションは go のゼロ値でないことをチェックするという仕様になっている。bool のゼロ値は false となるため、リクエストした JSON データに false を設定していたのか、未設定だったのかの違いを検出できない。これはバリデータの問題ではなく、go の json ライブラリの制約のようなもので使い勝手のよい仕様とは言えない。私もこの振る舞いに起因する不具合に遭遇したこともあるし、こういうときにどうしたらよいかも過去に3回ぐらいは調べている気がする。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/go-playground/validator/issues/142">How to validate bool #142&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>現時点での私の最適化は次のコードになる。データ構造として &lt;code>*bool&lt;/code> 型にすれば、ポインタ型のゼロ値は nil となるため、true, false, nil の3値でバリデーションできる。しかし、私はこのデータ構造を好ましく思わない。というのは、内部的には true/false の2値でしか管理しないメンバーを、json のバリデーションのためだけに nil も許容する3値にすることがよい設計だと私は思えない。そこでバリデータによるバリデーションは諦めて、json の Unmarshal 処理をフックしてバリデーション相当の処理を自分で実装する。このやり方のデメリットはメンバーが追加されたときに自分で UnmarshalJSON() メソッドを保守する必要がある点になる。しかし、メリットとして内部のデータ構造の型は &lt;code>bool&lt;/code> 型で扱える。一概にどちらがよいとは言いにくいかもしれないし、設計上の好みかもしれない。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">reqMyData&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Name&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#e6db74">`json:&amp;#34;name&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">View&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#e6db74">`json:&amp;#34;view&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">MyData&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Name&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#e6db74">`json:&amp;#34;name&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">View&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#e6db74">`json:&amp;#34;view&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">d&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">MyData&lt;/span>) &lt;span style="color:#a6e22e">UnmarshalJSON&lt;/span>(&lt;span style="color:#a6e22e">data&lt;/span> []&lt;span style="color:#66d9ef">byte&lt;/span>) &lt;span style="color:#66d9ef">error&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">tmp&lt;/span> &lt;span style="color:#a6e22e">reqMyData&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">json&lt;/span>.&lt;span style="color:#a6e22e">Unmarshal&lt;/span>(&lt;span style="color:#a6e22e">data&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">tmp&lt;/span>); &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Errorf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;failed to unmarshal as reqMyData&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">tmp&lt;/span>.&lt;span style="color:#a6e22e">View&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Errorf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;required view field&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">d&lt;/span>.&lt;span style="color:#a6e22e">Name&lt;/span> = &lt;span style="color:#a6e22e">tmp&lt;/span>.&lt;span style="color:#a6e22e">Name&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">d&lt;/span>.&lt;span style="color:#a6e22e">View&lt;/span> = &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">tmp&lt;/span>.&lt;span style="color:#a6e22e">View&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="サードパーティの-mongodb-コンテナイメージ">サードパーティの mongodb コンテナイメージ&lt;/h2>
&lt;p>先日の &lt;a href="/diary/diary/posts/2023/1211/">mongodb のレプリカセット調査&lt;/a> の続き。コードレビューをしていて &lt;a href="https://hub.docker.com/r/bitnami/mongodb">bitnami/mongodb&lt;/a> というサードパーティのコンテナイメージを使った方がよいのではないか？というコメントがあったのでその調査をしてみた。VMware 社が提供しているサードパーティのコンテナイメージらしい。&lt;/p>
&lt;blockquote>
&lt;p>MongoDB(R) is run and maintained by MongoDB, which is a completely separate project from Bitnami.&lt;/p>
&lt;/blockquote>
&lt;p>まず MongoDB プロジェクトとはまったく別管理であることが書いてある。&lt;/p>
&lt;blockquote>
&lt;p>Bitnami イメージを使用する理由&lt;/p>
&lt;ul>
&lt;li>Bitnamiはアップストリームソースの変更を綿密に追跡し、自動化されたシステムを使用してこのイメージの新しいバージョンを迅速に公開します。&lt;/li>
&lt;li>Bitnami イメージでは、最新のバグ修正と機能をできるだけ早く利用できます。&lt;/li>
&lt;li>Bitnamiのコンテナ、仮想マシン、クラウドイメージは、同じコンポーネントと構成アプローチを使用しているため、プロジェクトのニーズに応じて形式を簡単に切り替えることができます。&lt;/li>
&lt;li>Bitnamiのイメージはすべて、minideb（最小限のDebianベースのコンテナイメージ）またはscratch（明示的に空のイメージ）をベースにしています。&lt;/li>
&lt;li>Docker Hubで利用可能なすべてのBitnamiイメージは、Docker Content Trust（DCT）で署名されています。DOCKER_CONTENT_TRUST=1 を使用して、イメージの完全性を確認できます。&lt;/li>
&lt;li>Bitnamiコンテナイメージは定期的にリリースされ、最新のディストリビューションパッケージが利用可能です。&lt;/li>
&lt;/ul>
&lt;p>MongoDB®を本番環境で使用したいですか？Bitnami Application Catalogのエンタープライズ版であるVMware Tanzu Application Catalogをお試しください。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;a href="https://hub.docker.com/_/mongo">mongo&lt;/a> の公式イメージは ubuntu をベースイメージにしている。ubuntu よりは minideb の方が軽いのかな？そしてちゃんと upstream にも追随しているみたい。このベースイメージの違いによるものかは定かではないが、結合テストのイメージも移行してみたところ、10-20秒ほど結合テストの実行時間が速くなった。割合にすると10%程度かな。&lt;/p>
&lt;blockquote>
&lt;p>KubernetesにMongoDB®をデプロイするには？&lt;/p>
&lt;p>Bitnami アプリケーションを Helm Chart としてデプロイすることは、Kubernetes 上で当社のアプリケーションを使い始める最も簡単な方法です。インストールの詳細については、Bitnami MongoDB® Chart GitHub リポジトリを参照してください。&lt;/p>
&lt;p>Bitnami コンテナは、クラスタへの Helm Charts のデプロイと管理に Kubeapps と一緒に使用できます。&lt;/p>
&lt;/blockquote>
&lt;p>helm chart も提供しているようで、いずれクラウド版を作るときに MongoDB も k8s 上にデプロイする上でこのことは都合がよいように思える。&lt;/p>
&lt;p>レプリケーションを前提とした初期設定があり、entrypoint スクリプトもいくつか読んでみた感じだと、きれいに管理されていて保守もちゃんとやってくれそうにみえる。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/bitnami/containers/tree/main/bitnami/mongodb">https://github.com/bitnami/containers/tree/main/bitnami/mongodb&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>昨日、導入したばかりの公式イメージ + 自作スクリプトによるレプリケーション設定を廃止して、Bitnami のコンテナイメージを使うことに決めた。&lt;/p></content></item><item><title>owner/permission の違うファイルとリポジトリ管理</title><link>/diary/posts/2023/1211/</link><pubDate>Mon, 11 Dec 2023 09:37:23 +0900</pubDate><guid>/diary/posts/2023/1211/</guid><description>23時に寝て2時に起きて6時に起きて7時過ぎに起きた。なんか微妙な寝方をした。
先日の mongodb のレプリカセットの調査 の整理をしてマージリクエストを作成した。共通鍵の keyFile をどう扱えばいいのか、わからなくて、一旦コンテナ内の tmp 領域にコピーして、それを entrypoint スクリプトでコピーしてから owner/permission を変更するというやり方で、リポジトリ管理で共有しやすいようにしてみた。entrypoint スクリプトは root 権限で実行されることも理解した。
volumes: - ./mongo/keyfile:/var/tmp/keyfile.orig command: - mongod - --keyFile - /data/keyfile - --replSet - &amp;#34;myrs&amp;#34; entrypoint: - bash - -c - | if [[ ! -f /data/keyfile ]]; then cp /var/tmp/keyfile.orig /data/keyfile chmod 400 /data/keyfile chown mongodb:mongodb /data/keyfile fi exec docker-entrypoint.sh $$@ テックブログを読む会 昨日、西原さんに教えてもらった テックブログを読むイベント を探したら毎週月曜日に行われているようだった。早速 テックブログ一気読み選手権20231211杯 に参加した。HackMD で読んだメモを管理している。記事を選択して、読んで、所感をまとめて、他の人たちと共有する。ただそれだけのイベント。ちょうど30分で終わって、自分の勉強にもなったし、他の人の話しも聞いて参考になった。たった30分でも、なにもやらないよりずっとよい。1ヶ月ほど参加してやり方を学んだらチームにも展開してみようかと考えている。</description><content>&lt;p>23時に寝て2時に起きて6時に起きて7時過ぎに起きた。なんか微妙な寝方をした。&lt;/p>
&lt;p>先日の &lt;a href="/diary/diary/posts/2023/1207/">mongodb のレプリカセットの調査&lt;/a> の整理をしてマージリクエストを作成した。共通鍵の keyFile をどう扱えばいいのか、わからなくて、一旦コンテナ内の tmp 領域にコピーして、それを entrypoint スクリプトでコピーしてから owner/permission を変更するというやり方で、リポジトリ管理で共有しやすいようにしてみた。entrypoint スクリプトは root 権限で実行されることも理解した。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">volumes&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">./mongo/keyfile:/var/tmp/keyfile.orig&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">command&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">mongod&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - --&lt;span style="color:#ae81ff">keyFile&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">/data/keyfile&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - --&lt;span style="color:#ae81ff">replSet&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#34;myrs&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">entrypoint&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">bash&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - -&lt;span style="color:#ae81ff">c&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - |&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> if [[ ! -f /data/keyfile ]]; then
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> cp /var/tmp/keyfile.orig /data/keyfile
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> chmod 400 /data/keyfile
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> chown mongodb:mongodb /data/keyfile
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> fi
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> exec docker-entrypoint.sh $$@&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="テックブログを読む会">テックブログを読む会&lt;/h2>
&lt;p>昨日、西原さんに教えてもらった &lt;a href="/diary/diary/posts/2023/1210/">テックブログを読むイベント&lt;/a> を探したら毎週月曜日に行われているようだった。早速 &lt;a href="https://blogreading.connpass.com/event/304979/">テックブログ一気読み選手権20231211杯&lt;/a> に参加した。HackMD で読んだメモを管理している。記事を選択して、読んで、所感をまとめて、他の人たちと共有する。ただそれだけのイベント。ちょうど30分で終わって、自分の勉強にもなったし、他の人の話しも聞いて参考になった。たった30分でも、なにもやらないよりずっとよい。1ヶ月ほど参加してやり方を学んだらチームにも展開してみようかと考えている。&lt;/p></content></item><item><title>mongodb のレプリカセットのデプロイ調査</title><link>/diary/posts/2023/1207/</link><pubDate>Thu, 07 Dec 2023 09:26:50 +0900</pubDate><guid>/diary/posts/2023/1207/</guid><description>4時前に寝て6時半に起きた。1時過ぎまで作業して、帰って少しゲームして、うまく眠れなくてだらだらしていた。
mongodb のレプリカセットの調査 以前 mongodb でトランザクションを使うときにレプリカセットが必要 なことがわかった。他機能の開発途中だったので一旦後回しにしていたものを回収している。状況によってはメンバーに委譲してもよかったんだけど、私が遊撃で出張ってみることにした。実際に調べてみてコンテナの運用も考慮するとけっこう難しいことがわかってきた。
mongosh からは Replication Methods を使ってレプリカセットの操作ができる。これはユーティリティのようなもので mongodb としての低レベルのコマンド操作は Replication Commands になる。mongo-go-driver はレプリカセット向けのユーティリティを提供していないため、Replication Commands を RunCommand() の低レベル API を使って自分で実装しないといけない。
例えば、レプリカセットの初期化をするときは次のように replSetInitiate というコマンドを適切なパラメーターで呼び出す。あまりドキュメントで丁寧に説明されていないので試行錯誤でエラーメッセージをみながら実装することになる。とくにはまるのが mongod のサーバーは --replSet myrs のようにレプリカセットを指定して起動させるものの、初期化コマンドを実行するときはまだレプリカセットを設定していないため、レプリカセットを指定せず、且つ direct パラメーターをセットしないと mongod サーバーに接続できない。この微妙な設定を把握するのにはまった。これが正しい手順かどうかもわからないが、ググったりしているとフォーラムでそういったコメントが散見されたりする。おそらく mongosh の Replication Methods を使うと、クライアントからサーバー接続は裏方でよしなにやってくれるのでそっちの方が簡単ではある。
func (r *ReplicaSet) Initiate(ctx context.Context, config bson.M) error { client, err := r.connectDirect(ctx) if err != nil { return fmt.Errorf(&amp;#34;failed to connect with direct: %w&amp;#34;, err) } defer client.Disconnect(ctx) var result bson.</description><content>&lt;p>4時前に寝て6時半に起きた。1時過ぎまで作業して、帰って少しゲームして、うまく眠れなくてだらだらしていた。&lt;/p>
&lt;h2 id="mongodb-のレプリカセットの調査">mongodb のレプリカセットの調査&lt;/h2>
&lt;p>以前 &lt;a href="/diary/diary/posts/2023/1101/#mongo-とトランザクションとレプリカセット">mongodb でトランザクションを使うときにレプリカセットが必要&lt;/a> なことがわかった。他機能の開発途中だったので一旦後回しにしていたものを回収している。状況によってはメンバーに委譲してもよかったんだけど、私が遊撃で出張ってみることにした。実際に調べてみてコンテナの運用も考慮するとけっこう難しいことがわかってきた。&lt;/p>
&lt;p>&lt;a href="https://www.mongodb.com/docs/mongodb-shell/">mongosh&lt;/a> からは &lt;a href="https://www.mongodb.com/docs/v7.0/reference/method/js-replication/">Replication Methods&lt;/a> を使ってレプリカセットの操作ができる。これはユーティリティのようなもので mongodb としての低レベルのコマンド操作は &lt;a href="https://www.mongodb.com/docs/manual/reference/command/nav-replication/">Replication Commands&lt;/a> になる。&lt;a href="https://github.com/mongodb/mongo-go-driver">mongo-go-driver&lt;/a> はレプリカセット向けのユーティリティを提供していないため、Replication Commands を RunCommand() の低レベル API を使って自分で実装しないといけない。&lt;/p>
&lt;p>例えば、レプリカセットの初期化をするときは次のように &lt;code>replSetInitiate&lt;/code> というコマンドを適切なパラメーターで呼び出す。あまりドキュメントで丁寧に説明されていないので試行錯誤でエラーメッセージをみながら実装することになる。とくにはまるのが mongod のサーバーは &lt;code>--replSet myrs&lt;/code> のようにレプリカセットを指定して起動させるものの、初期化コマンドを実行するときはまだレプリカセットを設定していないため、レプリカセットを指定せず、且つ &lt;code>direct&lt;/code> パラメーターをセットしないと mongod サーバーに接続できない。この微妙な設定を把握するのにはまった。これが正しい手順かどうかもわからないが、ググったりしているとフォーラムでそういったコメントが散見されたりする。おそらく mongosh の Replication Methods を使うと、クライアントからサーバー接続は裏方でよしなにやってくれるのでそっちの方が簡単ではある。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ReplicaSet&lt;/span>) &lt;span style="color:#a6e22e">Initiate&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span> &lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#a6e22e">config&lt;/span> &lt;span style="color:#a6e22e">bson&lt;/span>.&lt;span style="color:#a6e22e">M&lt;/span>) &lt;span style="color:#66d9ef">error&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">client&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">connectDirect&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Errorf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;failed to connect with direct: %w&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">defer&lt;/span> &lt;span style="color:#a6e22e">client&lt;/span>.&lt;span style="color:#a6e22e">Disconnect&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">result&lt;/span> &lt;span style="color:#a6e22e">bson&lt;/span>.&lt;span style="color:#a6e22e">M&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">cmd&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">bson&lt;/span>.&lt;span style="color:#a6e22e">D&lt;/span>{{&lt;span style="color:#a6e22e">Key&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;replSetInitiate&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">Value&lt;/span>: &lt;span style="color:#a6e22e">config&lt;/span>}}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">client&lt;/span>.&lt;span style="color:#a6e22e">Database&lt;/span>(&lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">db&lt;/span>).&lt;span style="color:#a6e22e">RunCommand&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span>, &lt;span style="color:#a6e22e">cmd&lt;/span>).&lt;span style="color:#a6e22e">Decode&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">result&lt;/span>); &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Errorf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;failed to run replSetInitiate(): %w&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">log&lt;/span>.&lt;span style="color:#a6e22e">PrettyPrint&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;completed to initiate&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">result&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ReplicaSet&lt;/span>) &lt;span style="color:#a6e22e">connectDirect&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span> &lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">mongo&lt;/span>.&lt;span style="color:#a6e22e">Client&lt;/span>, &lt;span style="color:#66d9ef">error&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">opts&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">options&lt;/span>.&lt;span style="color:#a6e22e">Client&lt;/span>().
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">SetAuth&lt;/span>(&lt;span style="color:#a6e22e">options&lt;/span>.&lt;span style="color:#a6e22e">Credential&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Username&lt;/span>: &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">config&lt;/span>.&lt;span style="color:#a6e22e">User&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Password&lt;/span>: &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">config&lt;/span>.&lt;span style="color:#a6e22e">Passwd&lt;/span>.&lt;span style="color:#a6e22e">String&lt;/span>(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }).
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">SetHosts&lt;/span>(&lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">config&lt;/span>.&lt;span style="color:#a6e22e">Hosts&lt;/span>).
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">SetDirect&lt;/span>(&lt;span style="color:#66d9ef">true&lt;/span>) &lt;span style="color:#75715e">// must be true
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">mongo&lt;/span>.&lt;span style="color:#a6e22e">Connect&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span>, &lt;span style="color:#a6e22e">opts&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">InitSingleReplicaSet&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ctx&lt;/span> &lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#a6e22e">cfg&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">config&lt;/span>.&lt;span style="color:#a6e22e">MongoDB&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) &lt;span style="color:#66d9ef">error&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">rs&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">NewReplicaSet&lt;/span>(&lt;span style="color:#a6e22e">cfg&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">initConfig&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">bson&lt;/span>.&lt;span style="color:#a6e22e">M&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;_id&amp;#34;&lt;/span>: &lt;span style="color:#a6e22e">cfg&lt;/span>.&lt;span style="color:#a6e22e">ReplicaSet&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;members&amp;#34;&lt;/span>: []&lt;span style="color:#a6e22e">bson&lt;/span>.&lt;span style="color:#a6e22e">M&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#e6db74">&amp;#34;_id&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;host&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;localhost:27017&amp;#34;&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">rs&lt;/span>.&lt;span style="color:#a6e22e">Initiate&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span>, &lt;span style="color:#a6e22e">initConfig&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>さらに mongod サーバーを起動するときに &lt;code>--replSet&lt;/code> と &lt;code>--keyFile&lt;/code> (認証が必要な場合のみ？) という2つのパラメーターを指定する必要がある。&lt;code>--replSet&lt;/code> はレプリカセットの識別子を指定する。そして &lt;code>--keyFile&lt;/code> は共通鍵を指定する。この共通鍵を生成するには次のようにする。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ openssl rand -base64 &lt;span style="color:#ae81ff">756&lt;/span> &amp;gt; my-mongo-keyfile
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ chown mongodb:mongodb my-mongo-keyfile
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ chmod &lt;span style="color:#ae81ff">400&lt;/span> my-mongo-keyfile
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>普通のサーバーインスタンスならすぐできることだが、コンテナの運用において面倒なのが owner とパーミッションを設定しないといけないところ。mongo のコンテナは mongodb ユーザーで起動するため、root でマウントされたファイルシステムには書き込みできなかったりして keyFile の配置をどう扱えばよいのかが難しい。docker hub の mongo の issues でもどうやって設定したらいいの？って議論が発散している。mongo 本体が公式のスクリプトや仕組みを提供していれば済む話しだけど、どうもそうではないみたい。だから泥臭い方法で自分でなんとかしないといけないようにみえる。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/docker-library/mongo/issues/246">Creating a mongo image set with &amp;ndash;replSet #246&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/docker-library/mongo/issues/339">Cannot configure replica sets with entrypoint-initdb #339&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>dockertest でもレプリカセットの設定について次の issue として登録されている。mongo のコンテナを使ったテストの場合、dockertest のレイヤーが挟まるのでさらにわかりにくくなっている。テストを動かすためにどういった設定が必要かは把握できたのでなにかよい方法を考えてコントリビュートしたい。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/ory/dockertest/issues/480">Create an example for starting mongodb as a replica set #480&lt;/a>&lt;/li>
&lt;/ul></content></item><item><title>インフラの式年遷宮</title><link>/diary/posts/2023/1002/</link><pubDate>Mon, 02 Oct 2023 09:08:26 +0900</pubDate><guid>/diary/posts/2023/1002/</guid><description>1時に寝て何度か起きて5時に起きた。それからだらだらして寝てまた7時に起きた。
テスト環境の再整備と rootless コンテナ インフラの式年遷宮のようなことをしていて、テスト環境をリファクタリングして再整備していた。これまで root でコンテナを実行していたが、最近は rootless コンテナがセキュリティ強化の観点から望ましいということで次のドキュメントをみながら設定した。
Linux post-installation steps for Docker Engine 設定はとくに難しくないが、dockerd や containerd の起動を systemd のユーザーインスタンスに依存することになる。systemd のユーザーインスタンスは基本的にユーザーがログインしたときに生成されるものなので OS が再起動したときなどに困る。OS 再起動時にも systemd のユーザーインスタンスを生成するには linger という仕組みを有効にすればよいらしい。systemd &amp;ndash;user の扱いと linger のことまで理解していれば、たぶん大丈夫なのかな？これで運用がうまくいくことを祈りたい。
$ sudo loginctl enable-linger ucidm</description><content>&lt;p>1時に寝て何度か起きて5時に起きた。それからだらだらして寝てまた7時に起きた。&lt;/p>
&lt;h2 id="テスト環境の再整備と-rootless-コンテナ">テスト環境の再整備と rootless コンテナ&lt;/h2>
&lt;p>インフラの式年遷宮のようなことをしていて、テスト環境をリファクタリングして再整備していた。これまで root でコンテナを実行していたが、最近は rootless コンテナがセキュリティ強化の観点から望ましいということで次のドキュメントをみながら設定した。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.docker.com/engine/install/linux-postinstall/">Linux post-installation steps for Docker Engine&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>設定はとくに難しくないが、dockerd や containerd の起動を systemd のユーザーインスタンスに依存することになる。systemd のユーザーインスタンスは基本的にユーザーがログインしたときに生成されるものなので OS が再起動したときなどに困る。OS 再起動時にも systemd のユーザーインスタンスを生成するには linger という仕組みを有効にすればよいらしい。systemd &amp;ndash;user の扱いと linger のことまで理解していれば、たぶん大丈夫なのかな？これで運用がうまくいくことを祈りたい。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ sudo loginctl enable-linger ucidm
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></content></item><item><title>コンテナー間のデータ通信と named pipe</title><link>/diary/posts/2023/0829/</link><pubDate>Tue, 29 Aug 2023 09:27:04 +0900</pubDate><guid>/diary/posts/2023/0829/</guid><description>22時頃から寝ていて2回起きて3時に起き出して、4時までネットみたりしていて、また寝て6時に起きた。生活のリズムがおかしい。
コンテナー間のデータのやり取り 昨日 モジュール分割 したことにより、いままで1つのモジュールで管理していたが、モジュールを分割したのでそれぞれのバージョンを取得できるとよいという話題が出た。コンテナー内にアプリケーションのバイナリがあり、バイナリを実行するとバージョン情報を取得できる。それぞれのモジュールは独立したコンテナで動いてるため、コンテナー間でその情報を受け渡す方法が必要になる。ググってみると次の so がヒットして named pipe がプラクティスだという。
How to run shell script on host from docker container? ホスト os 上の named pipe をコンテナーの volumes でマウントして、それぞれのコンテナーが読み書きすればよい。構築時に named pipe さえ作ったらコンテナー内での読み書きでデータ通信を実現できるため、シンプルでよいんじゃないかと思えた。
mypipe という named pipe を作る。
$ mkfifo mypipe 読み込み用コンテナーのための read-Dockerfile を作る。tail コマンドで named pipe を読む。
$ vi read-Dockerfile From bash:latest ENTRYPOINT [ &amp;#34;tail&amp;#34;, &amp;#34;-f&amp;#34;, &amp;#34;/app/mypipe&amp;#34; ] $ docker build -t mypipe-read:latest -f read-Dockerfile . named pipe をマウントして読み込み用コンテナーを起動する。
$ docker run --rm --mount type=bind,source=&amp;#34;$(pwd)&amp;#34;/mypipe,target=/app/mypipe,readonly mypipe-read 書き込み用のエントリーポイントのスクリプトはちょっと工夫がいる。おそらく Dockerfile 内で直接リダイレクトの操作ができない (やり方がわからなかった) 。シェルスクリプトを呼び出す形にして、シェルスクリプト内部でリダイレクトにより、named pipe に書き込みする。</description><content>&lt;p>22時頃から寝ていて2回起きて3時に起き出して、4時までネットみたりしていて、また寝て6時に起きた。生活のリズムがおかしい。&lt;/p>
&lt;h2 id="コンテナー間のデータのやり取り">コンテナー間のデータのやり取り&lt;/h2>
&lt;p>昨日 &lt;a href="/diary/diary/posts/2023/0828/">モジュール分割&lt;/a> したことにより、いままで1つのモジュールで管理していたが、モジュールを分割したのでそれぞれのバージョンを取得できるとよいという話題が出た。コンテナー内にアプリケーションのバイナリがあり、バイナリを実行するとバージョン情報を取得できる。それぞれのモジュールは独立したコンテナで動いてるため、コンテナー間でその情報を受け渡す方法が必要になる。ググってみると次の so がヒットして named pipe がプラクティスだという。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://stackoverflow.com/questions/32163955/how-to-run-shell-script-on-host-from-docker-container">How to run shell script on host from docker container?&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>ホスト os 上の named pipe をコンテナーの volumes でマウントして、それぞれのコンテナーが読み書きすればよい。構築時に named pipe さえ作ったらコンテナー内での読み書きでデータ通信を実現できるため、シンプルでよいんじゃないかと思えた。&lt;/p>
&lt;p>mypipe という named pipe を作る。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ mkfifo mypipe
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>読み込み用コンテナーのための read-Dockerfile を作る。tail コマンドで named pipe を読む。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ vi read-Dockerfile
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>From bash:latest
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ENTRYPOINT &lt;span style="color:#f92672">[&lt;/span> &lt;span style="color:#e6db74">&amp;#34;tail&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;-f&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;/app/mypipe&amp;#34;&lt;/span> &lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ docker build -t mypipe-read:latest -f read-Dockerfile .
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>named pipe をマウントして読み込み用コンテナーを起動する。&lt;/p>
&lt;pre tabindex="0">&lt;code>$ docker run --rm --mount type=bind,source=&amp;#34;$(pwd)&amp;#34;/mypipe,target=/app/mypipe,readonly mypipe-read
&lt;/code>&lt;/pre>&lt;p>書き込み用のエントリーポイントのスクリプトはちょっと工夫がいる。おそらく Dockerfile 内で直接リダイレクトの操作ができない (やり方がわからなかった) 。シェルスクリプトを呼び出す形にして、シェルスクリプト内部でリダイレクトにより、named pipe に書き込みする。&lt;/p>
&lt;p>エントリーポイントのスクリプトは次のような感じ。&lt;code>eval &amp;quot;$@&amp;quot;&lt;/code> で任意のコード実行できるようにちょっと細工。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ vi myentrypoint.sh
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/sh&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cleanup&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#34;cleanup ...&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exit &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>trap cleanup INT TERM
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">while&lt;/span> true
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>date&lt;span style="color:#66d9ef">)&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> eval &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$@&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sleep &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>書き込み用コンテナーのための write-Dockerfile を作る。先の myentrypoint.sh を &lt;code>ENTRYPOINT&lt;/code> として起動させる。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ vi write-Dockerfile
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>From bash:latest
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>COPY myentrypoint.sh /app/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>RUN chmod +x /app/myentrypoint.sh
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ENTRYPOINT &lt;span style="color:#f92672">[&lt;/span> &lt;span style="color:#e6db74">&amp;#34;/app/myentrypoint.sh&amp;#34;&lt;/span> &lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ docker build -t mypipe-write:latest -f write-Dockerfile .
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>適当に乱数を生成する cli を eval 実行させる。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ docker run --rm --mount type&lt;span style="color:#f92672">=&lt;/span>bind,source&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>pwd&lt;span style="color:#66d9ef">)&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>/mypipe,target&lt;span style="color:#f92672">=&lt;/span>/app/mypipe mypipe-write &lt;span style="color:#e6db74">&amp;#34;tr -dc 0-9 &amp;lt; /dev/urandom | fold -w 8 | head -1 &amp;gt; /app/mypipe&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>読み込み用コンテナーで乱数を表示できるはず。&lt;/p>
&lt;p>なにも難しくなく、linux の標準の機能を使ってコンテナー間のデータ通信を実現できたことにちょっと驚いた。&lt;/p>
&lt;p>go で named pipe を読むときは linux ならば &lt;code>syscall.O_NONBLOCK&lt;/code> を指定することで書き込みしていなくてもブロックせずに読める。値を取得できない可能性はあるけど、それが許される要件ならこれで済む。またテックブログにまとめたい。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">readNamedPipe&lt;/span>(&lt;span style="color:#a6e22e">path&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>) ([]&lt;span style="color:#66d9ef">byte&lt;/span>, &lt;span style="color:#66d9ef">error&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">flag&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">os&lt;/span>.&lt;span style="color:#a6e22e">O_RDONLY&lt;/span> | &lt;span style="color:#a6e22e">syscall&lt;/span>.&lt;span style="color:#a6e22e">O_NONBLOCK&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">pipe&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">os&lt;/span>.&lt;span style="color:#a6e22e">OpenFile&lt;/span>(&lt;span style="color:#a6e22e">path&lt;/span>, &lt;span style="color:#a6e22e">flag&lt;/span>, &lt;span style="color:#a6e22e">os&lt;/span>.&lt;span style="color:#a6e22e">ModeNamedPipe&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>, &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Errorf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;failed to open path: %w&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">defer&lt;/span> &lt;span style="color:#a6e22e">pipe&lt;/span>.&lt;span style="color:#a6e22e">Close&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">reader&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">bufio&lt;/span>.&lt;span style="color:#a6e22e">NewReader&lt;/span>(&lt;span style="color:#a6e22e">pipe&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">b&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">reader&lt;/span>.&lt;span style="color:#a6e22e">ReadLine&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>, &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Errorf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;failed to read line: %w&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">b&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></content></item><item><title>issue を作るとストレスが軽減する</title><link>/diary/posts/2023/0519/</link><pubDate>Fri, 19 May 2023 19:49:10 +0900</pubDate><guid>/diary/posts/2023/0519/</guid><description>お酒飲んで新幹線乗ったせいか、新幹線の中であまり寝られなくて暑くていつもより移動に疲れた。その後1時に寝て何度か起きて7時に起きた。2日酔いではないが、寝起きの気分はよくなかった。
issue を作ることによるストレス軽減 昨日の打ち合わせのメモから議事録を作ったり、そこから新しい issue を作ったりしながら来週の打ち合わせの資料作りをしていた。資料を作っている途中、割り込みでメンバーのコードレビューが入ったりして、あまり資料作りは進捗しなかった。
打ち合わせした内容から issue を作る作業を、私は好きだったりする。何をやってよいかわからない状況というのは苦しい。issue を作ること、要件を言語化したり、背景を調べたり、他の issue との関連付けしたり、そういった手を動かすことがきっかけになって、その issue を明確化していく作業を積み重ねれば時間の経過とともに課題が解決するということを経験的に理解しているからだ。
大雑把に言えば、私にとって、issue さえ作れればその課題解決は優先順位付けと (解決までの) 時間の問題に置き換えられる。あれやらなきゃ、これもやらなきゃ、なにか抜け・漏れがあるんじゃないかと頭の中でもやもやしているものを issue という概念に変換することで考えなくて済むようになっていく過程がストレスを軽減している気もする。
コンテナ勉強会 先日公開したテックブログ とプラスアルファで勉強会をした。コンテナという汎用的な話題だったので CTO から社内向けにアナウンスされて (半業務命令っぽい雰囲気で) いつもより参加者は多かったように思える。10人前後は参加されていた。40分ぐらいで話し終えて20分ほど雑談の時間をとって盛り上がりは微妙だったけど、いくつか意見や質問が出たのでよかったのではないかと思う。
チームのメンバーが発表するときは私がモデレーターの役割をしている。私が発表するときはモデレーター兼発表者になってしまう。モデレーターと発表者を兼任するのはとても難しい。おそらく脳の集中力を向ける先が異なるからではないかと思う。モデレーターは質問者の質問を広げたり、コミュニケーションがうまくいくように手伝ったりする。回答から次の質問を考えたりもする。一方で発表者は自分の調べたことや伝えたいことを聴衆にわかりやすく伝えることのみに注力する。
モデレーターと発表者が同じになってしまうと、自分の説明のどこが伝わっていないのか、質問者の意図を組むにはどうすればいいかといったモデレーターの視点がなくなってしまう。以前 tenntenn さんの個人カンファレンス に参加したときに1人2役でパネルディスカッションをされていて、そのときに同僚からあまりやり過ぎると人格崩壊するから気をつけた方よいといった忠告を受けたと冗談で話されていた意味が理解できた。役者が他人になりきるように、これは兼任じゃなくて1人で2つの人格を演じないといけない。そんな器用なことはそうそうできない。</description><content>&lt;p>お酒飲んで新幹線乗ったせいか、新幹線の中であまり寝られなくて暑くていつもより移動に疲れた。その後1時に寝て何度か起きて7時に起きた。2日酔いではないが、寝起きの気分はよくなかった。&lt;/p>
&lt;h2 id="issue-を作ることによるストレス軽減">issue を作ることによるストレス軽減&lt;/h2>
&lt;p>昨日の打ち合わせのメモから議事録を作ったり、そこから新しい issue を作ったりしながら来週の打ち合わせの資料作りをしていた。資料を作っている途中、割り込みでメンバーのコードレビューが入ったりして、あまり資料作りは進捗しなかった。&lt;/p>
&lt;p>打ち合わせした内容から issue を作る作業を、私は好きだったりする。何をやってよいかわからない状況というのは苦しい。issue を作ること、要件を言語化したり、背景を調べたり、他の issue との関連付けしたり、そういった手を動かすことがきっかけになって、その issue を明確化していく作業を積み重ねれば時間の経過とともに課題が解決するということを経験的に理解しているからだ。&lt;/p>
&lt;p>大雑把に言えば、私にとって、issue さえ作れればその課題解決は優先順位付けと (解決までの) 時間の問題に置き換えられる。あれやらなきゃ、これもやらなきゃ、なにか抜け・漏れがあるんじゃないかと頭の中でもやもやしているものを issue という概念に変換することで考えなくて済むようになっていく過程がストレスを軽減している気もする。&lt;/p>
&lt;h2 id="コンテナ勉強会">コンテナ勉強会&lt;/h2>
&lt;p>&lt;a href="/diary/diary/posts/2023/0516/#テックブログ公開">先日公開したテックブログ&lt;/a> とプラスアルファで勉強会をした。コンテナという汎用的な話題だったので CTO から社内向けにアナウンスされて (半業務命令っぽい雰囲気で) いつもより参加者は多かったように思える。10人前後は参加されていた。40分ぐらいで話し終えて20分ほど雑談の時間をとって盛り上がりは微妙だったけど、いくつか意見や質問が出たのでよかったのではないかと思う。&lt;/p>
&lt;p>チームのメンバーが発表するときは私がモデレーターの役割をしている。私が発表するときはモデレーター兼発表者になってしまう。モデレーターと発表者を兼任するのはとても難しい。おそらく脳の集中力を向ける先が異なるからではないかと思う。モデレーターは質問者の質問を広げたり、コミュニケーションがうまくいくように手伝ったりする。回答から次の質問を考えたりもする。一方で発表者は自分の調べたことや伝えたいことを聴衆にわかりやすく伝えることのみに注力する。&lt;/p>
&lt;p>モデレーターと発表者が同じになってしまうと、自分の説明のどこが伝わっていないのか、質問者の意図を組むにはどうすればいいかといったモデレーターの視点がなくなってしまう。以前 &lt;a href="/diary/diary/posts/2023/0401/#個人カンファレンス">tenntenn さんの個人カンファレンス&lt;/a> に参加したときに1人2役でパネルディスカッションをされていて、そのときに同僚からあまりやり過ぎると人格崩壊するから気をつけた方よいといった忠告を受けたと冗談で話されていた意味が理解できた。役者が他人になりきるように、これは兼任じゃなくて1人で2つの人格を演じないといけない。そんな器用なことはそうそうできない。&lt;/p></content></item><item><title>出張の中日</title><link>/diary/posts/2023/0517/</link><pubDate>Wed, 17 May 2023 18:37:05 +0900</pubDate><guid>/diary/posts/2023/0517/</guid><description>0時に寝て何度か起きて5時半に起きてテレビで朝のニュースを聞き流しながら7時に起きた。
資料作成 今日はメンバーの1人が休暇だったため、打ち合わせはなしで資料ばかり作っていた。今週のチーム勉強会の発表は私が担当するのでその資料を作ったり、リリースを終えて社内向けにプロダクトの説明のための資料を準備したりしていた。これまでたくさんの資料を作ってきてるので改めて作るというよりは、過去に作ったものを洗練させたり、集めてきて補足する程度の作業になりそうな雰囲気だけわかってきた。
aws app runner の情報収集 App Runner Night !! にオンラインで参加した。AWS Startup Community というコミュニティがあることも知らなかった。顧問のはらさんが LT 発表すると聞いていたのでそれをみようと思ってながらで聞いていたので他の発表はあまりちゃんとみていてない。特別に目新しいことはなかったし、発表の中でもいくつかちょっとそこ怪しいんじゃない？とか思いながら他の作業をしていた。
私も余裕があれば app runner でサービスを動かしてみてその勘所を把握しておきたい。ecs がやりたいことに比べて使いにくいという印象は私もずっと思っていた。実質 k8s 以外のコンテナプラットフォームは aws しかないので app runner がよいものかどうかに関心をもっている。
コワーキングのオンラインイベント 月例のカフーツさんのオンラインイベントに参加した。先月の所感はここ 。今日は「移動」というテーマでいつも通りいとうさんがわーっと話をしていた。この2ヶ月に新しい官民の取り組みが始まったらしい。なんか空気だけでダメそうにみえる。
「テレワーク・ワーケーション官民推進協議会」を設立しました！ このサイトでは次の2つの用語を定義している。ブレジャーを初めて知ったけど、発音しにくくて語呂が悪いだろとか思えた。
ワーケーション (Work + Vacation) ブレジャー (Business + Leisure) このサイトにあるワーケーションの実施形態には共感するところもあって次の4つに分類している。IT 業界で多いのは合宿型とサテライトオフィス型かな。
福利厚生型 地域課題解決型 合宿型 サテライトオフィス型 あとどういう文脈だったか忘れてしまったが、身体感覚で「芭蕉」を読みなおす。 『おくのほそ道』謎解きの旅 という本を紹介された。能の探求者が書いた独特の視点から松尾芭蕉を取り上げた本らしくて、なんかおもしろそうにみえたのですぐに購入してみた。紙の文庫本しかなかった。読んでみる。</description><content>&lt;p>0時に寝て何度か起きて5時半に起きてテレビで朝のニュースを聞き流しながら7時に起きた。&lt;/p>
&lt;h2 id="資料作成">資料作成&lt;/h2>
&lt;p>今日はメンバーの1人が休暇だったため、打ち合わせはなしで資料ばかり作っていた。今週のチーム勉強会の発表は私が担当するのでその資料を作ったり、リリースを終えて社内向けにプロダクトの説明のための資料を準備したりしていた。これまでたくさんの資料を作ってきてるので改めて作るというよりは、過去に作ったものを洗練させたり、集めてきて補足する程度の作業になりそうな雰囲気だけわかってきた。&lt;/p>
&lt;h2 id="aws-app-runner-の情報収集">aws app runner の情報収集&lt;/h2>
&lt;p>&lt;a href="https://aws-startup-community.connpass.com/event/282015/">App Runner Night !!&lt;/a> にオンラインで参加した。&lt;a href="https://aws-startup-community.connpass.com/">AWS Startup Community&lt;/a> というコミュニティがあることも知らなかった。顧問のはらさんが LT 発表すると聞いていたのでそれをみようと思ってながらで聞いていたので他の発表はあまりちゃんとみていてない。特別に目新しいことはなかったし、発表の中でもいくつかちょっとそこ怪しいんじゃない？とか思いながら他の作業をしていた。&lt;/p>
&lt;p>私も余裕があれば app runner でサービスを動かしてみてその勘所を把握しておきたい。ecs がやりたいことに比べて使いにくいという印象は私もずっと思っていた。実質 k8s 以外のコンテナプラットフォームは aws しかないので app runner がよいものかどうかに関心をもっている。&lt;/p>
&lt;h2 id="コワーキングのオンラインイベント">コワーキングのオンラインイベント&lt;/h2>
&lt;p>月例のカフーツさんのオンラインイベントに参加した。&lt;a href="/diary/diary/posts/2023/0419/#コワーキングのオンラインイベント">先月の所感はここ&lt;/a> 。今日は「移動」というテーマでいつも通りいとうさんがわーっと話をしていた。この2ヶ月に新しい官民の取り組みが始まったらしい。なんか空気だけでダメそうにみえる。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.mlit.go.jp/kankocho/workation-bleisure/news/230218/">「テレワーク・ワーケーション官民推進協議会」を設立しました！&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>このサイトでは次の2つの用語を定義している。ブレジャーを初めて知ったけど、発音しにくくて語呂が悪いだろとか思えた。&lt;/p>
&lt;ul>
&lt;li>ワーケーション (Work + Vacation)&lt;/li>
&lt;li>ブレジャー (Business + Leisure)&lt;/li>
&lt;/ul>
&lt;p>このサイトにあるワーケーションの実施形態には共感するところもあって次の4つに分類している。IT 業界で多いのは合宿型とサテライトオフィス型かな。&lt;/p>
&lt;ul>
&lt;li>福利厚生型&lt;/li>
&lt;li>地域課題解決型&lt;/li>
&lt;li>合宿型&lt;/li>
&lt;li>サテライトオフィス型&lt;/li>
&lt;/ul>
&lt;p>あとどういう文脈だったか忘れてしまったが、&lt;a href="https://www.shunjusha.co.jp/book/9784393436400.html">身体感覚で「芭蕉」を読みなおす。 『おくのほそ道』謎解きの旅&lt;/a> という本を紹介された。能の探求者が書いた独特の視点から松尾芭蕉を取り上げた本らしくて、なんかおもしろそうにみえたのですぐに購入してみた。紙の文庫本しかなかった。読んでみる。&lt;/p></content></item></channel></rss>