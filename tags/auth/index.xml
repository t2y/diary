<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>auth on forest nook</title><link>/diary/tags/auth/</link><description>Recent content in auth on forest nook</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><copyright>© 2021 Tetsuya Morimoto</copyright><lastBuildDate>Tue, 18 Apr 2023 08:17:20 +0900</lastBuildDate><atom:icon>/diary/favicon.ico</atom:icon><icon>/diary/favicon.ico</icon><atom:link href="/diary/tags/auth/index.xml" rel="self" type="application/rss+xml"/><item><title>unix crypt(3) をよくわかってなかった</title><link>/diary/posts/2023/0418/</link><pubDate>Tue, 18 Apr 2023 08:17:20 +0900</pubDate><guid>/diary/posts/2023/0418/</guid><description>0時に寝て2回ほど起きて7時に起きた。わりと気分がよい方。
unix の crypt(3) というライブラリ実装 google の Admin console の api の REST Resource: users で hashFunction として crypt を選択してハッシュ化したパスワードを連携できる。
crypt - C crypt ライブラリに準拠しています。DES、MD5（ハッシュ プレフィックス $1$）、SHA-256（ハッシュ プレフィックス $5$）、SHA-512（ハッシュ プレフィックス $6$）ハッシュ アルゴリズムをサポートします。
この crypt というのは単純に sha256 や sha512 でハッシュ化すればよいわけではなく、歴史的経緯でそれぞれの os ごとにある crypt ライブラリの実装に依存しているらしい。
$ man 3 crypt おそらく google のドキュメントがいう C crypt ライブラリというのは glibc のことを指していると考えてよいと思うが、go の準標準パッケージである golang.org/x/crypto を探してもその実装は存在しない。これも推測だが、仕様が曖昧なものを go の開発者は実装しようとしないのだと思う。とはいえ、c の crypt ライブラリをラップして go から使うのも面倒と言えば面倒なので誰かが crypt ライブラリを真似て野良実装して、それが一部で使われていたりするようにみえる。しかし、なぜかそのオリジナルを作った開発者はそのコードのリポジトリを削除していて、ソースコードのコピーがまわりまわって、いま github.com/GehirnInc/crypt で保守されているらしい。このライブラリを使ってエンコードすると c の crypt ライブラリの出力と一致することは確認できた。この実装をみれば、単純にエンコードすればよいといったものではないことが伺えるので pure go のライブラリとして共有されているのは有り難い。</description><content>&lt;p>0時に寝て2回ほど起きて7時に起きた。わりと気分がよい方。&lt;/p>
&lt;h2 id="unix-の-crypt3-というライブラリ実装">unix の crypt(3) というライブラリ実装&lt;/h2>
&lt;p>google の Admin console の api の &lt;a href="https://developers.google.com/admin-sdk/directory/reference/rest/v1/users?hl=ja">REST Resource: users&lt;/a> で &lt;code>hashFunction&lt;/code> として crypt を選択してハッシュ化したパスワードを連携できる。&lt;/p>
&lt;blockquote>
&lt;p>crypt - C crypt ライブラリに準拠しています。DES、MD5（ハッシュ プレフィックス $1$）、SHA-256（ハッシュ プレフィックス $5$）、SHA-512（ハッシュ プレフィックス $6$）ハッシュ アルゴリズムをサポートします。&lt;/p>
&lt;/blockquote>
&lt;p>この crypt というのは単純に sha256 や sha512 でハッシュ化すればよいわけではなく、歴史的経緯でそれぞれの os ごとにある crypt ライブラリの実装に依存しているらしい。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ man &lt;span style="color:#ae81ff">3&lt;/span> crypt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>おそらく google のドキュメントがいう C crypt ライブラリというのは glibc のことを指していると考えてよいと思うが、go の準標準パッケージである &lt;a href="https://pkg.go.dev/golang.org/x/crypto">golang.org/x/crypto&lt;/a> を探してもその実装は存在しない。これも推測だが、仕様が曖昧なものを go の開発者は実装しようとしないのだと思う。とはいえ、c の crypt ライブラリをラップして go から使うのも面倒と言えば面倒なので誰かが crypt ライブラリを真似て野良実装して、それが一部で使われていたりするようにみえる。しかし、なぜかそのオリジナルを作った開発者はそのコードのリポジトリを削除していて、ソースコードのコピーがまわりまわって、いま &lt;a href="https://github.com/GehirnInc/crypt">github.com/GehirnInc/crypt&lt;/a> で保守されているらしい。このライブラリを使ってエンコードすると c の crypt ライブラリの出力と一致することは確認できた。この実装をみれば、単純にエンコードすればよいといったものではないことが伺えるので pure go のライブラリとして共有されているのは有り難い。&lt;/p>
&lt;p>このライブラリを使ってハッシュ化した文字列と c 言語のコードも chatgpt に書いてもらっていくつか一致することは検証できた。デバッグしていて、もう1つ salt を生成も特定の文字しか使えないのでうっかり乱数を使って文字列生成していると間違ってしまう。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">saltChars&lt;/span> = []byte(&lt;span style="color:#e6db74">&amp;#34;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789./&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">GenerateSalt&lt;/span>(&lt;span style="color:#a6e22e">method&lt;/span> &lt;span style="color:#a6e22e">Method&lt;/span>) []&lt;span style="color:#66d9ef">byte&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">b&lt;/span> = make([]&lt;span style="color:#66d9ef">byte&lt;/span>, &lt;span style="color:#ae81ff">16&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">charsLength&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> len(&lt;span style="color:#a6e22e">saltChars&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">b&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">b&lt;/span>[&lt;span style="color:#a6e22e">i&lt;/span>] = &lt;span style="color:#a6e22e">saltChars&lt;/span>[&lt;span style="color:#a6e22e">rand&lt;/span>.&lt;span style="color:#a6e22e">Intn&lt;/span>(&lt;span style="color:#a6e22e">charsLength&lt;/span>)]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">salt&lt;/span> []&lt;span style="color:#66d9ef">byte&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">switch&lt;/span> &lt;span style="color:#a6e22e">method&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#a6e22e">SHA256&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">salt&lt;/span> = append([]byte(&lt;span style="color:#e6db74">&amp;#34;$5$&amp;#34;&lt;/span>), &lt;span style="color:#a6e22e">b&lt;/span>&lt;span style="color:#f92672">...&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#a6e22e">SHA512&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">salt&lt;/span> = append([]byte(&lt;span style="color:#e6db74">&amp;#34;$6$&amp;#34;&lt;/span>), &lt;span style="color:#a6e22e">b&lt;/span>&lt;span style="color:#f92672">...&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">default&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> panic(&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Sprintf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;unsupported salt method: %s&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">method&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">salt&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここで生成した salt を使って github.com/GehirnInc/crypt を使うとこんな感じで crypt を使って google のユーザーアカウント連携ができる。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">Crypt&lt;/span>(&lt;span style="color:#a6e22e">password&lt;/span>, &lt;span style="color:#a6e22e">salt&lt;/span> []&lt;span style="color:#66d9ef">byte&lt;/span>) (&lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#66d9ef">error&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> len(&lt;span style="color:#a6e22e">salt&lt;/span>) &amp;lt; &lt;span style="color:#ae81ff">3&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Errorf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;invalid salt: %s&amp;#34;&lt;/span>, string(&lt;span style="color:#a6e22e">salt&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">crypter&lt;/span> &lt;span style="color:#a6e22e">crypt&lt;/span>.&lt;span style="color:#a6e22e">Crypter&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">switch&lt;/span> string(&lt;span style="color:#a6e22e">salt&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>:&lt;span style="color:#ae81ff">3&lt;/span>]) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#e6db74">&amp;#34;$5$&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">crypter&lt;/span> = &lt;span style="color:#a6e22e">crypt&lt;/span>.&lt;span style="color:#a6e22e">SHA256&lt;/span>.&lt;span style="color:#a6e22e">New&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#e6db74">&amp;#34;$6$&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">crypter&lt;/span> = &lt;span style="color:#a6e22e">crypt&lt;/span>.&lt;span style="color:#a6e22e">SHA512&lt;/span>.&lt;span style="color:#a6e22e">New&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">default&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Errorf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;unsupported salt prefix: %s&amp;#34;&lt;/span>, string(&lt;span style="color:#a6e22e">salt&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>:&lt;span style="color:#ae81ff">3&lt;/span>]))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">hashed&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">crypter&lt;/span>.&lt;span style="color:#a6e22e">Generate&lt;/span>(&lt;span style="color:#a6e22e">password&lt;/span>, &lt;span style="color:#a6e22e">salt&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">crypter&lt;/span>.&lt;span style="color:#a6e22e">Verify&lt;/span>(&lt;span style="color:#a6e22e">hashed&lt;/span>, &lt;span style="color:#a6e22e">password&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">hashed&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ハッシュ化した文字列が正しいかどうかは実際に google にログインしてみないと判別できないのでわりとデバッグや検証に時間がかかった。&lt;/p>
&lt;h3 id="リファレンス">リファレンス&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://blog.amedama.jp/entry/unix-crypt-3">色々な Unix 系 OS の crypt(3) について調べたら面白かった話&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://yosida95.com/2015/07/25/120000.html">/etc/shadow などで使われるハッシュ関数、 crypt(3) を Go 言語で実装しました&lt;/a>&lt;/li>
&lt;/ul></content></item><item><title>yubikey bio を購入してみた</title><link>/diary/posts/2023/0416/</link><pubDate>Sun, 16 Apr 2023 11:53:13 +0900</pubDate><guid>/diary/posts/2023/0416/</guid><description>0時に寝て7時に起きた。午前中は洗濯して、昨日届いたお肉を焼いて朝ご飯にしながらドラクエタクトやってた。
YubiKey Bio の購入 デスクトップマシンが不調だった1-2ヶ月ほど m2 macbook air でお仕事をしていた。デスクトップマシンと比べて明らかに便利だったことがある。1password にログインするときに os のシステムアカウントも利用できて、具体的には指紋認証によりパスワード入力を必要としなかった。デフォルトでは2週間ごとにパスワード入力を必要とする設定になっているが、これも無効にすることもできる。パスワードを忘れないように1ヶ月に1回ぐらいは手入力してもよいかもしれない。生体認証はその精度にまだ懸念はあるそうだけど、こういった日常的な認証における用途ならそれほど高い精度を要求しないことに気付いた。私は個人でお仕事しているから日常でオフィスに保管している物理的なデバイスを盗むのは難しい。他にも linux で使える指紋認証のデバイスを探してみた。しかし、現時点では usb の指紋認証デバイスは windows 一択になっていて linux はサポートされていない。YubiKey ぐらいしか、私はみつけることができなかった。
YubiKey Bio - FIDO Edition をオンラインストアで購入した。船便で購入したので届くまで1ヶ月ほどかかる。急ぐものではないので気長に待つ。
YubiKey Bio - FIDO Edition $90 Shipping &amp;amp; handling Economy - 10-20 Working Days - No tracking available $5 Duties, taxes and/or carrier subcharges $14.68 USD 日本にお店がないので輸入扱いで関税がかかるのかな？また会計システムに登録するときに税金の計上方法を調べる必要がありそう。
自分たちでやろうとしないことを他人は助けられない 他社のプロジェクト開発のお手伝いでプロジェクトマネージャーとしてこの半年をマネジメントしてきて分かるようになったことが1つある。米軍がアフガニスタンから撤退するときの方便のようにみかけ、ロシアのウクライナ侵攻のときにウクライナ軍が善戦して西側諸国の支持を得たことでその正しさを再確認できた言葉がある。
バイデン大統領は演説で「当事国の軍隊が戦う意思がないのにアメリカが戦うわけにはいかない」という趣旨を繰り返した。
アフガニスタン崩壊と日本への教訓
2月からプロジェクトの開発遅れがみえていてスケジュール調整している。プロジェクトの開発がうまくいかないことの全責任は私にあることは間違いない。その点には一切の懸念も疑問もない。昨今の働き方改革で有休取得が大事なことも理解していて、平均して取得するなら毎月1-2日休むことになる。それは理解できるが、開発が遅延していても有休で休み、その遅延をマネージャである私が休出して開発を肩代わりするという調整を1ヶ月以上続けてきて、この歪みは開発やプロジェクトにとってよくないということもわかってきた。
私個人のモチベーション管理にも多少の影響はあるが、私は指示されて休出しているわけではなく、自分の目的のためにやっているのでこの影響はそれほど重要ではない。
なにが問題かというとプロダクトオーナーシップを開発者がもたないという点にある。私はお手伝いであるから、いずれいなくなる。周りからどうみえようと最終的にプロダクトオーナーシップは契約形態としてもてない。そして、お手伝い先の開発メンバーがもつようになるのが望ましい。しかし、そういう雰囲気はみえない。これまで他社の人間がマネージャーをやっているようなプロジェクトに私が参加したことがなかったためにそういった視点がなかった。そして、私は自分がイニシアティブをもって開発するプロダクトはすべてプロダクトオーナーシップをもって臨んできた。そのため、開発者に裁量を与えることで必然的にプロダクトオーナーシップをもつようになると信じてきたが、いまのやり方だとそうならない気がしている。なぜならば、放っておいても問題になる前に私が勝手に対応してしまうために開発者のインセンティブやモチベーションを阻害してしまうからだ。
プロジェクトにおけるスケジュールや品質を担保するためにはマネージャーである私が一定の尽力をするのは合理的ではある。一方でそれをやり過ぎることで開発メンバーのプロダクトオーナーシップを遠ざけてしまう。プロダクトオーナーシップをもっていない開発者が休出してまで開発に尽力する意味など普通にはない。仮に私が開発メンバーでもそう思うだろう。昔の上長 がやっていたことをみて私が学んだことを、外部の人間として開発メンバーに教えることはとても難しいことを理解できた。</description><content>&lt;p>0時に寝て7時に起きた。午前中は洗濯して、昨日届いたお肉を焼いて朝ご飯にしながらドラクエタクトやってた。&lt;/p>
&lt;h2 id="yubikey-bio-の購入">YubiKey Bio の購入&lt;/h2>
&lt;p>デスクトップマシンが不調だった1-2ヶ月ほど &lt;a href="/diary/diary/posts/2022/1004/#m2-macbook-air-購入">m2 macbook air&lt;/a> でお仕事をしていた。デスクトップマシンと比べて明らかに便利だったことがある。&lt;a href="https://1password.com/jp/">1password&lt;/a> にログインするときに os のシステムアカウントも利用できて、具体的には指紋認証によりパスワード入力を必要としなかった。デフォルトでは2週間ごとにパスワード入力を必要とする設定になっているが、これも無効にすることもできる。パスワードを忘れないように1ヶ月に1回ぐらいは手入力してもよいかもしれない。生体認証はその精度にまだ懸念はあるそうだけど、こういった日常的な認証における用途ならそれほど高い精度を要求しないことに気付いた。私は個人でお仕事しているから日常でオフィスに保管している物理的なデバイスを盗むのは難しい。他にも linux で使える指紋認証のデバイスを探してみた。しかし、現時点では usb の指紋認証デバイスは windows 一択になっていて linux はサポートされていない。YubiKey ぐらいしか、私はみつけることができなかった。&lt;/p>
&lt;p>&lt;a href="https://www.yubico.com/jp/product/yubikey-bio-series/yubikey-bio/">YubiKey Bio - FIDO Edition&lt;/a> をオンラインストアで購入した。船便で購入したので届くまで1ヶ月ほどかかる。急ぐものではないので気長に待つ。&lt;/p>
&lt;pre tabindex="0">&lt;code>YubiKey Bio - FIDO Edition
$90
Shipping &amp;amp; handling
Economy - 10-20 Working Days - No tracking available
$5
Duties, taxes and/or carrier subcharges
$14.68 USD
&lt;/code>&lt;/pre>&lt;p>日本にお店がないので輸入扱いで関税がかかるのかな？また会計システムに登録するときに税金の計上方法を調べる必要がありそう。&lt;/p>
&lt;h2 id="自分たちでやろうとしないことを他人は助けられない">自分たちでやろうとしないことを他人は助けられない&lt;/h2>
&lt;p>他社のプロジェクト開発のお手伝いでプロジェクトマネージャーとしてこの半年をマネジメントしてきて分かるようになったことが1つある。米軍がアフガニスタンから撤退するときの方便のようにみかけ、ロシアのウクライナ侵攻のときにウクライナ軍が善戦して西側諸国の支持を得たことでその正しさを再確認できた言葉がある。&lt;/p>
&lt;blockquote>
&lt;p>バイデン大統領は演説で「当事国の軍隊が戦う意思がないのにアメリカが戦うわけにはいかない」という趣旨を繰り返した。&lt;/p>
&lt;p>&lt;a href="https://www.jfss.gr.jp/article/1569">アフガニスタン崩壊と日本への教訓&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>2月からプロジェクトの開発遅れがみえていてスケジュール調整している。プロジェクトの開発がうまくいかないことの全責任は私にあることは間違いない。その点には一切の懸念も疑問もない。昨今の働き方改革で有休取得が大事なことも理解していて、平均して取得するなら毎月1-2日休むことになる。それは理解できるが、開発が遅延していても有休で休み、その遅延をマネージャである私が休出して開発を肩代わりするという調整を1ヶ月以上続けてきて、この歪みは開発やプロジェクトにとってよくないということもわかってきた。&lt;/p>
&lt;p>私個人のモチベーション管理にも多少の影響はあるが、私は指示されて休出しているわけではなく、自分の目的のためにやっているのでこの影響はそれほど重要ではない。&lt;/p>
&lt;p>なにが問題かというとプロダクトオーナーシップを開発者がもたないという点にある。私はお手伝いであるから、いずれいなくなる。周りからどうみえようと最終的にプロダクトオーナーシップは契約形態としてもてない。そして、お手伝い先の開発メンバーがもつようになるのが望ましい。しかし、そういう雰囲気はみえない。これまで他社の人間がマネージャーをやっているようなプロジェクトに私が参加したことがなかったためにそういった視点がなかった。そして、私は自分がイニシアティブをもって開発するプロダクトはすべてプロダクトオーナーシップをもって臨んできた。そのため、開発者に裁量を与えることで必然的にプロダクトオーナーシップをもつようになると信じてきたが、いまのやり方だとそうならない気がしている。なぜならば、放っておいても問題になる前に私が勝手に対応してしまうために開発者のインセンティブやモチベーションを阻害してしまうからだ。&lt;/p>
&lt;p>プロジェクトにおけるスケジュールや品質を担保するためにはマネージャーである私が一定の尽力をするのは合理的ではある。一方でそれをやり過ぎることで開発メンバーのプロダクトオーナーシップを遠ざけてしまう。プロダクトオーナーシップをもっていない開発者が休出してまで開発に尽力する意味など普通にはない。仮に私が開発メンバーでもそう思うだろう。&lt;a href="/diary/diary/posts/2023/0310/">昔の上長&lt;/a> がやっていたことをみて私が学んだことを、外部の人間として開発メンバーに教えることはとても難しいことを理解できた。&lt;/p></content></item><item><title>rabbitmq 再び</title><link>/diary/posts/2022/1208/</link><pubDate>Thu, 08 Dec 2022 08:18:34 +0900</pubDate><guid>/diary/posts/2022/1208/</guid><description>0時に寝て3時に起きて6時半に起きた。前日あまり寝てなかったから普段よりよく眠れた。
rabbitmq の認証 たまたまなのだけど、前のお仕事でも rabbitmq を使っていて、いまのお仕事でも rabbitmq を使っている。私の中では kafka のエコシステムに感銘を受けたので私が技術選定してよいなら kafka を使っていきたいところだけど、rabbitmq も人気があってすごいなと思う。インフラを触っていて rabbitmq の認証をしていないことに気付いた。rabbitmq の docker image を使うとデフォルトで guest/guest のユーザーが作られる。
If you wish to change the default username and password of guest / guest, you can do so with the RABBITMQ_DEFAULT_USER and RABBITMQ_DEFAULT_PASS environmental variables. These variables were available previously in the docker-specific entrypoint shell script but are now available in RabbitMQ directly.
おそらくメッセージのやり取りを通信するときも何も指定しなかったら guest ユーザーとして扱っているのかな？通信するときの RabbitMQ URI Specification によると、amqp://user:pass@host:10000/vhost のような、昔ながらの uri にユーザー／パスワードを埋め込むような認証になる。このやり方だと uri 自体が credentials になってしまって運用の使い勝手が悪くなってしまうものの、アプリケーションの変更は必要ないというメリットもある。おそらく歴史的に認証は後付けで追加されたのかな？ともかく実際の運用だとユーザー／パスワードでアクセス制御を行うだろうと想定されるので気付いたタイミングで開発環境の docker image の設定と uri の変更を行った。</description><content>&lt;p>0時に寝て3時に起きて6時半に起きた。前日あまり寝てなかったから普段よりよく眠れた。&lt;/p>
&lt;h2 id="rabbitmq-の認証">rabbitmq の認証&lt;/h2>
&lt;p>たまたまなのだけど、前のお仕事でも rabbitmq を使っていて、いまのお仕事でも rabbitmq を使っている。私の中では &lt;a href="https://kafka.apache.org/">kafka&lt;/a> のエコシステムに感銘を受けたので私が技術選定してよいなら kafka を使っていきたいところだけど、rabbitmq も人気があってすごいなと思う。インフラを触っていて rabbitmq の認証をしていないことに気付いた。&lt;a href="https://hub.docker.com/_/rabbitmq">rabbitmq の docker image&lt;/a> を使うとデフォルトで guest/guest のユーザーが作られる。&lt;/p>
&lt;blockquote>
&lt;p>If you wish to change the default username and password of guest / guest, you can do so with the RABBITMQ_DEFAULT_USER and RABBITMQ_DEFAULT_PASS environmental variables. These variables were available previously in the docker-specific entrypoint shell script but are now available in RabbitMQ directly.&lt;/p>
&lt;/blockquote>
&lt;p>おそらくメッセージのやり取りを通信するときも何も指定しなかったら guest ユーザーとして扱っているのかな？通信するときの &lt;a href="https://www.rabbitmq.com/uri-spec.html">RabbitMQ URI Specification&lt;/a> によると、&lt;code>amqp://user:pass@host:10000/vhost&lt;/code> のような、昔ながらの uri にユーザー／パスワードを埋め込むような認証になる。このやり方だと uri 自体が credentials になってしまって運用の使い勝手が悪くなってしまうものの、アプリケーションの変更は必要ないというメリットもある。おそらく歴史的に認証は後付けで追加されたのかな？ともかく実際の運用だとユーザー／パスワードでアクセス制御を行うだろうと想定されるので気付いたタイミングで開発環境の docker image の設定と uri の変更を行った。&lt;/p>
&lt;h2 id="時事ネタの気軽な雑談会">時事ネタの気軽な雑談会&lt;/h2>
&lt;p>&lt;a href="https://play2learn.connpass.com/event/267936/">【おはなし会】CEXだって安全にできるもん&lt;/a> に参加した。ちょうさんは fin-py のイベントで何度か発表を聞いたことがある。データサイエンス系のお仕事をされているのかな？&lt;a href="/diary/diary/posts/2022/1113/">ftx 事件&lt;/a> をうけて ethereum の創始者である vitalik buterin 氏がブログに投稿したアルゴリズムの解説をされていた。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://vitalik.ca/general/2022/11/19/proof_of_solvency.html">Having a safe CEX: proof of solvency and beyond&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>取引所の不正を防ぐための仕組みとして、それぞれの口座の残高を公開しなくても merkle tree とハッシュ関数をうまく使って、取引所が実際に管理している残高とユーザーの残高が一致しているかをチェックできるような、そんなアルゴリズムだったと思う。ちゃんとブログの記事を読んでないけど、ちょうさんの解説を聞く分にはアルゴリズムはそう難しくないように思えた。そんなすごい仕組みじゃなくて、簡易的に大きな計算コストもなく全体の残高があっていることのおおよそのチェックはできますよといったもの。&lt;/p>
&lt;p>イベントが始まる前にちょうさんが大学の研究室にいた頃、研究室へ行くと同僚がいて気軽に新しい技術の話しができたけど、社会人になるとそういう機会が減ってしまったという。時事ネタを気軽に雑談できるイベントがあればという話しをされていて私も共感できた。&lt;/p></content></item><item><title>backlog の認可の仕組み</title><link>/diary/posts/2022/0329/</link><pubDate>Tue, 29 Mar 2022 07:19:00 +0900</pubDate><guid>/diary/posts/2022/0329/</guid><description>0時に寝て6時に起きた。
backlog の oauth 2.0 の仕組み ユーザー単位の API キーの他、oauth 2.0 の認可の仕組みもある。OAuth Grant Types は Authorization Code と Refresh Token の2つをサポートしている。
https://developer.nulab.com/ja/docs/backlog/auth/ https://backlog.com/developer/applications/ 手順はざっくりこんな感じ。
開発者向けのサイトからアプリケーションを作成して認可コードのリクエストを送る。
https://YOUR-SPACE.backlog.com/OAuth2AccessRequest.action?response_type=code&amp;amp;client_id=xxx&amp;amp;redirect_uri=http://localhost:18080/callback リダイレクト先に query='code=zzz' な認可コードが届く。それを使ってアクセストークンを取得する。
{&amp;#39;access_token&amp;#39;: &amp;#39;xxx&amp;#39;, &amp;#39;expires_in&amp;#39;: 3599, &amp;#39;refresh_token&amp;#39;: &amp;#39;xxx&amp;#39;, &amp;#39;token_type&amp;#39;: &amp;#39;Bearer&amp;#39;} 有効期限が1時間のアクセストークンを取得できる。次のようにして認証をパスできる。
$ curl -s -H &amp;#34;Authorization: Bearer xxx&amp;#34; &amp;#39;https://YOUR-SPACE.backlog.com/api/v2/space&amp;#39; 基本的にはユーザー単位の認証しかなくてアプリケーションアカウントの運用はできないみたい。backlog の課金プランをみると、基本的にはユーザー無制限っぽいのでアプリケーションアカウントを一般ユーザーで作成すれば、運用上問題にならないからアプリケーションアカウントを設けていないのではないかと思う。お手伝い先の管理者にインテグレーション向けの専用ユーザーを作成して API キーを github の secrets に登録してほしいという依頼を出した。</description><content>&lt;p>0時に寝て6時に起きた。&lt;/p>
&lt;h2 id="backlog-の-oauth-20-の仕組み">backlog の oauth 2.0 の仕組み&lt;/h2>
&lt;p>ユーザー単位の API キーの他、oauth 2.0 の認可の仕組みもある。&lt;a href="https://oauth.net/2/grant-types/">OAuth Grant Types&lt;/a> は Authorization Code と Refresh Token の2つをサポートしている。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://developer.nulab.com/ja/docs/backlog/auth/">https://developer.nulab.com/ja/docs/backlog/auth/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://backlog.com/developer/applications/">https://backlog.com/developer/applications/&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>手順はざっくりこんな感じ。&lt;/p>
&lt;p>開発者向けのサイトからアプリケーションを作成して認可コードのリクエストを送る。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>https://YOUR-SPACE.backlog.com/OAuth2AccessRequest.action?response_type&lt;span style="color:#f92672">=&lt;/span>code&amp;amp;client_id&lt;span style="color:#f92672">=&lt;/span>xxx&amp;amp;redirect_uri&lt;span style="color:#f92672">=&lt;/span>http://localhost:18080/callback
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>リダイレクト先に &lt;code>query='code=zzz'&lt;/code> な認可コードが届く。それを使ってアクセストークンを取得する。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{&lt;span style="color:#960050;background-color:#1e0010">&amp;#39;access_token&amp;#39;:&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;#39;xxx&amp;#39;,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">&amp;#39;expires_in&amp;#39;:&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">3599,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">&amp;#39;refresh_token&amp;#39;:&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;#39;xxx&amp;#39;,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">&amp;#39;token_type&amp;#39;:&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">&amp;#39;Bearer&amp;#39;&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>有効期限が1時間のアクセストークンを取得できる。次のようにして認証をパスできる。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ curl -s -H &lt;span style="color:#e6db74">&amp;#34;Authorization: Bearer xxx&amp;#34;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;https://YOUR-SPACE.backlog.com/api/v2/space&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>基本的にはユーザー単位の認証しかなくてアプリケーションアカウントの運用はできないみたい。backlog の課金プランをみると、基本的にはユーザー無制限っぽいのでアプリケーションアカウントを一般ユーザーで作成すれば、運用上問題にならないからアプリケーションアカウントを設けていないのではないかと思う。お手伝い先の管理者にインテグレーション向けの専用ユーザーを作成して API キーを github の secrets に登録してほしいという依頼を出した。&lt;/p></content></item><item><title>github apps を調べた</title><link>/diary/posts/2022/0301/</link><pubDate>Tue, 01 Mar 2022 07:56:36 +0900</pubDate><guid>/diary/posts/2022/0301/</guid><description>23時に寝て5時半に起きた。何度か夜中にも起きた。起きてからドラクエタクトやってた。
oauth apps と github apps いまお仕事で ci/cd の改善をやっていて、その一環としてリポジトリをまたがったパイプライン処理を検討している。 ci/cd で使うような認可の仕組みとして github には oauth apps と github apps の2種類がある。
Building OAuth Apps Building GitHub Apps 私はどちらも全く関わったことがなかったので、仕組みがイメージできる oauth apps を使えばよいのだろうと調べ始めた。しかし、一通り調べてみて会社の開発における ci/cd に使うなら github apps の方が適していることがわかった。両者がどう違うのかもドキュメントに記載されている。最初にこのドキュメントを読めば oauth apps を調査する必要はなかった。
Differences between GitHub Apps and OAuth Apps 具体的には、oauth apps は user の権限を認可する仕組みで、github apps は organization の権限を認可する仕組みと言える。github apps も oauth によるユーザー認証もできる上にアプリ自身の認証もできる。さらにアクセスできるリポジトリも制限できることから github actions などで、特定のリポジトリに対してのみアクセス可能なトークンを取得するには github apps の方が向くというわけだ。oauth でユーザーが認可するときに scope を指定するが、その scope を organization が設定できるといったところが github apps と oauth との違いにみえる。取得できる token の有効期限にもその考え方の違いが出ている。</description><content>&lt;p>23時に寝て5時半に起きた。何度か夜中にも起きた。起きてからドラクエタクトやってた。&lt;/p>
&lt;h2 id="oauth-apps-と-github-apps">oauth apps と github apps&lt;/h2>
&lt;p>いまお仕事で ci/cd の改善をやっていて、その一環としてリポジトリをまたがったパイプライン処理を検討している。
ci/cd で使うような認可の仕組みとして github には oauth apps と github apps の2種類がある。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.github.com/en/developers/apps/building-oauth-apps">Building OAuth Apps&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.github.com/en/developers/apps/building-github-apps">Building GitHub Apps&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>私はどちらも全く関わったことがなかったので、仕組みがイメージできる oauth apps を使えばよいのだろうと調べ始めた。しかし、一通り調べてみて会社の開発における ci/cd に使うなら github apps の方が適していることがわかった。両者がどう違うのかもドキュメントに記載されている。最初にこのドキュメントを読めば oauth apps を調査する必要はなかった。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.github.com/en/developers/apps/getting-started-with-apps/differences-between-github-apps-and-oauth-apps">Differences between GitHub Apps and OAuth Apps&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>具体的には、oauth apps は user の権限を認可する仕組みで、github apps は organization の権限を認可する仕組みと言える。github apps も oauth によるユーザー認証もできる上にアプリ自身の認証もできる。さらにアクセスできるリポジトリも制限できることから github actions などで、特定のリポジトリに対してのみアクセス可能なトークンを取得するには github apps の方が向くというわけだ。oauth でユーザーが認可するときに scope を指定するが、その scope を organization が設定できるといったところが github apps と oauth との違いにみえる。取得できる token の有効期限にもその考え方の違いが出ている。&lt;/p>
&lt;ul>
&lt;li>oauth apps
&lt;ul>
&lt;li>ユーザー/デバイス認証
&lt;ul>
&lt;li>認可コード: 15分&lt;/li>
&lt;li>アクセストークン: 無期限&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>github apps
&lt;ul>
&lt;li>installation 認証
&lt;ul>
&lt;li>認可jwt: 10分&lt;/li>
&lt;li>installation トークン: 1時間&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ユーザー/デバイス認証
&lt;ul>
&lt;li>認可コード: 15分&lt;/li>
&lt;li>アクセストークン: 8時間&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></content></item></channel></rss>