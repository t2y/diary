<!doctype html><html lang=en>
<head>
<title>dapr :: forest nook</title>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content>
<meta name=keywords content>
<meta name=robots content="noodp">
<link rel=canonical href=/diary/tags/dapr/>
<link rel=stylesheet href=/diary/assets/style.css>
<link rel=stylesheet href=/diary/assets/green.css>
<link rel=stylesheet href=/diary/style.css>
<link rel=apple-touch-icon href=/diary/img/apple-touch-icon-192x192.png>
<link rel="shortcut icon" href=/diary/favicon.ico>
<meta name=twitter:card content="summary">
<meta name=twitter:site content="t2y">
<meta name=twitter:creator content>
<meta property="og:locale" content="en">
<meta property="og:type" content="website">
<meta property="og:title" content="dapr">
<meta property="og:description" content>
<meta property="og:url" content="/diary/tags/dapr/">
<meta property="og:site_name" content="forest nook">
<meta property="og:image" content="/diary/favicon.ico">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">
<link href=/diary/tags/dapr/index.xml rel=alternate type=application/rss+xml title="forest nook">
</head>
<body class=green>
<div class="container full headings--one-size">
<header class=header>
<div class=header__inner>
<div class=header__logo>
<a href=/diary>
<div class=logo>
forest nook
</div>
</a>
</div>
<div class=menu-trigger>menu</div>
</div>
<nav class=menu>
<ul class="menu__inner menu__inner--desktop">
<li><a href=/diary/about>自己紹介</a></li>
<li><a href=/diary/dates>月別一覧</a></li>
<li><a href=/diary/tags>タグ一覧</a></li>
</ul>
<ul class="menu__inner menu__inner--mobile">
<li><a href=/diary/about>自己紹介</a></li>
<li><a href=/diary/dates>月別一覧</a></li>
<li><a href=/diary/tags>タグ一覧</a></li>
</ul>
</nav>
</header>
<div class=content>
<div class=posts>
<div class="post on-list">
<h1 class=post-title>
<a href=/diary/posts/2021/1201/>師走入り</a>
</h1>
<div class=post-meta>
<span class=post-date>
2021-12-01
</span>
</div>
<span class=post-tags>
#<a href=/diary/tags/morning-activity/>morning activity</a>&nbsp;
#<a href=/diary/tags/dapr/>dapr</a>&nbsp;
#<a href=/diary/tags/bizpy/>bizpy</a>&nbsp;
</span>
<div class=post-content>
<p>1時から1時間ほど仮眠をとって2時から4時過ぎまで作業して帰ってお風呂に入ってそのまま6時から <a href=https://kobe-sannomiya-dev.connpass.com/event/232426/>【三宮.dev オンライン】リモート朝活もくもく会</a> の朝活に参加した。30分ほど雑談して眠くなって7時過ぎから9時前まで寝てた。</p>
<h2 id=dapr-の-pubsub-の-dead-letter-サポート>dapr の pubsub の dead letter サポート</h2>
<p>お仕事で dapr を触っている。pubsub で dead letter queue の仕組みを導入しようとしているが、<a href=https://github.com/dapr/dapr/issues/2217>PubSub&rsquo;s DeadLetter Topic #2217</a> によると v1.6 (2022年1月20日リリース予定) のマイルストーンになっている。本当にその予定ならそろそろベータ版が実装されていて、開発ブランチあったらテストしようかと考えていた。調べてたら rabbitmq はすでに v1.5 で dead letter のサポートがマージされているのを発見した。</p>
<ul>
<li><a href=https://github.com/dapr/docs/pull/1844>Add dead letter support for RabbitMQ pubsub #1844</a></li>
</ul>
<p>たまたま、いま使っている pubsub も rabbitmq だった。ドキュメントをみたら確かにその設定が追加されている。</p>
<blockquote>
<p><a href=https://docs.dapr.io/reference/components-reference/supported-pubsub/setup-rabbitmq/>dapr RabbitMQ</a></p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Required</th>
<th>Details</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>enableDeadLetter</td>
<td>N</td>
<td>Enable forwarding Messages that cannot be handled to a dead-letter topic. Defaults to &ldquo;false&rdquo;</td>
<td>&ldquo;true&rdquo;, &ldquo;false&rdquo;</td>
</tr>
<tr>
<td>maxLen</td>
<td>N</td>
<td>The maximum number of messages of a queue and its dead letter queue (if dead letter enabled). If both maxLen and maxLenBytes are set then both will apply; whichever limit is hit first will be enforced. Defaults to no limit.</td>
<td>&ldquo;1000&rdquo;</td>
</tr>
<tr>
<td>maxLenBytes</td>
<td>N</td>
<td>Maximum length in bytes of a queue and its dead letter queue (if dead letter enabled). If both maxLen and maxLenBytes are set then both will apply; whichever limit is hit first will be enforced. Defaults to no limit.</td>
<td>&ldquo;1048576&rdquo;</td>
</tr>
</tbody>
</table>
</blockquote>
<p>enableDeadLetter=true に設定して、適当にエラーが発生しそうなリクエストを作って dead letter にメッセージが入るかどうかを検証してた。ひとまず dead letter にメッセージが入ること自体は確認できた。</p>
<h2 id=bizpy-勉強会>bizpy 勉強会</h2>
<p><a href=https://bizpy.connpass.com/event/229239/>Python で Slack のインテグレーションをやってみる勉強会 #3</a> を開催した。月曜日から2時間もあればできる資料作成をだらだら先送りしていて夜中に作った。なんか体調を崩しているのかもしれない。たまたま勉強会の前にせらさんから激励のコメントをいただいて嬉しかった。</p>
<blockquote>
<p>今日の分も含めコンテンツ拝見しましたが、素晴らしいですね</p>
</blockquote>
<p>私見だけど、slack インテグレーションで調べものをしているとせらさんの記事や issue のやり取りをみかけることが多い。twitter で slack インテグレーションに関してつぶやくと100%せらさんからレスポンスがある (個人の経験談) 。過去に私は外資の ISV で働きたいと思って活動したこともあったけど、せらさんをみていて自分のレベルでは無理だったなと得心がいった。なにがすごいって、bizpy の勉強会のようなところにもわざわざやってきて、講師にコメントしたりアドバイスしてくれるんだからね。</p>
<p>2ヶ月に渡り、slack インテグレーションのチュートリアルレベルの記事を実際に設定してみて、サンプルコード書いてみて、動かしてみて、slack でどんなことができそうかの理解を深めることができた。今回の内容はビジネスパーソン向けではなかったのでちょっと敷居が高かったかもしれないが、全3回でやり切ることができてよかった。終わってから運営に新たにわたなべさんが加わったことを参加者に紹介しつつ、次回の企画について雑談していた。次回はわたなべさんから機械学習入門のような勉強会をしてもらうことに決まった。</p>
</div>
</div>
<div class="post on-list">
<h1 class=post-title>
<a href=/diary/posts/2021/1105/>調べものだらけ</a>
</h1>
<div class=post-meta>
<span class=post-date>
2021-11-05
</span>
</div>
<span class=post-tags>
#<a href=/diary/tags/morning-activity/>morning activity</a>&nbsp;
#<a href=/diary/tags/book/>book</a>&nbsp;
#<a href=/diary/tags/rabbitmq/>rabbitmq</a>&nbsp;
#<a href=/diary/tags/dapr/>dapr</a>&nbsp;
</span>
<div class=post-content>
<p>1時半に寝て6時に起きた。昨日の夜はウォーキングして (朝活あるから) すぐに寝たんで早く起きた分、朝からストレッチをしてた。今週はバタバタしていてあまりストレッチできてない。</p>
<h2 id=朝活-ミクロ経済学入門の入門>朝活: ミクロ経済学入門の入門</h2>
<p><a href="https://www.youtube.com/watch?v=33vXvmnAHq0">[金朝ツメトギ] 2021-11-05 AM 6 金曜朝6時開催のもくもく会</a> で第7章の独占と寡占を読んだ。用語を次にまとめる。</p>
<ul>
<li>プライステイカー: 生産量を増やしたり減らしたりしても価格に影響を与えられない会社</li>
<li>完全市場: すべての会社がプライステイカーである市場</li>
<li>不完全市場: 完全市場ではない市場、プライステイカーではない会社がいる</li>
<li>独占市場: 1つの独占企業だけが存在する市場</li>
<li>クルーノー寡占市場: 同じ財を生産する少数の会社の総生産量から市場の価格が決まる市場
<ul>
<li>寡占: 少数の企業がいる市場
<ul>
<li>複占: 企業が2つだけの市場</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>前に出てきた市場均衡の話から、供給量を下げると価格が上昇する。生産者余剰がが大きくなり、生産者は得をする。実際にあった事例として、2016年に石油輸出機構 (OPEC) が石油の減産に合意して価格が上昇した。2012年に豊作だった歳に値崩れが起きるのをおそれて、全国農業組合連合会は価格を上げるために農家に野菜の廃棄処分を要請した。</p>
<p>独占市場にいる会社は高い価格で高い利潤を得ることはできるが、やがて価格競争を仕掛けてくる新規参入者を招き、長期的な利益を低めてしまう懸念がある。一方で高品質な財を低い利潤で販売していると、新規参入者が現れずに長期的な利益を得られる可能性がある。一概にどちらが正しいとは言えない。こうした状況を端的に描く <strong>展開型ゲーム</strong> を考えると、財を高値にするか安値にするかの思考実験ができるう。 <strong>ゲームツリー</strong> という図でこのゲームを表している。</p>
<figure><img src=/diary/img/2021/1105_game-tree.png>
</figure>
<p>A は安値を選び、B が参入しないという選択の組み合わせは、「自分がこう選択したら相手はこう選択してくる」とプレイヤーが予想して、そのうえで自分にとって最も利潤が高まる選択をする状況を表している。これを <strong>サブゲーム完全均衡</strong> の結果と呼ぶ。また、このような推論のやり方を <strong>逆向き帰納法 (バックワード・インダクション)</strong> と呼ぶ。サブゲーム完全均衡の結果は逆向き帰納法により求められる。</p>
<h2 id=rabbitmq-の-dead-letter-exchange-の調査>RabbitMQ の dead letter exchange の調査</h2>
<p>昨日の続き。RabbitMQ には exchange という概念がある。私が過去に使ったメッセージキュー (Kafka, AWS SQS) にはない概念でトピックをグルーピングしたり、メッセージのルーティングを制御する仕組みになる。普通のメッセージキューではデッドレターキューと呼ばれるものが RabbitMQ だと <a href=https://www.rabbitmq.com/dlx.html>Dead Letter Exchanges</a> になる。ドキュメントの概要はこんな感じ。</p>
<blockquote>
<p>次のイベントが発生したときに &ldquo;デッドレター&rdquo; とみなす。</p>
<ul>
<li>consumer が basic.reject または requeue=false の basic.nack を ack で返したとき</li>
<li>メッセージの TTL の期限切れになったとき</li>
<li>queue の最大長さを超えてメッセージが drop されたとき</li>
</ul>
<p>注意事項として queue の有効期限が切れても queue 内のメッセージはデッドレターとならない。</p>
<h4 id=設定方法>設定方法</h4>
<p>デッドレター exchange (DLXs) は普通の exchange であり、普通に宣言して通常の種別をセットする。任意の queue に対して2通りの設定方法がある。</p>
<ul>
<li>クライアント: queue の引数を使って定義する</li>
<li>サーバー: ポリシーを使って定義する</li>
</ul>
<p>詳細は割愛。</p>
<h4 id=ルーティング>ルーティング</h4>
<p>デッドレターメッセージのルーティングは、次のどちらかで行われる。</p>
<ul>
<li>デッドレターの queue に routingKey が設定されていればそれを使う</li>
<li>デッドレターの queue に routingKey が設定されていなければ、オリジナルのメッセージが publish されたときの routingKey を使う</li>
</ul>
<p>例えば、foo という routingKey をもつ exchange にメッセージを publish して、そのメッセージがデッドレターになった場合、foo という routingKey をもつデッドレターの exchange に publish される。もしそのメッセージが x-dead-letter-routing-key を bar にセットした queue に届いた場合は、そのメッセージは bar という routingKey をもつデッドレター exchange に publish される。</p>
<p>queue に特定の routingKey が設定されていなかった場合、その queue のメッセージは、すべてオリジナルの routingKey でデッドレター化されることに注意してください。これには CC および BCC ヘッダによって追加された routingKey も含む (詳細は割愛) 。</p>
<p>デッドレターメッセージが循環する可能性がある。例えば、queue がデッドレター用のルーティングキーを指定せずに、デフォルトの exchange にメッセージをデッドレターした場合などに起こる。このとき同じ queue に2回届いたメッセージは no rejections in the entire cycle だった場合にドロップされる。</p>
<h4 id=安全性>安全性</h4>
<p>デッドレターメッセージは内部的に publisher confirm を行わずに re-publish される。クラスタ環境の rabbitmq でデッドレターキューを使ったとしても安全性は保証されない。メッセージはデッドレターキューの対象の queue に publish された後でオリジナルの queue からは削除される。このときに対象の queue が受け取れなければメッセージがなくなってしまう可能性がある。</p>
<h4 id=デッドレターメッセージの副作用>デッドレターメッセージの副作用</h4>
<p>デッドレターメッセージはヘッダーを変更する。</p>
<ul>
<li>exchange の名前がデッドレター exchange の名前に置き換わる</li>
<li>routingKey がデッドレターキューの routingKey に置き換わる可能性がある</li>
<li>↑ が起きると、CC ヘッダーが削除される</li>
<li>Sender-selected Distribution ごとに BCC ヘッダーは削除される</li>
</ul>
<p>デッドレターの処理では x-death という名前の配列を、それぞれのデッドレタリングされたメッセージのヘッダに追加する。この配列には {queue, reason} のペアで識別される各デッドレタリングイベントのエントリが含まれる。詳細は割愛。</p>
</blockquote>
<h2 id=dapr-の調査>dapr の調査</h2>
<p><a href=https://docs.dapr.io/>dapr</a> について調べた。dapr は分散システム (アプリケーション) の複雑さを解決することを目的としている。様々なミドルウェア (分散システム) とのやり取りを http/grpc の api 呼び出し経由にして、その詳細を隠蔽する。ミドルウェアの上位に抽象化レイヤーを設けて統合的なインターフェースを提供したり、それぞれのミドルウェアにおける設定や運用の面倒なことなどを簡略化してくれる。サイドカーパターンを採用しているので言語に依らず、アプリケーションに dapr のコードを書く必要もない。dapr cli をインストールして dapr init すると docker で dapr プロセスが動いて、それだけで dapr にリクエストできるようになる。使い始めの学習コストは低いし、デプロイも簡単だし、意図している目的もわかりやすい。マイクロソフト社がスポンサーしていてプロジェクトの運営も安定してそうだし、おもしろいツールだと思う。</p>
<h2 id=k8s-の調査>k8s の調査</h2>
<p>せっかくの機会なのでちゃんと勉強することにした。今日は <a href=https://github.com/kubernetes/minikube>minikube</a> の <a href=https://minikube.sigs.k8s.io/docs/start/>Get Started!</a> やっただけ。</p>
</div>
</div>
<div class=pagination>
<div class=pagination__buttons>
</div>
</div>
</div>
</div>
<footer class=footer>
<div class=footer__inner>
<div class="copyright copyright--user">
<span>© 2021 Tetsuya Morimoto</span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span>
</div>
</div>
</footer>
<script src=/diary/assets/main.js></script>
<script src=/diary/assets/prism.js></script>
</div>
</body>
</html>