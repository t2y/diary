<!doctype html><html lang=en><head><title>Packaging :: </title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=/diary/tags/packaging/><link rel=stylesheet href=/diary/styles.css><link rel=stylesheet href=/diary/style.css><link rel="shortcut icon" href=/diary/favicon.ico><meta name=twitter:card content="summary"><meta name=twitter:site content="t2y"><meta name=twitter:creator content><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:title" content="Packaging"><meta property="og:description" content><meta property="og:url" content="/diary/tags/packaging/"><meta property="og:site_name" content><meta property="og:image" content="/diary/favicon.ico"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><link href=/diary/tags/packaging/index.xml rel=alternate type=application/rss+xml title></head><body class=green><div class="container full headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/diary><div class=logo>forest nook</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/diary/about>自己紹介</a></li><li><a href=/diary/dates>月別一覧</a></li><li><a href=/diary/tags>タグ一覧</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/diary/about>自己紹介</a></li><li><a href=/diary/dates>月別一覧</a></li><li><a href=/diary/tags>タグ一覧</a></li></ul></nav></header><div class=content><h1>Posts for: #Packaging</h1><div class=posts><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2024/0608/>オフラインカンファレンスへの参加</a></h1><div class=post-meta><time class=post-date>2024-06-08</time></div><span class=post-tags>#<a href=/diary/tags/go/>go</a>&nbsp;
#<a href=/diary/tags/event/>event</a>&nbsp;
#<a href=/diary/tags/packaging/>packaging</a>&nbsp;
#<a href=/diary/tags/health/>health</a>&nbsp;</span><div class=post-content><p>今日の運動は腹筋ローラー,腕立て,スクワット,散歩,ハンドグリップをした。統計を <a href="https://docs.google.com/spreadsheets/d/1bg85QtM-LciUgey8I79uI7vW2PEwsP6TVdeIRVkACBg/edit?usp=sharing">運動の記録</a> にまとめる。</p><p>神戸に戻ってきてから軽く公園へ行って運動しようと思っていたら22時頃から雨降りで行けなかった。オフィスで事務作業や片付けなどをしていた。</p><h2 id=久しぶりのオフラインカンファレンス>久しぶりのオフラインカンファレンス</h2><p>たまたま出張の週末にかさなっていたので <a href=https://gocon.jp/2024/>Go Conference 2024</a> に参加してきた。いつもはオンライン参加していたが、今回はオフラインでしかやらないという。朝ホテルでのんびりしていたら時間がぎりぎりになってしまって、10時半からの tenntenn さんの発表が始まる10分前ぐらいに会場へ着いた。時間的にはちょうどよかった。次の 1.23 でリリース予定のイテレーターについての話しを聞いた。さすがのクォリティだったと思う。</p><ul><li><a href="https://docs.google.com/presentation/d/1oY8pIpcB9t0C7siyQvj-ha5PLHTP_pdD-LA9uL2CaTU/edit?usp=sharing">イテレータによってGoはどう変わるのか</a></li></ul><p>python の generator に近い概念のようにみえる。まだ自分でイテレーターを実装したことがないので seq 関数というのがちょっと腹落ちしていない。お手伝い先の次の開発フェーズで 1.23 にアップデートするだろうからそのときにいろいろ試してみることになると思う。イテレーターは重要な概念なのでチーム勉強会などでメンバーとしっかり情報共有してもよいかもしれない。</p><p>他の発表もどれもレベルが高くておもしろかったのだが、私が関心をもったものを1つあげると go module のバージョン管理の仕組みの解説が勉強になった。</p><ul><li><a href="https://docs.google.com/presentation/d/1X5dXShWTmjhQbXH7vXHnTLJ5Tca7QhU4Pq1YugGiIHs/edit#slide=id.p">試してわかるGo ModulesとMinimal Version Selection</a></li></ul><p>依存先のモジュールのどのバージョンを使うかを決定するアルゴリズムを Minimal Version Selection (MVS) と呼ぶ。ライブラリをアップデートする経緯によってはサードパーティライブラリのバージョンの組み合わせは一意に決定されないという振る舞いを、あまり意識する機会はないだろうけれど、開発者として知っておく必要がある。</p><h2 id=過去の人間ドックの結果>過去の人間ドックの結果</h2><p><a href=/diary/posts/2024/0603/#過去の健康診断の記録>月曜日に手配しておいた</a> 5年前の人間ドックの結果の冊子が届いていた。5年前の時点で体重は80kgあったことがわかった。それからコロナ禍になって一気に90kgまで太ってしまったようにみえる。これでスプレッドシートに過去の健康診断の数値はプロットできた。5年前までの数値を見比べてみると、体重は10kgぐらいの幅で増えたり減ったりしているものの、血液検査や他の内蔵の数値などはあまり変化がないようにみえる。あとは今回の結果が送られてくるのを待つのみ。楽しみ。</p></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2024/0325/>ordered map という適当な粒度の課題</a></h1><div class=post-meta><time class=post-date>2024-03-25</time></div><span class=post-tags>#<a href=/diary/tags/go/>go</a>&nbsp;
#<a href=/diary/tags/design/>design</a>&nbsp;
#<a href=/diary/tags/packaging/>packaging</a>&nbsp;</span><div class=post-content><p>1時に寝て4時に起きて CPAP 治療忘れて寝ていたことに気付いて、装着してまた寝て6時半に起きた。</p><p>今日の運動は背筋をした。統計を <a href="https://docs.google.com/spreadsheets/d/1bg85QtM-LciUgey8I79uI7vW2PEwsP6TVdeIRVkACBg/edit?usp=sharing">運動の記録</a> にまとめる。</p><h2 id=orderedmap-ライブラリ>orderedmap ライブラリ</h2><p>json のオブジェクトの属性を意図した順番に並び替えたいという要件があって <a href=/diary/posts/2024/0308/#ordered-map-の開発>適当なライブラリをみつけられなくて</a> 最終的には自分で実装した。そのときに参考にしたモジュールではネストした配列やオブジェクトの順番を維持できないことに気付いて、どうせ実装するなら json の marshal/unmarshal の処理を完璧に実装しようと思って、再度フルスクラッチで作り直した。要は <a href=https://docs.python.org/ja/3/library/collections.html#collections.OrderedDict>python の OrderedDict</a> のようなものの go 版になる。</p><p><code>orderedmap</code> というキーワードで検索するといくつもオレオレの実装がみつかる。次の3つを参考にしながら、私も自分の思う「ぼくのかんがえたさいきょうの orderedmap」 を作ってみた。</p><ul><li><a href=https://github.com/iancoleman/orderedmap>https://github.com/iancoleman/orderedmap</a></li><li><a href=https://github.com/elliotchance/orderedmap>https://github.com/elliotchance/orderedmap</a></li><li><a href=https://github.com/mroth/orderedmap>https://github.com/mroth/orderedmap</a></li></ul><p>実際に作ったものが次になる。</p><ul><li><a href=https://github.com/kazamori/orderedmap>github.com/kazamori/orderedmap</a></li></ul><p>インストール</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ go get -u github.com/kazamori/orderedmap
</span></span></code></pre></div><p>go のモジュールは <a href=https://go.dev/ref/mod#goproxy-protocol>GOPROXY protocol</a> を介してプロキシサーバーから取得される。デフォルトでは <code>proxy.golang.org</code> が設定されている。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ go env | grep GOPROXY
</span></span><span style=display:flex><span>GOPROXY<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;https://proxy.golang.org,direct&#39;</span>
</span></span></code></pre></div><p>プロキシサーバーではモジュールがキャッシュされているため、利用する側でリビジョンを更新しようとしても短い間隔だとすぐには反映されない。プロキシサーバーに存在しないモジュールのリビジョンを取得したい場合は <code>GOPROXY</code> の環境変数でダイレクトモードに変更する。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ GOPROXY<span style=color:#f92672>=</span>direct go get -u github.com/kazamori/orderedmap
</span></span></code></pre></div><p>generics 対応して汎用の map を扱えるのがちょっとお気に入りなところ。他人が作ったライブラリを使うことはできるけど、プログラミング勉強として自分で実装してみるのもよい気はする。ちょうど <a href=https://kyotogo.connpass.com/event/313309/>kyoto.go</a> のイベントがあってそのトークに orderedmap について話して来ようと思う。</p></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2023/0710/>情報共有とメンバー課金の過ち</a></h1><div class=post-meta><time class=post-date>2023-07-10</time></div><span class=post-tags>#<a href=/diary/tags/ldap/>ldap</a>&nbsp;
#<a href=/diary/tags/packaging/>packaging</a>&nbsp;
#<a href=/diary/tags/information-exchange/>information exchange</a>&nbsp;
#<a href=/diary/tags/business/>business</a>&nbsp;</span><div class=post-content><p>1時に寝て4時に起きて5時に起きて7時に起きた。明け方からうまく眠れなくなった。</p><h2 id=clang-の互換性>clang の互換性</h2><p>openldap 2.5 向けに ldap の overlay モジュールのビルド環境を作っていた。これまでは 2.4 向けのモジュールのみを提供していた。2.5 もそろそろやろうということで先週末からビルド環境の構築に着手していた。rpm のパッケージングの作業をしていて、openldap 2.5 のサーバーのビルドをしていると次のエラーが発生した。</p><pre tabindex=0><code>configure:21011: checking for pthread_detach with &lt;pthread.h&gt;
configure:21033: clang -o conftest -O2 -g3 -fstack-protector -fPIE -D_REENTRANT -D_THREAD_SAFE -DOPENLDAP_FD_SETSIZE=16384 -DLDAP_CONNECTIONLESS -DSLAPD_META_CLIENT_PR -D_GNU_SOURCE -Wl,-z,relro -Wl,--as-needed  -Wl,-z,now -specs=/usr/lib/rpm/redhat/redhat-hardened-ld -specs=/usr/lib/rpm/redhat/redhat-annobin-cc1  conftest.c    &gt;&amp;5
clang-15: warning: argument unused during compilation: &#39;-specs=/usr/lib/rpm/redhat/redhat-hardened-ld&#39; [-Wunused-command-line-argument]
clang-15: warning: argument unused during compilation: &#39;-specs=/usr/lib/rpm/redhat/redhat-annobin-cc1&#39; [-Wunused-command-line-argument]
conftest.c:118:16: error: incompatible pointer to integer conversion passing &#39;void *&#39; to parameter of type &#39;pthread_t&#39; (aka &#39;unsigned long&#39;) [-Wint-conversion]
pthread_detach(NULL);
               ^~~~
/usr/lib64/clang/15.0.7/include/stddef.h:89:16: note: expanded from macro &#39;NULL&#39;
#  define NULL ((void*)0)
               ^~~~~~~~~~
/usr/include/pthread.h:269:38: note: passing argument to parameter &#39;__th&#39; here
extern int pthread_detach (pthread_t __th) __THROW;
                                     ^
1 error generated.
</code></pre><p>エラーメッセージを調べていると、どうやら clang 15 に pthread_detach がないといったものらしい。clang 14 のときはビルドできたという。他の oss でも clang のバージョン違いでビルドできないといったことは発生しているらしい。有識者によると、次の修正が clang15 対応らしい。</p><ul><li><a href=https://git.openldap.org/openldap/openldap/-/commit/4a9aaf7c2621c2800b163efe928512c20bd422e2>ITS#10011 build: fix compatibility with stricter C99 compilers</a></li></ul><p>それ以外はとくに問題なく、ビルドできてモジュールそのものの動作も確認した。あとは rpm のパッケージングと gitlab ci/cd でビルドしたモジュールで動くかどうかの検証だけ。</p><h2 id=メンバー課金による過ち>メンバー課金による過ち</h2><p><a href=/diary/posts/2023/0709/>昨日 SuperGoodMeetings をさわってみた</a> ときにチーム管理の機能があって、任意のユーザーを招待するのは無制限で課金されないと書いてあった。「なるほどね。」とピンと来てコパイロツトの中の人に次のような所感を共有してみた。</p><blockquote><p>招待可能ユーザー数を無制限にしているのはよい視点だと私は思います。メンバー課金にすると、経費を削減するために共有アカウントを利用したり、あまり使わない人にはアカウントを作らないようになって情報共有の側面から望ましくない状態になる。一昔前のオンプレ時代は業務に使うシステムのアカウントは全社員がもっていて当たり前だったのが、クラウドサービスを使うようになってメンバー課金の経費削減から全社員がもたないようになりつつある (とくに中小企業) のは、情報共有の視点から過去よりも悪化しているという問題意識を私はもっています。</p></blockquote><p>コパイロツトさんもまったく同じ課題意識をもっていてメンバー課金しない料金体系にしているとのこと。鶏と卵みたいな話しだけど、組織には情報共有のためにアカウントのお金をケチんなと言いたいし、クラウドサービスの会社も料金体系を1人ずつじゃなくて、30人、100人、1000人といったある程度の階段でいいんじゃない？とか思ったりする。メンバー課金じゃないクラウドサービスとして basecamp や backlog などがある。</p><ul><li><a href=https://basecamp.com/pricing>https://basecamp.com/pricing</a></li><li><a href=https://backlog.com/ja/pricing/>https://backlog.com/ja/pricing/</a></li></ul></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2023/0420/>git コマンドでアーカイブ</a></h1><div class=post-meta><time class=post-date>2023-04-20</time></div><span class=post-tags>#<a href=/diary/tags/rpm/>rpm</a>&nbsp;
#<a href=/diary/tags/git/>git</a>&nbsp;
#<a href=/diary/tags/packaging/>packaging</a>&nbsp;</span><div class=post-content><p>2時に寝て7時に起きた。昨日も遅かったので0時ぐらいに晩ご飯を食べてうまく眠れなかった。体調が悪かったので今日は早めにお仕事を終えて帰って寝てた。</p><h2 id=rpm-パッケージングのためのアーカイブ>rpm パッケージングのためのアーカイブ</h2><p>プロダクトは docker compose を使ってデプロイするので docker-compose.yml と関連する設定などのサンプルファイルをパッケージングして rpm として提供する。ビルドは必要なく、初期は数ファイルだったので rpm の SOURCES ディレクトリに直接配置して個別に SourceXx と指定してパッケージングしていた。設定のサンプルファイルが増えてくると1つずつ指定するのが面倒になってきてアーカイブすることにした。rpm を作るための Makefile で次のように git コマンドからアーカイブを作ることができる。このやり方のメリットの1つは git でアーカイブすることでリポジトリにコミットされているものだけが使われるため、対象ディレクトリに中間ファイルなどが散らかっていても無視してくれて都合がよい。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=display:flex><span>VERSION          <span style=color:#f92672>=</span> 1.0.0
</span></span><span style=display:flex><span>SRC_PREFIX       <span style=color:#f92672>=</span> my-product-<span style=color:#66d9ef>$(</span>VERSION<span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span>SRC_ARCHIVE      <span style=color:#f92672>=</span> <span style=color:#66d9ef>$(</span>SRC_PREFIX<span style=color:#66d9ef>)</span>.tar.bz2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>SOURCES/$(SRC_ARCHIVE)</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>	git -C ../my-src archive HEAD --prefix <span style=color:#66d9ef>$(</span>SRC_PREFIX<span style=color:#66d9ef>)</span>/ -o <span style=color:#66d9ef>$(</span>SRC_ARCHIVE<span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span>	mv ../my-src/<span style=color:#66d9ef>$(</span>SRC_ARCHIVE<span style=color:#66d9ef>)</span> $@
</span></span></code></pre></div><p>make したときに my-product-1.0.0.tar.bz のようなアーカイブが rpm パッケージングするときの SOURCES 配下に置かれる。そして rpm の spec ファイルでこのアーカイブを <code>Source0</code> として指定して %prep で %setup マクロを呼び出すと展開される。</p><pre tabindex=0><code>Source0: my-product-%{version}.tar.bz2
...
%prep
%setup
</code></pre><p>たったこれだけで spec ファイルの Source 管理をシンプルにできて保守コストが下がるのでうまいやり方だなと学びになった。</p></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2023/0413/>rpm のパッケージングを作り直す</a></h1><div class=post-meta><time class=post-date>2023-04-13</time></div><span class=post-tags>#<a href=/diary/tags/linux/>linux</a>&nbsp;
#<a href=/diary/tags/rpm/>rpm</a>&nbsp;
#<a href=/diary/tags/packaging/>packaging</a>&nbsp;</span><div class=post-content><p>1時に寝て何度か起きてあまり眠れなかった。昨日は遅くに帰ってきて晩ご飯を遅くに食べたので寝ていて吐き気がしてうまく眠れなかった。寝る前に食べることはできないみたい。</p><h2 id=rpm-パッケージング再び>rpm パッケージング再び</h2><p><a href=/diary/posts/2023/0411/#ビルド問題の解決>ビルドができるようになったモジュール</a> を rpm でパッケージングする。rpm でのビルドもできる状態で渡してもらえたので私が開発したモジュールを追加してパッケージングを修正する。rpm のパッケージングを行うのも5年ぶりといったところ。コンテナに慣れてしまって rpm を使うことはもうないと思っていたけれど、まだまだ現役であることを実感する。spec ファイルは普通に読めるので既存の設定や、他の rpm パッケージの spec ファイルの記述などもみながら、自分のモジュールで必要な設定を追加していく。久しぶりだったわりには順調に作業が進捗して2-3時間もやっていて追加の修正をして、実際にインストールして動作確認もできた。</p><p>rpm のマクロを確認する。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ rpm --eval <span style=color:#e6db74>&#34;%{_libdir}&#34;</span>
</span></span><span style=display:flex><span>/usr/lib64
</span></span></code></pre></div><p>あるサーバーサービスを systemd 経由で実行させる。内部的に環境変数を使っている。systemd の EnvironmentFile で環境変数を設定したファイルへのパスを指定できる。例えば、次のように EnvironmentFile にパスを設定する。</p><pre tabindex=0><code>[Service]
Type=simple
EnvironmentFile=/opt/path/to/my.env
ExecStart=/opt/path/to/bin/my-service
KillMode=process
StartLimitBurst=2
Restart=on-abnormal
User=ldap
Group=ldap
</code></pre><p>この環境変数にはパスワードのような機密情報も含むので rpm の %files で root 権限でのみ読めるようにアクセス制限を設定する。systemd 自体は root 権限で動くので環境変数の設定は root が行って my-service は ldap のユーザー／グループ権限で動く。</p><pre tabindex=0><code>%attr(600,root,root) %config(noreplace) %{_sysconfdir}/path/to/my.env
</code></pre><blockquote class=twitter-tweet><p lang=ja dir=ltr>もう rpm なんか古の技術で自分で作ることなんか今後はないやろと思っていた。5年ぶりぐらいに、いま rpm でパッケージングしていて、spec ファイルを普通に読めるので簡単なパッケージングぐらいはすぐできる。なんでもやっといたら役に立つもんやと思ったりもする。</p>&mdash; Tetsuya Morimoto (@t2y) <a href="https://twitter.com/t2y/status/1646540939740213248?ref_src=twsrc%5Etfw">April 13, 2023</a></blockquote><script async src=https://platform.twitter.com/widgets.js></script></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2023/0403/>ローカルにコンテナレジストリを構築する</a></h1><div class=post-meta><time class=post-date>2023-04-03</time></div><span class=post-tags>#<a href=/diary/tags/docker/>docker</a>&nbsp;
#<a href=/diary/tags/packaging/>packaging</a>&nbsp;
#<a href=/diary/tags/mdbook/>mdbook</a>&nbsp;
#<a href=/diary/tags/document/>document</a>&nbsp;
#<a href=/diary/tags/mermaid/>mermaid</a>&nbsp;</span><div class=post-content><p>出張する日は寝ないで資料を作ったりバグ修正したりして始発の新幹線の中で寝てた。寝てなくて疲れているせいか、新幹線で寝るのに慣れたのか、わりと2-3時間ぐっすり新幹線で眠れるようになってきた。普通にベッドで寝ても3時間ぐらいしか眠れないので睡眠時間はあまり変わらない。</p><h2 id=docker-registry-の構築>docker registry の構築</h2><p><a href=/diary/posts/2023/0330/#外部向けコンテナレジストリ>先日の調査</a> の続き。<a href=https://docs.docker.com/registry/deploying/>Deploy a registry server</a> に書いてあることを実際にローカルで検証した。</p><p>tls の自己証明書の作成。subjectAltName という設定をするように書いてある。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ openssl req -newkey rsa:4096 -nodes -sha256 -keyout certs/domain.key -addext <span style=color:#e6db74>&#34;subjectAltName = DNS:myhost.mydomain.example.com&#34;</span> -x509 -days <span style=color:#ae81ff>365</span> -out certs/domain.crt
</span></span></code></pre></div><p>basic 認証のための htpasswd の設定。htpasswd とか懐かしいなと思いながら実行した。</p><pre tabindex=0><code class=language-bsah data-lang=bsah>$ docker run --entrypoint htpasswd httpd:2 -Bbn user1 secret1 &gt;&gt; dot_htpasswd
$ docker run --entrypoint htpasswd httpd:2 -Bbn user2 secret2 &gt;&gt; dot_htpasswd
</code></pre><p>docker 社が提供する oss な docker registry サーバーを使って起動する。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ mkdir /mnt/registry  <span style=color:#75715e># docker image を永続化する場所</span>
</span></span><span style=display:flex><span>$ sudo docker run -d <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  --restart<span style=color:#f92672>=</span>always <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  --name registry <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  -v <span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>$(</span>pwd<span style=color:#66d9ef>)</span><span style=color:#e6db74>&#34;</span>/auth:/auth <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  -e <span style=color:#e6db74>&#34;REGISTRY_AUTH=htpasswd&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  -e <span style=color:#e6db74>&#34;REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  -e <span style=color:#e6db74>&#34;REGISTRY_AUTH_HTPASSWD_PATH=/auth/dot_htpasswd&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  -v <span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>$(</span>pwd<span style=color:#66d9ef>)</span><span style=color:#e6db74>&#34;</span>/certs:/certs <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  -e <span style=color:#e6db74>&#34;REGISTRY_HTTP_ADDR=0.0.0.0:443&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  -e <span style=color:#e6db74>&#34;REGISTRY_HTTP_TLS_CERTIFICATE=/certs/domain.crt&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  -e <span style=color:#e6db74>&#34;REGISTRY_HTTP_TLS_KEY=/certs/domain.key&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  -p 8443:443 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  -v /mnt/registry:/var/lib/registry <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  registry:2
</span></span></code></pre></div><p>これで basic 認証付きで https で通信できる docker registry サーバーができた。</p><p>外部のマシンから dokcer login しようとすると次のようなエラーが発生する。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ docker login myhost.mydomain.example.com:8443
</span></span><span style=display:flex><span>Username: user2
</span></span><span style=display:flex><span>Password: ***
</span></span><span style=display:flex><span>Error response from daemon: Get <span style=color:#e6db74>&#34;https://myhost.mydomain.example.com:8443/v2/&#34;</span>: x509: certificate signed by unknown authority
</span></span></code></pre></div><p><a href=https://docs.docker.com/registry/insecure/>Test an insecure registry</a> によると、自己証明書を使って外部からアクセスできるようにするためには docker client 側にさっき作った domain.crt をコピーする必要がある。</p><p>linux だとこんな設定。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cp domain.crt /etc/docker/certs.d/myhost.mydomain.example.com:8443/ca.crt 
</span></span></code></pre></div><p>Docker Desktop for Mac を使っている場合はこんな感じ。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh><span style=display:flex><span>&gt; security add-trusted-cert -d -r trustRoot -k ~/Library/Keychains/login.keychain path/to/certs/domain.crt
</span></span></code></pre></div><p>これで外部からも docker login して任意の docker image を push/pull できるようになる。docker registry サーバーは Let’s Encrypt をサポートしているそうなので <a href=https://letsencrypt.org/how-it-works/>How It Works</a> を参照して設定すればよいと書いてあった。</p><h2 id=mdbook-の初期設定>mdbook の初期設定</h2><p>mdbook は新しい rust のバージョンだとビルドできなかったりするので rustup を使ってローカルに rustc をインストールするのがよいかもしれない。プラグインとしては <a href=https://github.com/badboy/mdbook-mermaid>mdbook-mermaid</a> を使う。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ curl --proto <span style=color:#e6db74>&#39;=https&#39;</span> --tlsv1.2 -sSf https://sh.rustup.rs | sh
</span></span><span style=display:flex><span>$ ~/.cargo/bin/rustc --version
</span></span><span style=display:flex><span>$ cargo install mdbook mdbook-mermaid
</span></span></code></pre></div><p>mdbook-mermaid の設定も簡単でドキュメントルート配下に mermaid の js ファイルを配置すると動いた。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ vi book.toml
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>preprocessor.mermaid<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>command <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;mdbook-mermaid&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>output.html<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>additional-js <span style=color:#f92672>=</span> <span style=color:#f92672>[</span><span style=color:#e6db74>&#34;mermaid.min.js&#34;</span>, <span style=color:#e6db74>&#34;mermaid-init.js&#34;</span><span style=color:#f92672>]</span>
</span></span></code></pre></div></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2023/0330/>コンテナレジストリをプライベートに運用する</a></h1><div class=post-meta><time class=post-date>2023-03-30</time></div><span class=post-tags>#<a href=/diary/tags/docker/>docker</a>&nbsp;
#<a href=/diary/tags/packaging/>packaging</a>&nbsp;</span><div class=post-content><p>0時に寝て7時に起きた。晩ご飯を食べきれなくて調子悪いと思っていたら夜も吐き気と胃酸で気分が悪くてあまり眠れなかった。</p><h2 id=外部向けコンテナレジストリ>外部向けコンテナレジストリ</h2><p>いまお仕事で作っているアプリケーションは docker image としてパッケージングしている。エンドユーザーがこのアプリケーションを使うためには docker pull できるためにインターネットを経由してアクセスできる必要がある。普段はイントラネットのコンテナレジストリに push/pull して運用しているのを、外部のエンドユーザー向けにアクセスできるコンテナレジストリ (リポジトリ) を構築しないといけない。パブリックなリポジトリとして提供するのであれば、<a href=https://hub.docker.com/>docker hub</a> や <a href=https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-container-registry>GitHub Container registry</a> などを無料で利用できる。しかし、プライベートなリポジトリで運用しようとするとその選択肢は狭まってしまう。おそらく他社のサービスを使うのであれば、実際の運用を考慮するといくらか費用がかかるだろう。</p><p>仮に docker image が使うストレージを5GiB、インターネットへの outbound なデータ転送を30GiB/月で見積もってみた。docker hub だと利用量によって課金されないのでその後に利用増加が前提であればよさそうにみえる。</p><ul><li><p>github (従量課金)</p><ul><li><a href=https://github.com/pricing>team プラン</a></li><li>開発者1人: $20.25/month, $243/year</li></ul></li><li><p>aws (従量課金)</p><ul><li>region=tokyo: $3.92/month, $47.04/year</li></ul></li><li><p>docker hub (容量無制限)</p><ul><li><a href=https://www.docker.com/pricing/>team プラン</a></li><li>開発者1人: $11/month, $132/year</li></ul></li></ul><p>別の選択肢として自前でコンテナレジストリを運用するという方法もある。docker registry サーバーは oss として公開されていて docker image の push/pull をするだけのサーバーならすぐに構築できる。ベーシック認証に近い v1 の認証でよければ <a href=https://httpd.apache.org/docs/current/programs/htpasswd.html>htpasswd</a> を使ってアカウント管理できる。</p><ul><li><a href=https://docs.docker.com/registry/deploying/>Deploy a registry server</a></li></ul><p>ドメインと tls の証明書と外部からアクセスできるサーバーがあれば、自前で運用するのもそう大変ではないと思う。実際にこれらの運用コストと他サービスの利用料金とを比べて選択することになるだろう。</p></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2023/0329/>gitlab packages api の使い方</a></h1><div class=post-meta><time class=post-date>2023-03-29</time></div><span class=post-tags>#<a href=/diary/tags/gitlab/>gitlab</a>&nbsp;
#<a href=/diary/tags/ci/cd/>ci/cd</a>&nbsp;
#<a href=/diary/tags/packaging/>packaging</a>&nbsp;</span><div class=post-content><p>0時に寝て何度か起きて6時半に起きた。先週より少し早く起きれるようになってきた。</p><h2 id=gitlab-cicd-で別プロジェクト-リポジトリ-の成果物を取得する>gitlab ci/cd で別プロジェクト (リポジトリ) の成果物を取得する</h2><p>gitlab では複数のパッケージリポジトリに対応しているが、それらに当てはまらない汎用の成果物向けに <a href=https://docs.gitlab.com/ee/user/packages/generic_packages/>GitLab Generic Packages Repository</a> というものがある。zip でもバイナリファイルでも何でも置くためのリポジトリと言える。但し、同じパッケージ名でバージョン管理するといった作りにはなっていなくて、同じパッケージ名でアップロードしても別のパッケージ id が割り当てられて管理される。他バージョンとの紐付け自体はできているので、おそらく歴史的経緯でそういう仕様なのだと思う。そのために、あるパッケージの最新のバージョンを取得したいときは作成日の降順でソートして最初のパッケージを取得するといったコードを書かないといけない。それは <a href=https://docs.gitlab.com/ee/api/packages.html>Packages API</a> を駆使して簡単なスクリプトを書くことになる。</p><p>もう1つ分からないことにトークンの使い分けがある。なるべく ci/cd での処理は <a href=https://docs.gitlab.com/ee/ci/jobs/ci_job_token.html>GitLab CI/CD job token</a> を使いたいところだが、どうも Packages API の呼び出しはできなくて別途プロジェクトでアクセストークンを作成して呼び出すようにしている。これはもしかしたら別の設定で CI/CD job token でも呼び出しできるかもしれない。rest api への呼び出し権限そのものがないのかもしれない。</p><p>最終的には次のようなスクリプトで任意のプロジェクトの generic リポジトリの最新の成果物を取得できた。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>rm -rf <span style=color:#e6db74>${</span>TARGET_DIR<span style=color:#e6db74>}</span>
</span></span><span style=display:flex><span>mkdir -p <span style=color:#e6db74>${</span>TARGET_DIR<span style=color:#e6db74>}</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> project in $PROJECTS
</span></span><span style=display:flex><span><span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  prj<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>echo <span style=color:#e6db74>&#34;</span>$project<span style=color:#e6db74>&#34;</span> | jq -Rr @uri<span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span>  base<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>CI_API_V4_URL<span style=color:#e6db74>}</span><span style=color:#e6db74>/projects/</span><span style=color:#e6db74>${</span>prj<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>  pkg<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>curl -s -H <span style=color:#e6db74>&#34;PRIVATE-TOKEN: </span>$PROJECT_ACCESS_TOKEN<span style=color:#e6db74>&#34;</span> <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>base<span style=color:#e6db74>}</span><span style=color:#e6db74>/packages?order_by=created_at&amp;sort=desc&amp;per_page=1&#34;</span> | jq <span style=color:#e6db74>&#39;.[0]&#39;</span><span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span>  pkg_id<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>echo $pkg | jq -r .id<span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span>  pkg_name<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>echo $pkg | jq -r .name<span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span>  pkg_version<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>echo $pkg | jq -r .version<span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span>  file_names<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>curl -s -H <span style=color:#e6db74>&#34;PRIVATE-TOKEN: </span>$PROJECT_ACCESS_TOKEN<span style=color:#e6db74>&#34;</span> <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>base<span style=color:#e6db74>}</span><span style=color:#e6db74>/packages/</span><span style=color:#e6db74>${</span>pkg_id<span style=color:#e6db74>}</span><span style=color:#e6db74>/package_files&#34;</span> | jq -r <span style=color:#e6db74>&#39;.[].file_name&#39;</span><span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> file_name in $file_names
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>    dw_endpoint<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>base<span style=color:#e6db74>}</span><span style=color:#e6db74>/packages/generic/</span><span style=color:#e6db74>${</span>pkg_name<span style=color:#e6db74>}</span><span style=color:#e6db74>/</span><span style=color:#e6db74>${</span>pkg_version<span style=color:#e6db74>}</span><span style=color:#e6db74>/</span><span style=color:#e6db74>${</span>file_name<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>    curl -s -H <span style=color:#e6db74>&#34;PRIVATE-TOKEN: </span>$PROJECT_ACCESS_TOKEN<span style=color:#e6db74>&#34;</span> <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>dw_endpoint<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span> -o <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>TARGET_DIR<span style=color:#e6db74>}</span><span style=color:#e6db74>/</span><span style=color:#e6db74>${</span>file_name<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>done</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>done</span>
</span></span><span style=display:flex><span>find <span style=color:#e6db74>${</span>TARGET_DIR<span style=color:#e6db74>}</span> -type f
</span></span></code></pre></div></div></article><div class=pagination><div class=pagination__buttons></div></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2025 Powered by <a href=https://gohugo.io>Hugo</a></span>
<span>:: <a href=https://github.com/panr/hugo-theme-terminal target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/diary/bundle.min.js></script></div></body></html>