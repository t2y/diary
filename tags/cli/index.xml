<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Cli on</title><link>/diary/tags/cli/</link><description>Recent content in Cli on</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Mon, 25 Nov 2024 18:21:15 +0900</lastBuildDate><atom:icon>/diary/favicon.ico</atom:icon><icon>/diary/favicon.ico</icon><atom:link href="/diary/tags/cli/index.xml" rel="self" type="application/rss+xml"/><item><title>compose 環境のバックアップ</title><link>/diary/posts/2024/1125/</link><pubDate>Mon, 25 Nov 2024 18:21:15 +0900</pubDate><guid>/diary/posts/2024/1125/</guid><description>今日は溜まった日記をまとめて書くためにバドミントン練習はおやすみ。
コンテナの環境変数の再利用 朝から rpm パッケージングのリファクタリングをしてインストール検証をした後、バックアップスクリプトの調査をしていた。コンテナの環境変数は次のようにして取得できる。
環境変数をすべて表示 $ docker compose exec mongo env 任意の環境変数の値を取得 $ docker compose mongo printenv MONGODB_PORT_NUMBER パスワードの隠蔽 コンテナ内の mongodump を実行するときにパスワードを隠蔽するにはパイプを使って標準入力から渡す。
$ echo ${passwd} | docker compose exec --no-TTY mongo mongodump --authenticationDatabase admin --uri mongodb://${user}@localhost:27017 --db mydb --archive &amp;gt; mydb.dump tar ball によるバックアップ 普通に tar ball を作ると次のようになる。
$ tar --exclude path/to/dir/subdir1 --exclude path/to/dir/subdir2 -czf backup.tar.gz path/to/dir お手伝い先の社員さんに zstd という新しい圧縮アルゴリズムを使う方がよいとアドバイスをもらって変更した。別途 zstd のパッケージはインストールしておく必要がある。
$ tar --exclude path/to/dir/subdir1 --exclude path/to/dir/subdir2 --zstd -cf backup.</description><content>&lt;p>今日は溜まった日記をまとめて書くためにバドミントン練習はおやすみ。&lt;/p>
&lt;h2 id="コンテナの環境変数の再利用">コンテナの環境変数の再利用&lt;/h2>
&lt;p>朝から rpm パッケージングのリファクタリングをしてインストール検証をした後、バックアップスクリプトの調査をしていた。コンテナの環境変数は次のようにして取得できる。&lt;/p>
&lt;ul>
&lt;li>環境変数をすべて表示&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>$ docker compose exec mongo env
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>任意の環境変数の値を取得&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>$ docker compose mongo printenv MONGODB_PORT_NUMBER
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>パスワードの隠蔽&lt;/li>
&lt;/ul>
&lt;p>コンテナ内の mongodump を実行するときにパスワードを隠蔽するにはパイプを使って標準入力から渡す。&lt;/p>
&lt;pre tabindex="0">&lt;code>$ echo ${passwd} | docker compose exec --no-TTY mongo mongodump --authenticationDatabase admin --uri mongodb://${user}@localhost:27017 --db mydb --archive &amp;gt; mydb.dump
&lt;/code>&lt;/pre>&lt;h2 id="tar-ball-によるバックアップ">tar ball によるバックアップ&lt;/h2>
&lt;p>普通に tar ball を作ると次のようになる。&lt;/p>
&lt;pre tabindex="0">&lt;code>$ tar --exclude path/to/dir/subdir1 --exclude path/to/dir/subdir2 -czf backup.tar.gz path/to/dir
&lt;/code>&lt;/pre>&lt;p>お手伝い先の社員さんに &lt;a href="https://github.com/facebook/zstd">zstd&lt;/a> という新しい圧縮アルゴリズムを使う方がよいとアドバイスをもらって変更した。別途 zstd のパッケージはインストールしておく必要がある。&lt;/p>
&lt;pre tabindex="0">&lt;code>$ tar --exclude path/to/dir/subdir1 --exclude path/to/dir/subdir2 --zstd -cf backup.tar.zst path/to/dir
&lt;/code>&lt;/pre></content></item><item><title>exec とスクリプト</title><link>/diary/posts/2024/1018/</link><pubDate>Fri, 18 Oct 2024 11:19:20 +0900</pubDate><guid>/diary/posts/2024/1018/</guid><description>今日のバドミントン練習はエアシャトルでリフティングを60分した。連続最大回数は191回だった。もう少しで200回だったのに残念。木曜日は睡眠をたくさんとって疲れは少し取れたし、安定的に50回前後は続くようになりつつも、100回までに失敗してしまう。今日は100回を超えたのが2回だけだった。ラケットのスィートスポットでとらえたときにきれいに真上にあがる感覚が楽しい。うまくいくときは数回は続く。それが自然にできるときとそうじゃないときの違いを私は制御できてなくて言語化もできない。
エアシャトルとメイビスにおけるリフティングの違いを比べてみると、メイビスの方が打ち上げて落ちてくるときにあまり回転せずコルクが下を向く傾向が多いようにみえる。エアシャトルの方がコルクが重い分、縦方向に回転し始めるとその回転が止まらず、回転しているからラケット面でとらえるのが難しくなる。だからエアシャトルの方がメイビスよりもリフティングが難しいといえる。シャトルを高く打ち上げると、落下してくる距離が長くなりその回転が落ち着く傾向があるからリフティングしやすくなるのではないかと仮説を考えた。伸び悩みかもしれないし、地道に練習を継続するときかもしれない。
exec とエントリーポイントのスクリプト コンテナを起動して stop すると SIGTERM が送られる。そのときに api サーバーでシグナルの処理をしているのに、気付いたらシグナル処理が行われずタイムアウトするようになっていた。デフォルトでは10秒でタイムアウトして強制終了となる。なぜシグナルを捕捉しなくなったかを調査したら、あるときサーバーの起動前に前処理が必要になってエントリーポイントをシェルスクリプトにしていた。そのときに exec しないと、シェルスクリプトのプロセスに対してシグナルが送られるため、api サーバーがシグナルを検知できなくなるという副作用があることに気付いた。これまでも exec を使うとプロセス ID は変更されないという知識を知っていたが、それがどういう状況で役に立つかを理解できていなかった。シグナルを用いた同期処理に exec が役に立つ状況があることを学んだ。修正は次の1行のみ。
--- a/docker/entrypoint.sh +++ b/docker/entrypoint.sh @@ -2,4 +2,4 @@ ... ... (pre process) ... -./bin/api &amp;#34;$@&amp;#34; +exec ./bin/api &amp;#34;$@&amp;#34; go test からバイナリをビルドしてサーバーを起動する 先日 結合テスト向けカバレッジ計測の調査 をした成果を使って実際に go test からカバレッジ計測のカスタマイズを施したバイナリをビルドしてサーバー起動するコードを書いてみた。やや手間取ったが、一通り動いてカバレッジを計測できた。例えば、単体テストのカバレッジを計測するための makefile のターゲットは次のようになる。
GO_COVER_DIR:=$(CURDIR)/tests/coverage coverage: @mkdir -p $(GO_COVER_DIR) go test -tags=integration -race -cover ./... -covermode atomic -args -test.gocoverdir=$(GO_COVER_DIR) go は fork ができない。fork の代わりに exec を使う。How do I fork a go process?</description><content>&lt;p>今日のバドミントン練習はエアシャトルでリフティングを60分した。連続最大回数は191回だった。もう少しで200回だったのに残念。木曜日は睡眠をたくさんとって疲れは少し取れたし、安定的に50回前後は続くようになりつつも、100回までに失敗してしまう。今日は100回を超えたのが2回だけだった。ラケットのスィートスポットでとらえたときにきれいに真上にあがる感覚が楽しい。うまくいくときは数回は続く。それが自然にできるときとそうじゃないときの違いを私は制御できてなくて言語化もできない。&lt;/p>
&lt;p>エアシャトルとメイビスにおけるリフティングの違いを比べてみると、メイビスの方が打ち上げて落ちてくるときにあまり回転せずコルクが下を向く傾向が多いようにみえる。エアシャトルの方がコルクが重い分、縦方向に回転し始めるとその回転が止まらず、回転しているからラケット面でとらえるのが難しくなる。だからエアシャトルの方がメイビスよりもリフティングが難しいといえる。シャトルを高く打ち上げると、落下してくる距離が長くなりその回転が落ち着く傾向があるからリフティングしやすくなるのではないかと仮説を考えた。伸び悩みかもしれないし、地道に練習を継続するときかもしれない。&lt;/p>
&lt;h2 id="exec-とエントリーポイントのスクリプト">exec とエントリーポイントのスクリプト&lt;/h2>
&lt;p>コンテナを起動して stop すると SIGTERM が送られる。そのときに api サーバーでシグナルの処理をしているのに、気付いたらシグナル処理が行われずタイムアウトするようになっていた。デフォルトでは10秒でタイムアウトして強制終了となる。なぜシグナルを捕捉しなくなったかを調査したら、あるときサーバーの起動前に前処理が必要になってエントリーポイントをシェルスクリプトにしていた。そのときに exec しないと、シェルスクリプトのプロセスに対してシグナルが送られるため、api サーバーがシグナルを検知できなくなるという副作用があることに気付いた。これまでも &lt;a href="https://ja.wikipedia.org/wiki/Exec">exec&lt;/a> を使うとプロセス ID は変更されないという知識を知っていたが、それがどういう状況で役に立つかを理解できていなかった。シグナルを用いた同期処理に exec が役に立つ状況があることを学んだ。修正は次の1行のみ。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-diff" data-lang="diff">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">--- a/docker/entrypoint.sh
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&lt;/span>&lt;span style="color:#a6e22e">+++ b/docker/entrypoint.sh
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">&lt;/span>&lt;span style="color:#75715e">@@ -2,4 +2,4 @@
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ... (pre process)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">-./bin/api &amp;#34;$@&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&lt;/span>&lt;span style="color:#a6e22e">+exec ./bin/api &amp;#34;$@&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="go-test-からバイナリをビルドしてサーバーを起動する">go test からバイナリをビルドしてサーバーを起動する&lt;/h2>
&lt;p>先日 &lt;a href="/diary/diary/posts/2024/1011/#go-の結合テスト向けカバレッジ計測の考察">結合テスト向けカバレッジ計測の調査&lt;/a> をした成果を使って実際に go test からカバレッジ計測のカスタマイズを施したバイナリをビルドしてサーバー起動するコードを書いてみた。やや手間取ったが、一通り動いてカバレッジを計測できた。例えば、単体テストのカバレッジを計測するための makefile のターゲットは次のようになる。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-makefile" data-lang="makefile">&lt;span style="display:flex;">&lt;span>GO_COVER_DIR&lt;span style="color:#f92672">:=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>CURDIR&lt;span style="color:#66d9ef">)&lt;/span>/tests/coverage
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">coverage&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @mkdir -p &lt;span style="color:#66d9ef">$(&lt;/span>GO_COVER_DIR&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> go test -tags&lt;span style="color:#f92672">=&lt;/span>integration -race -cover ./... -covermode atomic -args -test.gocoverdir&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>GO_COVER_DIR&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>go は &lt;a href="https://ja.wikipedia.org/wiki/Fork">fork&lt;/a> ができない。fork の代わりに exec を使う。&lt;a href="https://stackoverflow.com/a/28371586">How do I fork a go process?&lt;/a> に go の goroutine のスケジューリングと fork は相性が悪くてうまく動かないということが背景だと説明されている。それはともかく exec を使ってもサーバープロセスを非同期に起動できたのでそのスニペットを書いておく。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">binaryPath&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">buildBinary&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">args&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> []&lt;span style="color:#66d9ef">string&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;-verbose&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;-port&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">strconv&lt;/span>.&lt;span style="color:#a6e22e">Itoa&lt;/span>(&lt;span style="color:#a6e22e">ServerPort&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">r&lt;/span>, &lt;span style="color:#a6e22e">w&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">io&lt;/span>.&lt;span style="color:#a6e22e">Pipe&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">go&lt;/span> &lt;span style="color:#66d9ef">func&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">s&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">bufio&lt;/span>.&lt;span style="color:#a6e22e">NewScanner&lt;/span>(&lt;span style="color:#a6e22e">r&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">s&lt;/span>.&lt;span style="color:#a6e22e">Scan&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">s&lt;/span>.&lt;span style="color:#a6e22e">Text&lt;/span>())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">cmd&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">exec&lt;/span>.&lt;span style="color:#a6e22e">Command&lt;/span>(&lt;span style="color:#a6e22e">binaryPath&lt;/span>, &lt;span style="color:#a6e22e">args&lt;/span>&lt;span style="color:#f92672">...&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">cmd&lt;/span>.&lt;span style="color:#a6e22e">Stdout&lt;/span> = &lt;span style="color:#a6e22e">w&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">cmd&lt;/span>.&lt;span style="color:#a6e22e">Start&lt;/span>(); &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">slog&lt;/span>.&lt;span style="color:#a6e22e">Error&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;failed to start api server&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;err&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">defer&lt;/span> &lt;span style="color:#66d9ef">func&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">cmd&lt;/span>.&lt;span style="color:#a6e22e">Process&lt;/span>.&lt;span style="color:#a6e22e">Signal&lt;/span>(&lt;span style="color:#a6e22e">syscall&lt;/span>.&lt;span style="color:#a6e22e">SIGTERM&lt;/span>); &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">slog&lt;/span>.&lt;span style="color:#a6e22e">Error&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;failed to terminate the api process&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;err&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">s&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">cmd&lt;/span>.&lt;span style="color:#a6e22e">Process&lt;/span>.&lt;span style="color:#a6e22e">Wait&lt;/span>(); &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">slog&lt;/span>.&lt;span style="color:#a6e22e">Error&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;failed to wait terminating the api process&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;err&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">w&lt;/span>.&lt;span style="color:#a6e22e">Close&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">slog&lt;/span>.&lt;span style="color:#a6e22e">Info&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;completed to terminate the api process&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;s&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">s&lt;/span>.&lt;span style="color:#a6e22e">String&lt;/span>())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// サーバーに対するテストを実行
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>サーバープロセスの標準出力のログを &lt;a href="/diary/diary/posts/2024/0919/">io.Pipe&lt;/a> を使って出力することもできる。exec で生成したプロセスに対してもシグナルを送ったり終了を待つこともできる。デバッグしている分にはこれで意図したように制御できた。この知見は将来的に役に立つ気がする。0時過ぎから調査を再開して4時前ぐらいまでやっていた。少しはまって時間はかかったものの、久しぶりに集中してデバッグしていた。&lt;/p></content></item><item><title>ローカルに window server をインストールした</title><link>/diary/posts/2024/0118/</link><pubDate>Thu, 18 Jan 2024 09:28:57 +0900</pubDate><guid>/diary/posts/2024/0118/</guid><description>1時過ぎに寝て6時半に起きた。久しぶりによく眠れた。6時半に起きてたのに8時ぐらいまでだらだらしてた。
今日の筋トレは腹筋:20x1,腕立て:15x1,スクワット20x1をした。
windows server 2022 試用版のインストール Windows Server 2022 の試用版が提供されていると知ったのでローカルの VirtualBox 環境にインストールしてみた。Active Directory の検証に使うのでディレクトサービスや ldaps 接続のための証明書サービスなどを設定する。メンバーがインストールして課題管理システムにメモを残してくれてあったのでそれを見ながらインストールや設定自体はすぐにできた。1つだけうまく接続できないことがあった。
ホスト os から ldapsearch で ldaps で接続しようとすると次のようなエラーになる。
$ ldapsearch -x -H &amp;#34;ldaps://192.168.56.101&amp;#34; -W -b &amp;#34;CN=Users,DC=myad,DC=com&amp;#34; -D &amp;#34;CN=Administrator,CN=Users,DC=myad,DC=com&amp;#34; ldap_sasl_bind(SIMPLE): Can&amp;#39;t contact LDAP server (-1) ldap では接続できるので tls の検証のチェックに失敗していることは自明だったが、メンバーは接続できているようにみえたので私の環境の設定が誤っているのかどうかを調べていた。2時間ぐらいデバッグしたりしながら調べてもよくわからなくて、たまたまチーム勉強会があったので終わったときにメンバーに聞いてみた。すぐに完結した。ldapsearch は LDAPTLS_REQCERT という環境変数で tls のリクエストの振る舞いを制御できる。次のように明示的に指定すると接続できる。
$ LDAPTLS_REQCERT=never ldapsearch -x -H &amp;#34;ldaps://192.168.56.101&amp;#34; ... この設定はいくつかの方法で設定ファイルに書いておくこともできる。メンバーが使っている環境には ldap.conf でこの設定を有効にしていたので ldaps 接続できていたというオチだった。私が openldap について明るくないのでこういった背景知識をもっていなくてはまっていただけだった。
Thus the following files and variables are read, in order: variable $LDAPNOINIT, and if that is not set: system file /etc/openldap/ldap.</description><content>&lt;p>1時過ぎに寝て6時半に起きた。久しぶりによく眠れた。6時半に起きてたのに8時ぐらいまでだらだらしてた。&lt;/p>
&lt;p>今日の筋トレは腹筋:20x1,腕立て:15x1,スクワット20x1をした。&lt;/p>
&lt;h2 id="windows-server-2022-試用版のインストール">windows server 2022 試用版のインストール&lt;/h2>
&lt;p>&lt;a href="https://www.microsoft.com/ja-jp/evalcenter/evaluate-windows-server-2022">Windows Server 2022&lt;/a> の試用版が提供されていると知ったのでローカルの &lt;a href="https://www.virtualbox.org/">VirtualBox&lt;/a> 環境にインストールしてみた。Active Directory の検証に使うのでディレクトサービスや ldaps 接続のための証明書サービスなどを設定する。メンバーがインストールして課題管理システムにメモを残してくれてあったのでそれを見ながらインストールや設定自体はすぐにできた。1つだけうまく接続できないことがあった。&lt;/p>
&lt;p>ホスト os から ldapsearch で ldaps で接続しようとすると次のようなエラーになる。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ ldapsearch -x -H &lt;span style="color:#e6db74">&amp;#34;ldaps://192.168.56.101&amp;#34;&lt;/span> -W -b &lt;span style="color:#e6db74">&amp;#34;CN=Users,DC=myad,DC=com&amp;#34;&lt;/span> -D &lt;span style="color:#e6db74">&amp;#34;CN=Administrator,CN=Users,DC=myad,DC=com&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ldap_sasl_bind&lt;span style="color:#f92672">(&lt;/span>SIMPLE&lt;span style="color:#f92672">)&lt;/span>: Can&lt;span style="color:#960050;background-color:#1e0010">&amp;#39;&lt;/span>t contact LDAP server &lt;span style="color:#f92672">(&lt;/span>-1&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ldap では接続できるので tls の検証のチェックに失敗していることは自明だったが、メンバーは接続できているようにみえたので私の環境の設定が誤っているのかどうかを調べていた。2時間ぐらいデバッグしたりしながら調べてもよくわからなくて、たまたまチーム勉強会があったので終わったときにメンバーに聞いてみた。すぐに完結した。ldapsearch は &lt;code>LDAPTLS_REQCERT&lt;/code> という環境変数で tls のリクエストの振る舞いを制御できる。次のように明示的に指定すると接続できる。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ LDAPTLS_REQCERT&lt;span style="color:#f92672">=&lt;/span>never ldapsearch -x -H &lt;span style="color:#e6db74">&amp;#34;ldaps://192.168.56.101&amp;#34;&lt;/span> ...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この設定はいくつかの方法で設定ファイルに書いておくこともできる。メンバーが使っている環境には &lt;code>ldap.conf&lt;/code> でこの設定を有効にしていたので ldaps 接続できていたというオチだった。私が openldap について明るくないのでこういった背景知識をもっていなくてはまっていただけだった。&lt;/p>
&lt;pre tabindex="0">&lt;code>Thus the following files and variables are read, in order:
variable $LDAPNOINIT, and if that is not set:
system file /etc/openldap/ldap.conf,
user files $HOME/ldaprc, $HOME/.ldaprc, ./ldaprc,
system file $LDAPCONF,
user files $HOME/$LDAPRC, $HOME/.$LDAPRC, ./$LDAPRC,
variables $LDAP&amp;lt;uppercase option name&amp;gt;.
Settings late in the list override earlier ones.
&lt;/code>&lt;/pre>&lt;h2 id="明石海峡大橋海上ウォーク">明石海峡大橋海上ウォーク&lt;/h2>
&lt;p>神戸ジャーナルの記事をみかけて、そういうイベントがあるのは知っていた。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kaijo-uzushio-walk.jp/">神戸淡路鳴門自動車道 2橋ウォーク同時開催！ 明石海峡大橋海上ウォーク/大鳴門橋うずしおウォーク 令和6年3月9日(土)・10日(日)&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>開発合宿の翌週だし、わざわざ行くほどでもないかとスルーしていたものの、関東から知人がわざわざ歩きに来るという話しを聞いて、せっかくの機会なので私も参加することにした。土曜日の午前中に明石海峡大橋を歩いてくる。まだ申込みが始まったばかりなので希望の時間帯を選択できると思う。&lt;/p></content></item><item><title>vhs コマンドの使い方</title><link>/diary/posts/2024/0110/</link><pubDate>Wed, 10 Jan 2024 08:27:29 +0900</pubDate><guid>/diary/posts/2024/0110/</guid><description>23時過ぎに寝始めて何度か起きて7時半に起きた。
今日の筋トレは腹筋:10x1,腕立て:10x1,スクワット15x1をした。
sveltekit で context のデータを扱う ui 側でページに依存しない形で設定情報などを扱いたいとする。svelte の store と context api を組み合わせて sveltekit として context を管理するサンプルコードが紹介されている。
context と共に store を使う これだけですぐ動くのだけど、このときに LayoutData はサーバー側で作るとバックエンドの仕組みを隠蔽できて嬉しい。そういったときは src/routes/+layout.server.ts にバックエンドの api 呼び出しを隠蔽することで意図した振る舞いになる。
import type { LayoutServerLoad } from &amp;#34;./$types&amp;#34;; export const load: LayoutServerLoad = async () =&amp;gt; { const r = await fetch(`localhost:18080/myapi`); return r.json(); }; アニメ gif をスクリプトから作る お気に入りのコマンドラインツールを淡々と紹介する をみていて vhs という cli でアニメ gif を作ってくれることを知った。試しにやってみた。ターミナルを録画するようなやり方と比べて、録画時にタイプミスしてしまうようなミスを防げる。次のようなスクリプトファイルを新規作成する。
$ vhs new bf.tape Output bf.gif Require echo Set Shell &amp;#34;bash&amp;#34; Set FontSize 14 Set Width 800 Set Height 380 Type &amp;#34;genact -m bruteforce&amp;#34; Sleep 500ms Enter Sleep 10s あとはこの設定でアニメ gif を作る。</description><content>&lt;p>23時過ぎに寝始めて何度か起きて7時半に起きた。&lt;/p>
&lt;p>今日の筋トレは腹筋:10x1,腕立て:10x1,スクワット15x1をした。&lt;/p>
&lt;h2 id="sveltekit-で-context-のデータを扱う">sveltekit で context のデータを扱う&lt;/h2>
&lt;p>ui 側でページに依存しない形で設定情報などを扱いたいとする。svelte の store と context api を組み合わせて sveltekit として context を管理するサンプルコードが紹介されている。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://kit.svelte.jp/docs/state-management#using-stores-with-context">context と共に store を使う&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>これだけですぐ動くのだけど、このときに &lt;code>LayoutData&lt;/code> はサーバー側で作るとバックエンドの仕組みを隠蔽できて嬉しい。そういったときは &lt;code>src/routes/+layout.server.ts&lt;/code> にバックエンドの api 呼び出しを隠蔽することで意図した振る舞いになる。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-typescript" data-lang="typescript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">import&lt;/span> &lt;span style="color:#66d9ef">type&lt;/span> { &lt;span style="color:#a6e22e">LayoutServerLoad&lt;/span> } &lt;span style="color:#66d9ef">from&lt;/span> &lt;span style="color:#e6db74">&amp;#34;./$types&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">export&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">load&lt;/span>: &lt;span style="color:#66d9ef">LayoutServerLoad&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">async&lt;/span> () &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">await&lt;/span> &lt;span style="color:#a6e22e">fetch&lt;/span>(&lt;span style="color:#e6db74">`localhost:18080/myapi`&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">json&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="アニメ-gif-をスクリプトから作る">アニメ gif をスクリプトから作る&lt;/h2>
&lt;p>&lt;a href="https://zenn.dev/kou_pg_0131/articles/favorite-cli-tools">お気に入りのコマンドラインツールを淡々と紹介する&lt;/a> をみていて &lt;a href="https://github.com/charmbracelet/vhs">vhs&lt;/a> という cli でアニメ gif を作ってくれることを知った。試しにやってみた。ターミナルを録画するようなやり方と比べて、録画時にタイプミスしてしまうようなミスを防げる。次のようなスクリプトファイルを新規作成する。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ vhs new bf.tape
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre tabindex="0">&lt;code>Output bf.gif
Require echo
Set Shell &amp;#34;bash&amp;#34;
Set FontSize 14
Set Width 800
Set Height 380
Type &amp;#34;genact -m bruteforce&amp;#34; Sleep 500ms Enter
Sleep 10s
&lt;/code>&lt;/pre>&lt;p>あとはこの設定でアニメ gif を作る。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ vhs bf.tape
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;figure>&lt;img src="/diary/diary/img/2024/0110_bf.gif"/>
&lt;/figure>
&lt;p>これで 4.8 MiB なのでサイズはまぁまぁ大きい。サイズやカラーの調整をすればもう1桁は縮小できるかもしれない。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ ls -lh img/2024/0110_bf.gif
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-rw-rw-r-- &lt;span style="color:#ae81ff">1&lt;/span> 4.8M 1月 &lt;span style="color:#ae81ff">10&lt;/span> 19:48 img/2024/0110_bf.gif
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></content></item><item><title>gitlab issues と mongodb による分析</title><link>/diary/posts/2023/0511/</link><pubDate>Thu, 11 May 2023 09:06:56 +0900</pubDate><guid>/diary/posts/2023/0511/</guid><description>0時に寝て何度か起きて7時に起きた。今日も一日資料作りをしていた。
gitlab issues の解析 ふりかえりの資料を作っていて gitlab issues の解析を始めた。gitlab にも分析系機能は提供されているが、大半が有償機能で free では使えない。実質 free で役に立ちそうなレポートを私はみつけられなかった。
Analyze GitLab usage gitlab は glab cli というツールを提供している。試しに glab を使って issues の解析ができないかとやってみたが、グループ単位ではなくプロジェクト単位でしか操作できないようにみえた。そこで rest api を呼び出すための便利ツールとして使うことにした。要は rest api で任意のデータを取得してそれを使ってローカルで解析することにした。例えば、次のようにして特定ラベルを除外した特定グループのマイルストーンごとの issues をすべて取得できる。
$ mygrpid=&amp;#34;xxx&amp;#34; $ milestones=&amp;#34;2022-11 2022-12 2023-01 2023-02 2023-03 2023-04&amp;#34; $ for i in $milestones; do echo $i; glab api --paginate &amp;#34;groups/${mygrpid}/issues?milestone=${i}&amp;amp;not[labels]=Duplicate,Invalid,Wontfix&amp;#34; | jq -c &amp;#39;.[]&amp;#39; &amp;gt; &amp;#34;${i}-issues.json&amp;#34;; done あとはこの json データをそのまま分析のためのデータベースに取り込む。今回は mongodb にインポートしてみた。mongodb だとスキーマを定義しなくても json データをそのままインポートできてアドホックな分析に便利そうに思えた。オブジェクトの入れ子構造をもつ json データのようなものを rdbms にインポートするのはひと工夫必要なことから json データをそのままインポートできるドキュメントデータベースの有効性を理解できた。インポートしたら MongoDB Shell を使うとてっとり早い。例えば、マイルストーンごとの issues の件数などは次のようにして集計できる。</description><content>&lt;p>0時に寝て何度か起きて7時に起きた。今日も一日資料作りをしていた。&lt;/p>
&lt;h2 id="gitlab-issues-の解析">gitlab issues の解析&lt;/h2>
&lt;p>ふりかえりの資料を作っていて gitlab issues の解析を始めた。gitlab にも分析系機能は提供されているが、大半が有償機能で free では使えない。実質 free で役に立ちそうなレポートを私はみつけられなかった。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.gitlab.com/ee/user/analytics/">Analyze GitLab usage&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>gitlab は &lt;a href="https://gitlab.com/gitlab-org/cli">glab cli&lt;/a> というツールを提供している。試しに glab を使って issues の解析ができないかとやってみたが、グループ単位ではなくプロジェクト単位でしか操作できないようにみえた。そこで rest api を呼び出すための便利ツールとして使うことにした。要は rest api で任意のデータを取得してそれを使ってローカルで解析することにした。例えば、次のようにして特定ラベルを除外した特定グループのマイルストーンごとの issues をすべて取得できる。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ mygrpid&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;xxx&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ milestones&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;2022-11 2022-12 2023-01 2023-02 2023-03 2023-04&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ &lt;span style="color:#66d9ef">for&lt;/span> i in $milestones; &lt;span style="color:#66d9ef">do&lt;/span> echo $i; glab api --paginate &lt;span style="color:#e6db74">&amp;#34;groups/&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>mygrpid&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/issues?milestone=&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>i&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;amp;not[labels]=Duplicate,Invalid,Wontfix&amp;#34;&lt;/span> | jq -c &lt;span style="color:#e6db74">&amp;#39;.[]&amp;#39;&lt;/span> &amp;gt; &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>i&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">-issues.json&amp;#34;&lt;/span>; &lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>あとはこの json データをそのまま分析のためのデータベースに取り込む。今回は mongodb にインポートしてみた。mongodb だとスキーマを定義しなくても json データをそのままインポートできてアドホックな分析に便利そうに思えた。オブジェクトの入れ子構造をもつ json データのようなものを rdbms にインポートするのはひと工夫必要なことから json データをそのままインポートできるドキュメントデータベースの有効性を理解できた。インポートしたら &lt;a href="https://www.mongodb.com/products/shell">MongoDB Shell&lt;/a> を使うとてっとり早い。例えば、マイルストーンごとの issues の件数などは次のようにして集計できる。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>gitlab&amp;gt; db.issues.aggregate&lt;span style="color:#f92672">([{&lt;/span> $group: &lt;span style="color:#f92672">{&lt;/span> &lt;span style="color:#e6db74">&amp;#34;_id&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$milestone&lt;span style="color:#e6db74">.title&amp;#34;&lt;/span>, count: &lt;span style="color:#f92672">{&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$sum&lt;span style="color:#e6db74">&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#f92672">}&lt;/span>, &lt;span style="color:#f92672">{&lt;/span> $sort: &lt;span style="color:#f92672">{&lt;/span> _id: &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">}}])&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">{&lt;/span> _id: &lt;span style="color:#e6db74">&amp;#39;2022-11&amp;#39;&lt;/span>, count: &lt;span style="color:#ae81ff">348&lt;/span> &lt;span style="color:#f92672">}&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">{&lt;/span> _id: &lt;span style="color:#e6db74">&amp;#39;2022-12&amp;#39;&lt;/span>, count: &lt;span style="color:#ae81ff">346&lt;/span> &lt;span style="color:#f92672">}&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">{&lt;/span> _id: &lt;span style="color:#e6db74">&amp;#39;2023-01&amp;#39;&lt;/span>, count: &lt;span style="color:#ae81ff">338&lt;/span> &lt;span style="color:#f92672">}&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">{&lt;/span> _id: &lt;span style="color:#e6db74">&amp;#39;2023-02&amp;#39;&lt;/span>, count: &lt;span style="color:#ae81ff">357&lt;/span> &lt;span style="color:#f92672">}&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">{&lt;/span> _id: &lt;span style="color:#e6db74">&amp;#39;2023-03&amp;#39;&lt;/span>, count: &lt;span style="color:#ae81ff">347&lt;/span> &lt;span style="color:#f92672">}&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">{&lt;/span> _id: &lt;span style="color:#e6db74">&amp;#39;2023-04&amp;#39;&lt;/span>, count: &lt;span style="color:#ae81ff">336&lt;/span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>担当者別に &lt;code>Enhance&lt;/code> ラベルが付いた issues の件数を数えるときには次のようになる。sql を使えないというデメリットを json データをそのままインポートできるメリットの方が上回るときは mongodb のクエリを学ぶ機会になる。私も mongodb の aggregation の実行方法をドキュメントみながらやってた。全然わからないので慣れが必要になる。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>gitlab&amp;gt; db.issues.aggregate&lt;span style="color:#f92672">([{&lt;/span> $group: &lt;span style="color:#f92672">{&lt;/span> &lt;span style="color:#e6db74">&amp;#34;_id&amp;#34;&lt;/span>: &lt;span style="color:#f92672">{&lt;/span> assignee: &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$assignee&lt;span style="color:#e6db74">.username&amp;#34;&lt;/span>, enhance: &lt;span style="color:#f92672">{&lt;/span>$in: &lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Enhance&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$labels&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#f92672">]}&lt;/span> &lt;span style="color:#f92672">}&lt;/span>, count: &lt;span style="color:#f92672">{&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$sum&lt;span style="color:#e6db74">&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#f92672">}&lt;/span>, &lt;span style="color:#f92672">{&lt;/span>$match: &lt;span style="color:#f92672">{&lt;/span>&lt;span style="color:#e6db74">&amp;#34;_id.enhance&amp;#34;&lt;/span>: true&lt;span style="color:#f92672">}}&lt;/span>, &lt;span style="color:#f92672">{&lt;/span> $sort: &lt;span style="color:#f92672">{&lt;/span> _id: &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">}}])&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">{&lt;/span> _id: &lt;span style="color:#f92672">{&lt;/span> assignee: &lt;span style="color:#e6db74">&amp;#39;bob&amp;#39;&lt;/span>, enhance: true &lt;span style="color:#f92672">}&lt;/span>, count: &lt;span style="color:#ae81ff">84&lt;/span> &lt;span style="color:#f92672">}&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">{&lt;/span> _id: &lt;span style="color:#f92672">{&lt;/span> assignee: &lt;span style="color:#e6db74">&amp;#39;john&amp;#39;&lt;/span>, enhance: true &lt;span style="color:#f92672">}&lt;/span>, count: &lt;span style="color:#ae81ff">143&lt;/span> &lt;span style="color:#f92672">}&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">{&lt;/span> _id: &lt;span style="color:#f92672">{&lt;/span> assignee: &lt;span style="color:#e6db74">&amp;#39;mary&amp;#39;&lt;/span>, enhance: true &lt;span style="color:#f92672">}&lt;/span>, count: &lt;span style="color:#ae81ff">53&lt;/span> &lt;span style="color:#f92672">}&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">{&lt;/span> _id: &lt;span style="color:#f92672">{&lt;/span> assignee: &lt;span style="color:#e6db74">&amp;#39;parks&amp;#39;&lt;/span>, enhance: true &lt;span style="color:#f92672">}&lt;/span>, count: &lt;span style="color:#ae81ff">78&lt;/span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></content></item><item><title>ローカルのゲスト os に開発環境を作る</title><link>/diary/posts/2023/0412/</link><pubDate>Wed, 12 Apr 2023 09:30:05 +0900</pubDate><guid>/diary/posts/2023/0412/</guid><description>0時に寝て7時に起きた。いろいろうまくいってない。
vagrant 再び rpm でパッケージングされた openldap サーバーの動作検証をするために vagrant で rockylinux/8 Vagrant box の環境を構築する。 rockylinux 8 だと次のようなエラーが発生した。
VBoxManage: error: Failed to open OVF file &amp;#39;path/to/.vagrant.d/boxes/rockylinux-VAGRANTSLASH-8/7.0.0/virtualbox/box.ovf&amp;#39; (VERR_FILE_NOT_FOUND) 既知のバグとして次の forum にワークアラウンドが書かれている。
Vagrant box rockylinux/8 fails for virtualbox provider with error VBOX_E_OBJECT_NOT_FOUND uefi なマシンのせいなのかな？詳細を理解していないけど Vagrantfile を次のようにする。
Vagrant.configure(&amp;#34;2&amp;#34;) do |config| config.vm.box = &amp;#34;rockylinux/8&amp;#34; config.vm.provider &amp;#34;virtualbox&amp;#34; do |domain| domain.customize [&amp;#34;modifyvm&amp;#34;, :id, &amp;#34;--firmware&amp;#34;, &amp;#34;efi&amp;#34;] end end 修正済みのイメージをダウンロードするようにメタデータを作成する。
$ vi box-metadata.json { &amp;#34;name&amp;#34; : &amp;#34;rockylinux/8&amp;#34;, &amp;#34;description&amp;#34; : &amp;#34;Rocky Linux 8 7.</description><content>&lt;p>0時に寝て7時に起きた。いろいろうまくいってない。&lt;/p>
&lt;h2 id="vagrant-再び">vagrant 再び&lt;/h2>
&lt;p>rpm でパッケージングされた openldap サーバーの動作検証をするために vagrant で &lt;a href="https://app.vagrantup.com/rockylinux/boxes/8">rockylinux/8 Vagrant box&lt;/a> の環境を構築する。 rockylinux 8 だと次のようなエラーが発生した。&lt;/p>
&lt;pre tabindex="0">&lt;code>VBoxManage: error: Failed to open OVF file &amp;#39;path/to/.vagrant.d/boxes/rockylinux-VAGRANTSLASH-8/7.0.0/virtualbox/box.ovf&amp;#39; (VERR_FILE_NOT_FOUND)
&lt;/code>&lt;/pre>&lt;p>既知のバグとして次の forum にワークアラウンドが書かれている。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://forums.rockylinux.org/t/vagrant-box-rockylinux-8-fails-for-virtualbox-provider-with-error-vbox-e-object-not-found/8228/4">Vagrant box rockylinux/8 fails for virtualbox provider with error VBOX_E_OBJECT_NOT_FOUND&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>uefi なマシンのせいなのかな？詳細を理解していないけど Vagrantfile を次のようにする。&lt;/p>
&lt;pre tabindex="0">&lt;code>Vagrant.configure(&amp;#34;2&amp;#34;) do |config|
config.vm.box = &amp;#34;rockylinux/8&amp;#34;
config.vm.provider &amp;#34;virtualbox&amp;#34; do |domain|
domain.customize [&amp;#34;modifyvm&amp;#34;, :id, &amp;#34;--firmware&amp;#34;, &amp;#34;efi&amp;#34;]
end
end
&lt;/code>&lt;/pre>&lt;p>修正済みのイメージをダウンロードするようにメタデータを作成する。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ vi box-metadata.json
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span> : &lt;span style="color:#e6db74">&amp;#34;rockylinux/8&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;description&amp;#34;&lt;/span> : &lt;span style="color:#e6db74">&amp;#34;Rocky Linux 8 7.0.0 Bugfix&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;versions&amp;#34;&lt;/span> : [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;version&amp;#34;&lt;/span> : &lt;span style="color:#e6db74">&amp;#34;7.0.1-20221213.0&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;providers&amp;#34;&lt;/span> : [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span> : &lt;span style="color:#e6db74">&amp;#34;virtualbox&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;url&amp;#34;&lt;/span> : &lt;span style="color:#e6db74">&amp;#34;http://dl.rockylinux.org/pub/rocky/8/images/x86_64/Rocky-8-Vagrant-Vbox-8.7-20221213.0.x86_64.box&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>再度 vagrant の環境を作り直す。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ vagrant box add box-metadata.json
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ rm -rf .vagrant/ &lt;span style="color:#75715e"># 古い設定を削除&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ vagrant up
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>vagrant を使うのも4年ぶりになるかな。コンテナに慣れてしまうと久しぶり感がある。使い方を忘れていて調べながらやってた。&lt;/p>
&lt;h3 id="vagrant-にポートフォワーディングの設定を追加">vagrant にポートフォワーディングの設定を追加&lt;/h3>
&lt;pre tabindex="0">&lt;code>$ vi Vagrantfile
...
config.vm.network &amp;#34;forwarded_port&amp;#34;, guest: 389, host: 1389 # ldap
config.vm.network &amp;#34;forwarded_port&amp;#34;, guest: 636, host: 1636 # ldaps
...
&lt;/code>&lt;/pre>&lt;p>これでホスト os からゲスト os へ接続できる。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-console" data-lang="console">&lt;span style="display:flex;">&lt;span>==&amp;gt; default: Forwarding ports...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> default: 389 (guest) =&amp;gt; 1389 (host) (adapter 1)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> default: 636 (guest) =&amp;gt; 1636 (host) (adapter 1)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> default: 22 (guest) =&amp;gt; 2222 (host) (adapter 1)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここでは ldap サーバーに対して &lt;a href="https://directory.apache.org/studio/">Apache Directory Studio&lt;/a> で接続できるように ssh のポートフォワーディングを設定している。&lt;/p>
&lt;h3 id="scp-でファイルを転送">scp でファイルを転送&lt;/h3>
&lt;p>config を出力する。ssh の秘密鍵へのパス設定をしてくれるので scp のオプションに指定しなくて済む。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ vagrant ssh-config &amp;gt; ssh.config
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ポート番号も config に記載されているけれど、それは指定しないと scp できなかった。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ scp -P &lt;span style="color:#ae81ff">2200&lt;/span> -F ssh.config path/to/myfile vagrant@localhost:
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>vagrant ユーザーのパスワードも聞かれて vagrant を指定すればコピーできた。config を作ってもあまり便利ではなかった。&lt;/p>
&lt;p>&lt;a href="https://github.com/invernizzi/vagrant-scp">vagrant-scp&lt;/a> というプラグインがあるのでインストールしてみる。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ vagrant plugin install vagrant-scp
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>次のようにして使う。この方が簡単。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ vagrant scp path/to/myfile ./ &lt;span style="color:#75715e"># 仮想マシンのホームディレクトリにコピーされる&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></content></item><item><title>rsync に daemon モードがあるらしい</title><link>/diary/posts/2023/0405/</link><pubDate>Wed, 05 Apr 2023 11:24:21 +0900</pubDate><guid>/diary/posts/2023/0405/</guid><description>23時に寝て2時半に起きて4時や5時に起きて7時に起きた。泊まっているホテルの低反発枕の寝心地がよい。
rsync daemon over ssh 外部向けのドキュメントを公開するための gitlab ci/cd を構築した。web サーバにドキュメントをアップロードする手段として rsync を使っている。rsync over ssh でデータを転送するときにさらに daemon モード (rsyncd) という仕組みがあって、権限や書き込み先の acl なども細かく制御できる。手順や設定は古の古臭い雰囲気はするけれど、実用的には ssh の秘密鍵を使ってちょっと高機能なアップロードを実現できる。ssh agent で鍵登録できていれば次のような cli でセキュアに rsync できる。全然知らない方法だったので学びの1つになった。
$ rsync \ --verbose \ --rsh ssh \ --stats \ --compress-choice=zstd \ --compress-level=10 \ --itemize-changes \ --recursive \ --checksum \ --delete \ local/ ${USER}@${HOST}::${RSYNC_DIR} rsync+sshはdaemonモードを使うと更に安全になる LLMを使ってみる会 LLMを使ってみる会 に参加した。私も chatgpt に調べものやちょっとしたことを聞くようになったりしているが、他の人たちがどんな用途に使っているのかも知りたくて参加してみた。fin-py のイベントだったのでみんな金融系のドキュメントの要約に使っているのが多そうにみえた。あとは研究テーマとして gpt/llm を取り上げている人たちも何人かいた。</description><content>&lt;p>23時に寝て2時半に起きて4時や5時に起きて7時に起きた。泊まっているホテルの低反発枕の寝心地がよい。&lt;/p>
&lt;h2 id="rsync-daemon-over-ssh">rsync daemon over ssh&lt;/h2>
&lt;p>外部向けのドキュメントを公開するための gitlab ci/cd を構築した。web サーバにドキュメントをアップロードする手段として rsync を使っている。rsync over ssh でデータを転送するときにさらに daemon モード (rsyncd) という仕組みがあって、権限や書き込み先の acl なども細かく制御できる。手順や設定は古の古臭い雰囲気はするけれど、実用的には ssh の秘密鍵を使ってちょっと高機能なアップロードを実現できる。ssh agent で鍵登録できていれば次のような cli でセキュアに rsync できる。全然知らない方法だったので学びの1つになった。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ rsync &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --verbose &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --rsh ssh &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --stats &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --compress-choice&lt;span style="color:#f92672">=&lt;/span>zstd &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --compress-level&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">10&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --itemize-changes &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --recursive &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --checksum &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --delete &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> local/ &lt;span style="color:#e6db74">${&lt;/span>USER&lt;span style="color:#e6db74">}&lt;/span>@&lt;span style="color:#e6db74">${&lt;/span>HOST&lt;span style="color:#e6db74">}&lt;/span>::&lt;span style="color:#e6db74">${&lt;/span>RSYNC_DIR&lt;span style="color:#e6db74">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;a href="https://jyn.jp/rsync-daemon-over-ssh/">rsync+sshはdaemonモードを使うと更に安全になる&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="llmを使ってみる会">LLMを使ってみる会&lt;/h2>
&lt;p>&lt;a href="https://fin-py.connpass.com/event/279271/">LLMを使ってみる会&lt;/a> に参加した。私も chatgpt に調べものやちょっとしたことを聞くようになったりしているが、他の人たちがどんな用途に使っているのかも知りたくて参加してみた。fin-py のイベントだったのでみんな金融系のドキュメントの要約に使っているのが多そうにみえた。あとは研究テーマとして gpt/llm を取り上げている人たちも何人かいた。&lt;/p></content></item><item><title>docker/compose のモジュールの使い方がわかってきた</title><link>/diary/posts/2023/0327/</link><pubDate>Mon, 27 Mar 2023 08:09:28 +0900</pubDate><guid>/diary/posts/2023/0327/</guid><description>0時に寝て7時に起きた。前日はバテてだらだらしていたので寝過ぎた。
案ずるよりもツールできた 先週末に docker/compose 関連のライブラリ調査 を終えて実際のツール作りをしていた。本当は日曜日に作ってしまおうと思いつつ休んでしまった。なぜか今日はメンバーが全員お休みでチームで私しか働いていなかった。年度末で有休消化しているのかな？問い合わせ対応やメンバーのサポートが不要だったので1日中、自分の開発に集中できた。そして開発に集中できた結果、一通りツールの機能の開発を終えられた。火曜日までには仕上げたいと思っていたのでぎりぎり間に合った。
最終的に testcontainers-go の compose モジュールを使うのは断念して compose cli のみ go 標準の os/exec パッケージを使ってプロセスを fork するようにした。また docker image をコンテナレジストリから取得するときに認証が必要な場合、最初の docker login すると credentials store にパスワード (またはトークン) 情報が記録される。設定情報は $HOME/.docker/config.json からも確認できる。この仕組みを使ってコンテナレジストリへのログインを自動化できる。私の環境では macbook に docker desktop をインストールしているが、普通に使っていると次のように credentials が保存されてその内容を確認できる。
$ docker-credential-desktop list | jq . { &amp;#34;https://index.docker.io/v1/&amp;#34;: &amp;#34;t2y1979&amp;#34;, &amp;#34;https://index.docker.io/v1/access-token&amp;#34;: &amp;#34;t2y1979&amp;#34;, &amp;#34;https://index.docker.io/v1/refresh-token&amp;#34;: &amp;#34;t2y1979&amp;#34; } $ echo &amp;#34;https://index.docker.io/v1/access-token&amp;#34; | docker-credential-desktop get {&amp;#34;ServerURL&amp;#34;:&amp;#34;https://index.docker.io/v1/access-token&amp;#34;,&amp;#34;Username&amp;#34;:&amp;#34;t2y1979&amp;#34;,&amp;#34;Secret&amp;#34;:&amp;#34;***&amp;#34;} これと同じことを docker のライブラリで行うには次のようにする。取得したい docker image の uri を参照すればコンテナレジストリがわかる。そこからこの cli でやっているようなことを順番にやっていけばよい。これらのユーティリティは3つのリポジトリで管理されていて、この雰囲気をみただけでもこのモジュール分割が本当に適切なんやろか？とか思ったりもする。</description><content>&lt;p>0時に寝て7時に起きた。前日はバテてだらだらしていたので寝過ぎた。&lt;/p>
&lt;h2 id="案ずるよりもツールできた">案ずるよりもツールできた&lt;/h2>
&lt;p>先週末に &lt;a href="/diary/diary/posts/2023/0324/">docker/compose 関連のライブラリ調査&lt;/a> を終えて実際のツール作りをしていた。本当は日曜日に作ってしまおうと思いつつ休んでしまった。なぜか今日はメンバーが全員お休みでチームで私しか働いていなかった。年度末で有休消化しているのかな？問い合わせ対応やメンバーのサポートが不要だったので1日中、自分の開発に集中できた。そして開発に集中できた結果、一通りツールの機能の開発を終えられた。火曜日までには仕上げたいと思っていたのでぎりぎり間に合った。&lt;/p>
&lt;p>最終的に testcontainers-go の compose モジュールを使うのは断念して compose cli のみ go 標準の &lt;a href="https://pkg.go.dev/os/exec">os/exec&lt;/a> パッケージを使ってプロセスを fork するようにした。また docker image をコンテナレジストリから取得するときに認証が必要な場合、最初の &lt;a href="https://docs.docker.com/engine/reference/commandline/login/">docker login&lt;/a> すると credentials store にパスワード (またはトークン) 情報が記録される。設定情報は &lt;code>$HOME/.docker/config.json&lt;/code> からも確認できる。この仕組みを使ってコンテナレジストリへのログインを自動化できる。私の環境では macbook に docker desktop をインストールしているが、普通に使っていると次のように credentials が保存されてその内容を確認できる。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ docker-credential-desktop list | jq .
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;https://index.docker.io/v1/&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;t2y1979&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;https://index.docker.io/v1/access-token&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;t2y1979&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;https://index.docker.io/v1/refresh-token&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;t2y1979&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ echo &lt;span style="color:#e6db74">&amp;#34;https://index.docker.io/v1/access-token&amp;#34;&lt;/span> | docker-credential-desktop get
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">{&lt;/span>&lt;span style="color:#e6db74">&amp;#34;ServerURL&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;https://index.docker.io/v1/access-token&amp;#34;&lt;/span>,&lt;span style="color:#e6db74">&amp;#34;Username&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;t2y1979&amp;#34;&lt;/span>,&lt;span style="color:#e6db74">&amp;#34;Secret&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;***&amp;#34;&lt;/span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これと同じことを docker のライブラリで行うには次のようにする。取得したい docker image の uri を参照すればコンテナレジストリがわかる。そこからこの cli でやっているようなことを順番にやっていけばよい。これらのユーティリティは3つのリポジトリで管理されていて、この雰囲気をみただけでもこのモジュール分割が本当に適切なんやろか？とか思ったりもする。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/distribution/distribution">https://github.com/distribution/distribution&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/docker/cli">https://github.com/docker/cli&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/moby/moby">https://github.com/moby/moby&lt;/a>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">getRegistryAuthFromImage&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ctx&lt;/span> &lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#a6e22e">imageURI&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) (&lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#66d9ef">error&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ref&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">reference&lt;/span>.&lt;span style="color:#a6e22e">ParseNormalizedNamed&lt;/span>(&lt;span style="color:#a6e22e">imageURI&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Errorf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;failed to parse image uri: %w&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">repo&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">registry&lt;/span>.&lt;span style="color:#a6e22e">ParseRepositoryInfo&lt;/span>(&lt;span style="color:#a6e22e">ref&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Errorf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;failed to parse repository: %w&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">dcli&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">command&lt;/span>.&lt;span style="color:#a6e22e">NewDockerCli&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Errorf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;failed to create docker cli: %w&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">auth&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">command&lt;/span>.&lt;span style="color:#a6e22e">ResolveAuthConfig&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span>, &lt;span style="color:#a6e22e">dcli&lt;/span>, &lt;span style="color:#a6e22e">repo&lt;/span>.&lt;span style="color:#a6e22e">Index&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">encoded&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">command&lt;/span>.&lt;span style="color:#a6e22e">EncodeAuthToBase64&lt;/span>(&lt;span style="color:#a6e22e">auth&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Errorf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;failed to encode auth: %w&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">encoded&lt;/span>, &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></content></item><item><title>postgresql の json データ型</title><link>/diary/posts/2022/0926/</link><pubDate>Mon, 26 Sep 2022 08:01:22 +0900</pubDate><guid>/diary/posts/2022/0926/</guid><description>1時に寝て6時半に起きた。連休中に夜更ししてたから生活が乱れた。
ロガー向けのログ保存 API の開発 先週の休暇前にやっていた作業の開発に着手。一通り web api のエンドポイントの実装は終えてテストをあらかた書いたところ。いまのプロジェクトとしても、過去の私の経験としてもやったことのない新しい挑戦の1つとして postgresql の JSONデータ型 を使う。具体的には json 型と jsonb 型の2つがある。前者はテキストで保持する型で、後者は内部的にバイナリに変換されてインデックスも使える。バイナリに変換してインデックスを作る分、insert 時にテキストで保存するよりは少し余分なオーバーヘッドを要する。json のデータを参照用途で使うのか、検索するのかでこれらの型を使い分ければいいのかな。
実際の sql で json データの条件指定は次のようになる。@&amp;gt; というみたこともない気持ち悪い演算子を使う。
&amp;gt; select * from mytable where data @&amp;gt; &amp;#39;{&amp;#34;x&amp;#34;: 1, &amp;#34;y&amp;#34;: 2}&amp;#39;; java の jdbc で扱うには PGobject という型に変換して扱う必要がある。
private PGobject convertData(String value) throws SQLException { var data = new PGobject(); data.setType(&amp;#34;jsonb&amp;#34;); data.setValue(value); return data; } 余談だけど、curl で json 文字列を query string としてリクエストするには url encode しないといけない。
$ curl -s --get --data-urlencode &amp;#39;data={&amp;#34;x&amp;#34;: 1, &amp;#34;y&amp;#34;: 2}&amp;#39; http://localhost/path | jq .</description><content>&lt;p>1時に寝て6時半に起きた。連休中に夜更ししてたから生活が乱れた。&lt;/p>
&lt;h2 id="ロガー向けのログ保存-api-の開発">ロガー向けのログ保存 API の開発&lt;/h2>
&lt;p>先週の休暇前にやっていた作業の開発に着手。一通り web api のエンドポイントの実装は終えてテストをあらかた書いたところ。いまのプロジェクトとしても、過去の私の経験としてもやったことのない新しい挑戦の1つとして postgresql の &lt;a href="https://www.postgresql.jp/document/13/html/datatype-json.html">JSONデータ型&lt;/a> を使う。具体的には json 型と jsonb 型の2つがある。前者はテキストで保持する型で、後者は内部的にバイナリに変換されてインデックスも使える。バイナリに変換してインデックスを作る分、insert 時にテキストで保存するよりは少し余分なオーバーヘッドを要する。json のデータを参照用途で使うのか、検索するのかでこれらの型を使い分ければいいのかな。&lt;/p>
&lt;p>実際の sql で json データの条件指定は次のようになる。&lt;code>@&amp;gt;&lt;/code> というみたこともない気持ち悪い演算子を使う。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">select&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">from&lt;/span> mytable &lt;span style="color:#66d9ef">where&lt;/span> &lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#f92672">@&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;{&amp;#34;x&amp;#34;: 1, &amp;#34;y&amp;#34;: 2}&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>java の jdbc で扱うには &lt;em>PGobject&lt;/em> という型に変換して扱う必要がある。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> PGobject &lt;span style="color:#a6e22e">convertData&lt;/span>(String value) &lt;span style="color:#66d9ef">throws&lt;/span> SQLException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> data &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> PGobject();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> data.&lt;span style="color:#a6e22e">setType&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;jsonb&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> data.&lt;span style="color:#a6e22e">setValue&lt;/span>(value);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> data;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>余談だけど、curl で json 文字列を query string としてリクエストするには url encode しないといけない。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ curl -s --get --data-urlencode &lt;span style="color:#e6db74">&amp;#39;data={&amp;#34;x&amp;#34;: 1, &amp;#34;y&amp;#34;: 2}&amp;#39;&lt;/span> http://localhost/path | jq .
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></content></item><item><title>k8s の cronjob を検証中</title><link>/diary/posts/2022/0622/</link><pubDate>Wed, 22 Jun 2022 18:58:20 +0900</pubDate><guid>/diary/posts/2022/0622/</guid><description>0時に寝て6時に起きた。寝不足を解消して体調が戻ってきた。
k8s の cronjob バッチ処理を Kubernetes: CronJob で作る。一通り設定して minikube で検証して eks 上でも動くようになった。
apiVersion: batch/v1 kind: CronJob metadata: name: my-app-hourly-job spec: schedule: &amp;#34;5 */1 * * *&amp;#34; concurrencyPolicy: Forbid startingDeadlineSeconds: 600 jobTemplate: spec: backoffLimit: 0 template: metadata: labels: app: my-app-hourly annotations: dapr.io/enabled: &amp;#34;true&amp;#34; dapr.io/app-id: &amp;#34;my-app-hourly&amp;#34; spec: containers: - name: my-app-hourly-job image: my-app-image imagePullPolicy: Always env: - name: BATCH_ENV value: &amp;#34;dev&amp;#34; command: - &amp;#34;/bin/sh&amp;#34; - &amp;#34;/app/scripts/my-app.sh&amp;#34; - &amp;#34;param1&amp;#34; - &amp;#34;param2&amp;#34; restartPolicy: Never command の設定がわかりにくい。さらに k8s のドキュメントのサンプル設定も誤解を招くような例になっている。どうも実行できるのは1つの cli だけで、複数コマンドを指定できるわけではない。シェルスクリプトを docker イメージに含めて、そこで任意のスクリプトを実装した方がよいだろう。</description><content>&lt;p>0時に寝て6時に起きた。寝不足を解消して体調が戻ってきた。&lt;/p>
&lt;h2 id="k8s-の-cronjob">k8s の cronjob&lt;/h2>
&lt;p>バッチ処理を &lt;a href="https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/">Kubernetes: CronJob&lt;/a> で作る。一通り設定して minikube で検証して eks 上でも動くようになった。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yml" data-lang="yml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">batch/v1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">CronJob&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">my-app-hourly-job&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">spec&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">schedule&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;5 */1 * * *&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">concurrencyPolicy&lt;/span>: &lt;span style="color:#ae81ff">Forbid&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">startingDeadlineSeconds&lt;/span>: &lt;span style="color:#ae81ff">600&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">jobTemplate&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">spec&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">backoffLimit&lt;/span>: &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">template&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">labels&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">app&lt;/span>: &lt;span style="color:#ae81ff">my-app-hourly&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">annotations&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">dapr.io/enabled&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;true&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">dapr.io/app-id&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;my-app-hourly&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">spec&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">containers&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">my-app-hourly-job&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">image&lt;/span>: &lt;span style="color:#ae81ff">my-app-image&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">imagePullPolicy&lt;/span>: &lt;span style="color:#ae81ff">Always&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">env&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">BATCH_ENV&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">value&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;dev&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">command&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#34;/bin/sh&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#34;/app/scripts/my-app.sh&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#34;param1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#34;param2&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">restartPolicy&lt;/span>: &lt;span style="color:#ae81ff">Never&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>command の設定がわかりにくい。さらに k8s のドキュメントのサンプル設定も誤解を招くような例になっている。どうも実行できるのは1つの cli だけで、複数コマンドを指定できるわけではない。シェルスクリプトを docker イメージに含めて、そこで任意のスクリプトを実装した方がよいだろう。&lt;/p>
&lt;ul>
&lt;li>&amp;ldquo;/bin/sh&amp;rdquo;&lt;/li>
&lt;li>&amp;ldquo;/app/scripts/my-app.sh&amp;rdquo;&lt;/li>
&lt;li>&amp;ldquo;param1&amp;rdquo;&lt;/li>
&lt;li>&amp;ldquo;param2&amp;rdquo;&lt;/li>
&lt;/ul>
&lt;p>この設定は次の cli として実行される。&lt;/p>
&lt;blockquote>
&lt;p>/bin/sh /app/scripts/my-app.sh param1 param2&lt;/p>
&lt;/blockquote>
&lt;p>&lt;a href="https://stackoverflow.com/questions/51657105/how-to-ensure-kubernetes-cronjob-does-not-restart-on-failure">How to ensure kubernetes cronjob does not restart on failure&lt;/a> によると、バッチ処理が失敗したときに再実行したくないときは次の3つの設定をする。&lt;/p>
&lt;ul>
&lt;li>concurrencyPolicy: Forbid&lt;/li>
&lt;li>backoffLimit: 0&lt;/li>
&lt;li>restartPolicy: Never&lt;/li>
&lt;/ul>
&lt;p>restartPolicy が Never 以外だと、エラーが発生すると永遠に再実行されてしまうので障害時に2次被害を増やしてしまう懸念があったような気がする。&lt;/p>
&lt;p>あと、うちの環境は dapr 経由で他の pod サービスと通信しているので dapr を有効にしないと pod 間通信ができない。dapr はデーモンでずっと起動しているからバッチ処理の終了時に daprd も shutdown してやらないといけない。&lt;a href="https://docs.dapr.io/operations/hosting/kubernetes/kubernetes-job/">Running Dapr with a Kubernetes Job&lt;/a> にその方法が書いてある。daprd を shutdown しないと、pod のステータスが NotReady のままで Completed にならない。&lt;/p>
&lt;p>まだまだよくわかってないので &lt;a href="https://kubernetes.io/docs/concepts/workloads/controllers/job/">Jobs&lt;/a> のドキュメントに一通り目を通そうと思っている。&lt;/p></content></item><item><title>maven で executable jar を作る</title><link>/diary/posts/2022/0621/</link><pubDate>Tue, 21 Jun 2022 10:28:55 +0900</pubDate><guid>/diary/posts/2022/0621/</guid><description>4時に寝て7時に起きた。
maven での executable jar の作り方 gradle では作ったことがあったけど、maven では初めてなので要領がわかっていない。
How to Create an Executable JAR with Maven How can I create an executable JAR with dependencies using Maven? これらの記事を読むと、maven-assembly-plugin を使えばいいのかな？とまずはこのプラグインで検証を始めた。古くからあるプラグインなので実績は十分なのだけど、もうあまり保守されていないのか、他プラグインから jar のマニフェストに書き込んで git のリビジョン番号が連携できてなかったり、通常の jar の生成処理を置き換えられなかったりと、あまり使い勝手のよいものではなかった。あと log4j2 と相性が悪くて意図したように設定ファイルを読み込んで初期化ができない。
main ERROR Error processing element EcsLayout: CLASS_NOT_FOUND main ERROR Unable to locate plugin type for EcsLayout main ERROR Unable to locate plugin for EcsLayout main ERROR Could not create plugin of type class org.</description><content>&lt;p>4時に寝て7時に起きた。&lt;/p>
&lt;h2 id="maven-での-executable-jar-の作り方">maven での executable jar の作り方&lt;/h2>
&lt;p>gradle では作ったことがあったけど、maven では初めてなので要領がわかっていない。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.baeldung.com/executable-jar-with-maven">How to Create an Executable JAR with Maven&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://stackoverflow.com/questions/574594/how-can-i-create-an-executable-jar-with-dependencies-using-maven">How can I create an executable JAR with dependencies using Maven?&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>これらの記事を読むと、&lt;a href="https://maven.apache.org/plugins/maven-assembly-plugin/">maven-assembly-plugin&lt;/a> を使えばいいのかな？とまずはこのプラグインで検証を始めた。古くからあるプラグインなので実績は十分なのだけど、もうあまり保守されていないのか、他プラグインから jar のマニフェストに書き込んで git のリビジョン番号が連携できてなかったり、通常の jar の生成処理を置き換えられなかったりと、あまり使い勝手のよいものではなかった。あと log4j2 と相性が悪くて意図したように設定ファイルを読み込んで初期化ができない。&lt;/p>
&lt;pre tabindex="0">&lt;code>main ERROR Error processing element EcsLayout: CLASS_NOT_FOUND
main ERROR Unable to locate plugin type for EcsLayout
main ERROR Unable to locate plugin for EcsLayout
main ERROR Could not create plugin of type class org.apache.logging.log4j.core.appender.ConsoleAppender for element Console:
java.lang.NullPointerException: Cannot invoke &amp;#34;org.apache.logging.log4j.core.config.plugins.util.PluginType.getElementName()&amp;#34;
because &amp;#34;childType&amp;#34; is null java.lang.NullPointerException:
Cannot invoke &amp;#34;org.apache.logging.log4j.core.config.plugins.util.PluginType.getElementName()&amp;#34; because &amp;#34;childType&amp;#34; is null
&lt;/code>&lt;/pre>&lt;p>この厄介な問題をデバッグするよりも、すでにうまくいくことがわかっている &lt;a href="https://docs.spring.io/spring-boot/docs/current/maven-plugin/reference/htmlsingle/">spring-boot-maven-plugin&lt;/a> を使った方が簡単そうだったのでそうすることにした。不要な spring boot 関連の jar なども executable jar や docker イメージに含まれてしまうことだけがデメリット。そこだけ目を瞑れば log4j2 の初期化エラーも起きず、正常に動作した。やっぱり最近のアプリケーションで使われているプラグインはちゃんとしてるねみたいな話しにしておく。次の設定だけでうまくいった。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-xml" data-lang="xml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;plugin&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>org.springframework.boot&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>spring-boot-maven-plugin&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;configuration&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;mainClass&amp;gt;&lt;/span>com.example.myapp.Main&lt;span style="color:#f92672">&amp;lt;/mainClass&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/configuration&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;executions&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;execution&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;goals&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;goal&amp;gt;&lt;/span>repackage&lt;span style="color:#f92672">&amp;lt;/goal&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/goals&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/execution&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;/executions&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;lt;/plugin&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></content></item><item><title>log4j2 の設定ファイルの動的な読み込み</title><link>/diary/posts/2022/0620/</link><pubDate>Mon, 20 Jun 2022 08:23:37 +0900</pubDate><guid>/diary/posts/2022/0620/</guid><description>0時に寝て7時に起きた。
バッチ処理モジュール cli でバッチ処理モジュールを作った。コマンドラインの引数パーサーと yml のパーサーを使うことにした。
picocli snakeyaml ロガー実装に log4j2 を使っているので設定ファイルはアプリケーションの設定ファイルと log4j2 の設定ファイルの2つになる。それぞれ環境ごとに用意してエントリーポイントから起動したタイミングで明示的に設定ファイルを読み込むようにした。
log4j2 の yml 設定ファイルを動的にどうやって設定するかはドキュメントにもとくに書いてなかった気がする。log4j2 のソースコードやテストコードを読みながら次のようにしたら反映された。
public static Config load(BatchEnvironment env) { var path = String.format(&amp;#34;config-%s.yml&amp;#34;, env.getName()); var inputStream = ConfigUtil.class.getClassLoader().getResourceAsStream(path); var yaml = new Yaml(new Constructor(Config.class)); return yaml.load(inputStream); } アプリケーションの設定は yml 設定に対応する Config クラスを定義しておいて次のようにして読み込む。
public static void initializeLogSettings(BatchEnvironment env) throws IOException { var path = String.format(&amp;#34;log4j2-%s.yml&amp;#34;, env.getName()); var inputStream = ConfigUtil.class.getClassLoader().getResourceAsStream(path); var source = new ConfigurationSource(inputStream); var configuration = new YamlConfigurationFactory().</description><content>&lt;p>0時に寝て7時に起きた。&lt;/p>
&lt;h2 id="バッチ処理モジュール">バッチ処理モジュール&lt;/h2>
&lt;p>cli でバッチ処理モジュールを作った。コマンドラインの引数パーサーと yml のパーサーを使うことにした。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://picocli.info/">picocli&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://bitbucket.org/snakeyaml/">snakeyaml&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>ロガー実装に &lt;a href="https://logging.apache.org/log4j/2.x/">log4j2&lt;/a> を使っているので設定ファイルはアプリケーションの設定ファイルと log4j2 の設定ファイルの2つになる。それぞれ環境ごとに用意してエントリーポイントから起動したタイミングで明示的に設定ファイルを読み込むようにした。&lt;/p>
&lt;p>log4j2 の yml 設定ファイルを動的にどうやって設定するかはドキュメントにもとくに書いてなかった気がする。log4j2 のソースコードやテストコードを読みながら次のようにしたら反映された。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> Config &lt;span style="color:#a6e22e">load&lt;/span>(BatchEnvironment env) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> path &lt;span style="color:#f92672">=&lt;/span> String.&lt;span style="color:#a6e22e">format&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;config-%s.yml&amp;#34;&lt;/span>, env.&lt;span style="color:#a6e22e">getName&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> inputStream &lt;span style="color:#f92672">=&lt;/span> ConfigUtil.&lt;span style="color:#a6e22e">class&lt;/span>.&lt;span style="color:#a6e22e">getClassLoader&lt;/span>().&lt;span style="color:#a6e22e">getResourceAsStream&lt;/span>(path);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> yaml &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Yaml(&lt;span style="color:#66d9ef">new&lt;/span> Constructor(Config.&lt;span style="color:#a6e22e">class&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> yaml.&lt;span style="color:#a6e22e">load&lt;/span>(inputStream);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>アプリケーションの設定は yml 設定に対応する &lt;code>Config&lt;/code> クラスを定義しておいて次のようにして読み込む。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">initializeLogSettings&lt;/span>(BatchEnvironment env) &lt;span style="color:#66d9ef">throws&lt;/span> IOException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> path &lt;span style="color:#f92672">=&lt;/span> String.&lt;span style="color:#a6e22e">format&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;log4j2-%s.yml&amp;#34;&lt;/span>, env.&lt;span style="color:#a6e22e">getName&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> inputStream &lt;span style="color:#f92672">=&lt;/span> ConfigUtil.&lt;span style="color:#a6e22e">class&lt;/span>.&lt;span style="color:#a6e22e">getClassLoader&lt;/span>().&lt;span style="color:#a6e22e">getResourceAsStream&lt;/span>(path);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> source &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ConfigurationSource(inputStream);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> configuration &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> YamlConfigurationFactory().&lt;span style="color:#a6e22e">getConfiguration&lt;/span>(&lt;span style="color:#66d9ef">null&lt;/span>, source);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Configurator.&lt;span style="color:#a6e22e">initialize&lt;/span>(configuration);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ちょっとした cli を作るときにちょっとしたライブラリがあると楽でよい。&lt;/p>
&lt;h2 id="欠損金の繰り戻し還付の申請の誤り">欠損金の繰り戻し還付の申請の誤り&lt;/h2>
&lt;p>国税局から電話がかかってきた。初めて提出した欠損金の繰り戻し還付の申請があちこち間違ってますよと。申請書類と一緒に法人税の申告書もみてもらっていて、還付申請した金額も申告の別表1に記入する必要があって、それも一緒に修正してねという話し。法人税の修正申告と還付の訂正依頼の2つが必要とのこと。税務署の人たちは本当に丁寧で親切にあれが間違っている、これが間違っていると教えてくれる。素人が法人決算やっているので初めて行う手続きの間違いはつきものだけど、税務署の人たちが教えてくれるので本当に助かる。感謝。&lt;/p></content></item></channel></rss>