<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>debug on forest nook</title><link>/diary/tags/debug/</link><description>Recent content in debug on forest nook</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><copyright>© 2021 Tetsuya Morimoto</copyright><lastBuildDate>Mon, 27 Nov 2023 18:50:24 +0900</lastBuildDate><atom:icon>/diary/favicon.ico</atom:icon><icon>/diary/favicon.ico</icon><atom:link href="/diary/tags/debug/index.xml" rel="self" type="application/rss+xml"/><item><title>sveltekit/vite アプリケーションの調査を再開</title><link>/diary/posts/2023/1127/</link><pubDate>Mon, 27 Nov 2023 18:50:24 +0900</pubDate><guid>/diary/posts/2023/1127/</guid><description>1時に寝て起きたか起きてないか覚えてない感じで6時に起きた。起きてちょっとゲームして気付いたら7時だった。
kit/vite アプリケーションのデバッグ 先週公開したテックブログ の続き。
vite アプリケーションのバックエンドインテグレーション の詳細を調査している。丸1日デバッグしていていくつか振る舞いがわかってきて、designer アプリケーションを作りたいという要件に対して、こうすればできるんじゃないかという仮説も立てられるようになった。いまやりたい要件は kit の ssr アプリケーションを埋め込みたい。これは要件に満たないが、kit の ssg アプリケーションならば static ディレクトリに置くだけで参照できるし、インポートパスさえ書き換えてやれば別の kit アプリに埋め込むこともできるのを確認した。意図した通りの振る舞い。
vite アプリケーションはビルドオプションで manifest.json を出力し、エントリーポイントやどのファイルがどのファイルをインポートしているかといった情報を管理している。sveltekit はこれらの manifest.json から rollup でバンドルするために manifest.js を生成している。厳密には、sveltekit では production ビルド向けのチューニングをしたビルドツールを adapter と呼び、vite のビルドをフックする場所に1つになっている。node.js サーバー向けに production ビルドするときは adapter-node を使う。この実装を読んでみると、vite がビルドした成果物に対して、再度 rollup でバンドルして成果物を作り直すといったことをしている。そして、vite の成果物 (manifest.json も含む) を抽象化したものが Builder となる。adapter は Builder のインスタンスを使ってビルドの成果物を制御できる。先の manifest.js もこのときに生成していて、rollup でバンドルするためのパラメーターの1つとして使っているようにみえる。しかし、rollup のドキュメントをみても直接的に manifest.js の説明はなく、rollup の拡張の仕組みで manifest.js を作っているというよりは、sveltekit の要件によるもののようにもみえる。ここの背景はまだよくわからない。
私はフロントエンドのことが全然わからないのでライブラリのソースコードを読みながら、ドキュメントとあわせて調べて、1つずつ理解を深めていくというアプローチで進めている。こういった調査のやり方もメンバーへ伝えていければと考えている。
小規模企業共済オンライン手続きポータル 2021年度から小規模企業共済 に加入している。今年から掛け金を7万円/月に変更した。年間で84万円の所得控除となる。ちょうど2023年9月1日からポータルサイトが作成されたらしい。いずれマイナポータルと紐付くのかもしれない。
「オンライン手続きポータル」を公開しました 利用登録しようと思って、メールアドレスを登録しようとしたら会社のメールアドレスはなぜかバリデーションエラーになって gmail のアドレスなら登録できた。その後も氏名の半角カナ入力を強制されたりしながら、マイナンバーカードを読み取って認証チェックして利用登録の申請はできた。しかし、自動で本登録されるわけではなく、おそらく申請内容が先方に届いてなんらかの運用があって本登録されるみたい。オンラインポータルのホームでも半角カナを使っていたり、&amp;lt;title&amp;gt; タグには「マイナ手続きポータル」とあったり、申請しただけでいくつも不備がわかるようなひどいサイトになっている。2023年にまともな開発者が作ったサイトとは思えない。デジタル庁に作り直してもらった方がよいと思う。</description><content>&lt;p>1時に寝て起きたか起きてないか覚えてない感じで6時に起きた。起きてちょっとゲームして気付いたら7時だった。&lt;/p>
&lt;h2 id="kitvite-アプリケーションのデバッグ">kit/vite アプリケーションのデバッグ&lt;/h2>
&lt;p>&lt;a href="/diary/diary/posts/2023/1124/#テックブログ公開">先週公開したテックブログ&lt;/a> の続き。&lt;/p>
&lt;p>&lt;a href="https://ja.vitejs.dev/guide/backend-integration.html">vite アプリケーションのバックエンドインテグレーション&lt;/a> の詳細を調査している。丸1日デバッグしていていくつか振る舞いがわかってきて、designer アプリケーションを作りたいという要件に対して、こうすればできるんじゃないかという仮説も立てられるようになった。いまやりたい要件は kit の ssr アプリケーションを埋め込みたい。これは要件に満たないが、kit の ssg アプリケーションならば static ディレクトリに置くだけで参照できるし、インポートパスさえ書き換えてやれば別の kit アプリに埋め込むこともできるのを確認した。意図した通りの振る舞い。&lt;/p>
&lt;p>vite アプリケーションはビルドオプションで manifest.json を出力し、エントリーポイントやどのファイルがどのファイルをインポートしているかといった情報を管理している。sveltekit はこれらの manifest.json から rollup でバンドルするために manifest.js を生成している。厳密には、sveltekit では production ビルド向けのチューニングをしたビルドツールを &lt;a href="https://kit.svelte.dev/docs/adapters">adapter&lt;/a> と呼び、vite のビルドをフックする場所に1つになっている。node.js サーバー向けに production ビルドするときは &lt;a href="https://kit.svelte.dev/docs/adapter-node">adapter-node&lt;/a> を使う。この実装を読んでみると、vite がビルドした成果物に対して、再度 rollup でバンドルして成果物を作り直すといったことをしている。そして、vite の成果物 (manifest.json も含む) を抽象化したものが &lt;a href="https://kit.svelte.dev/docs/types#public-types-builder">Builder&lt;/a> となる。adapter は Builder のインスタンスを使ってビルドの成果物を制御できる。先の manifest.js もこのときに生成していて、rollup でバンドルするためのパラメーターの1つとして使っているようにみえる。しかし、rollup のドキュメントをみても直接的に manifest.js の説明はなく、rollup の拡張の仕組みで manifest.js を作っているというよりは、sveltekit の要件によるもののようにもみえる。ここの背景はまだよくわからない。&lt;/p>
&lt;p>私はフロントエンドのことが全然わからないのでライブラリのソースコードを読みながら、ドキュメントとあわせて調べて、1つずつ理解を深めていくというアプローチで進めている。こういった調査のやり方もメンバーへ伝えていければと考えている。&lt;/p>
&lt;h2 id="小規模企業共済オンライン手続きポータル">小規模企業共済オンライン手続きポータル&lt;/h2>
&lt;p>&lt;a href="/diary/diary/posts/2022/0206/#2021年度の個人の確定申告">2021年度から小規模企業共済&lt;/a> に加入している。今年から掛け金を7万円/月に変更した。年間で84万円の所得控除となる。ちょうど2023年9月1日からポータルサイトが作成されたらしい。いずれマイナポータルと紐付くのかもしれない。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.smrj.go.jp/org/info/press/2023/ool3bn000000kxx5-att/20230901_press01.pdf">「オンライン手続きポータル」を公開しました&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>利用登録しようと思って、メールアドレスを登録しようとしたら会社のメールアドレスはなぜかバリデーションエラーになって gmail のアドレスなら登録できた。その後も氏名の半角カナ入力を強制されたりしながら、マイナンバーカードを読み取って認証チェックして利用登録の申請はできた。しかし、自動で本登録されるわけではなく、おそらく申請内容が先方に届いてなんらかの運用があって本登録されるみたい。オンラインポータルのホームでも半角カナを使っていたり、&lt;code>&amp;lt;title&amp;gt;&lt;/code> タグには「マイナ手続きポータル」とあったり、申請しただけでいくつも不備がわかるようなひどいサイトになっている。2023年にまともな開発者が作ったサイトとは思えない。デジタル庁に作り直してもらった方がよいと思う。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://portal.e-shishobako.ne.jp/dp_apl/pw-usr/#/portal/landing?riyoCd=RGO0226000">小規模企業共済ｵﾝﾗｲﾝ手続きﾎﾟｰﾀﾙ&lt;/a>&lt;/li>
&lt;/ul></content></item><item><title>selinux はなるべく有効にして使うもの</title><link>/diary/posts/2023/1003/</link><pubDate>Tue, 03 Oct 2023 16:28:42 +0900</pubDate><guid>/diary/posts/2023/1003/</guid><description>22時ぐらいから寝始めて何度か起きて6時に起きた。早く寝たから早く起きた。
selinux の微妙な振る舞い 今日は火曜日なのでチームの定例会議をやって、ドキュメントを書いて、その後はインフラの細かい作業をわちゃわちゃやって、ドキュメントを書いてとわちゃわちゃやってた。
先週、最新の almalinux 8 をインストールして、その後、lvm の論理ボリュームの結合 とか、rootless コンテナ の設定とか、テスト環境を構築していた。gitlab ci/cd から ssh で公開鍵認証を使ってデプロイしている。作り直したこのテスト環境に対してその公開鍵認証がうまく動かない現象に遭遇した。よくある設定や権限のトラブルではなく、デバッグ用の sshd を起動すると公開鍵認証できた。なにかしら systemd 経由で起動する sshd の設定ミスなんじゃないかと、2-3時間デバッグしてもわからなくて社内の有識者に尋ねてみた。
$ sudo /usr/sbin/sshd -d -p 2222 selinux を無効にしてみたら？というアドバイスをいただいて、試しに enforced から disabled にしたら動いたので selinux のなにかしらの設定を変えてしまったのかな？とそのときは思っていた。しかし、別の開発者からデフォルト設定で enforced でも動くはずという情報をもらって、もう一度 disabled から enforced に戻して再起動したら普通に動いて、その前の公開鍵認証の失敗を再現できなくなった。私にはこの先のデバッグはまったくわからない。お手伝い先のシニアエンジニアの方にみてもらって次のようなことを教えてもらった。
SElinuxが怪しいなと思ったら、/var/log/audit/audit.log とかausearch -m avcコマンドを確認。
authorized_keysのアクセスが拒否されているので確かにSELinuxの問題があったことがわかります。
type=AVC msg=audit(1696315292.258:1446): avc: denied { read } for pid=446534 comm=&amp;ldquo;sshd&amp;rdquo; name=&amp;ldquo;authorized_keys&amp;rdquo; dev=&amp;ldquo;dm-0&amp;rdquo; ino=201836096 scontext=system_u:system_r:sshd_t:s0-s0:c0.c1023 tcontext=unconfined_u:object_r:default_t:s0 tclass=file permissive=0
現在、authorized_keysのコンテキストは期待通りunconfined_u:object_r:ssh_home_t:s0となっているけど、問題が起きていたときは、unconfined_u:object_r:default_t:s0 だったことがわかります。
詳しい経緯はわからないけど、.ssh/authorized_keysを作成した時点でopenssh用のselinuxポリシーが適用されていなかったと考えられます。
その後なにかのイベント(再起動?)でrestorecon 相当が行われて、コンテキストがssh_home_tに変更され問題は解消した。
なんだかよくわかないけど、OSのマイナーバージョンアップで微妙にセキュリティコンテキストが変更されてrestoreconすると解決する、ってのは時々起きてますね。</description><content>&lt;p>22時ぐらいから寝始めて何度か起きて6時に起きた。早く寝たから早く起きた。&lt;/p>
&lt;h2 id="selinux-の微妙な振る舞い">selinux の微妙な振る舞い&lt;/h2>
&lt;p>今日は火曜日なのでチームの定例会議をやって、ドキュメントを書いて、その後はインフラの細かい作業をわちゃわちゃやって、ドキュメントを書いてとわちゃわちゃやってた。&lt;/p>
&lt;p>先週、最新の almalinux 8 をインストールして、その後、&lt;a href="/diary/diary/posts/2023/0929/#lvm-の論理ボリュームの結合">lvm の論理ボリュームの結合&lt;/a> とか、&lt;a href="/diary/diary/posts/2023/1002/">rootless コンテナ&lt;/a> の設定とか、テスト環境を構築していた。gitlab ci/cd から ssh で公開鍵認証を使ってデプロイしている。作り直したこのテスト環境に対してその公開鍵認証がうまく動かない現象に遭遇した。よくある設定や権限のトラブルではなく、デバッグ用の sshd を起動すると公開鍵認証できた。なにかしら systemd 経由で起動する sshd の設定ミスなんじゃないかと、2-3時間デバッグしてもわからなくて社内の有識者に尋ねてみた。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ sudo /usr/sbin/sshd -d -p &lt;span style="color:#ae81ff">2222&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>selinux を無効にしてみたら？というアドバイスをいただいて、試しに enforced から disabled にしたら動いたので selinux のなにかしらの設定を変えてしまったのかな？とそのときは思っていた。しかし、別の開発者からデフォルト設定で enforced でも動くはずという情報をもらって、もう一度 disabled から enforced に戻して再起動したら普通に動いて、その前の公開鍵認証の失敗を再現できなくなった。私にはこの先のデバッグはまったくわからない。お手伝い先のシニアエンジニアの方にみてもらって次のようなことを教えてもらった。&lt;/p>
&lt;blockquote>
&lt;p>SElinuxが怪しいなと思ったら、/var/log/audit/audit.log とか&lt;code>ausearch -m avc&lt;/code>コマンドを確認。&lt;br />
authorized_keysのアクセスが拒否されているので確かにSELinuxの問題があったことがわかります。&lt;br />
type=AVC msg=audit(1696315292.258:1446): avc: denied { read } for pid=446534 comm=&amp;ldquo;sshd&amp;rdquo; name=&amp;ldquo;authorized_keys&amp;rdquo; dev=&amp;ldquo;dm-0&amp;rdquo; ino=201836096 scontext=system_u:system_r:sshd_t:s0-s0:c0.c1023 tcontext=unconfined_u:object_r:default_t:s0 tclass=file permissive=0&lt;br />
現在、authorized_keysのコンテキストは期待通りunconfined_u:object_r:ssh_home_t:s0となっているけど、問題が起きていたときは、unconfined_u:object_r:default_t:s0 だったことがわかります。&lt;br />
詳しい経緯はわからないけど、.ssh/authorized_keysを作成した時点でopenssh用のselinuxポリシーが適用されていなかったと考えられます。&lt;br />
その後なにかのイベント(再起動?)でrestorecon 相当が行われて、コンテキストがssh_home_tに変更され問題は解消した。&lt;br />
なんだかよくわかないけど、OSのマイナーバージョンアップで微妙にセキュリティコンテキストが変更されてrestoreconすると解決する、ってのは時々起きてますね。&lt;br />
たぶんopensshインストール前にrsyncしたのでコンテキストがdefault_tになってたんじゃないかと。なかなかの罠ですね。&lt;br />&lt;/p>
&lt;/blockquote>
&lt;p>おそらく lvm の論理ボリュームのバックアップ／リストアに &lt;code>rsync -a&lt;/code> を使った (本当は &lt;code>cp -a&lt;/code>の方がよい) ことによる問題ではないかということ。私が報告した状況と selinux のログからすぐ助言できるのが素晴らしいと思う。まだまだ私のインフラエンジニアとしての未熟さを実感した瞬間でもあった。一昔前は selinux は disabled にするものという常識だったが、最近は初期設定で動くようになっているのでなるべく selinux は有効にして運用するものという意識に変わってきているらしい。&lt;/p></content></item><item><title>openldap サーバーのデバッグ</title><link>/diary/posts/2023/0906/</link><pubDate>Wed, 06 Sep 2023 08:18:13 +0900</pubDate><guid>/diary/posts/2023/0906/</guid><description>1時に寝て3時に起きて5時に起きて6時半に起きた。あとひと踏ん張りなのでこのまま突っ切る。
openldap 2.5 の ldappasswd の振る舞い openldap サーバーでパスワードを変更時の平文パスワードを連携するために カスタム overlay モジュール を使っている。前回の改修をしたときは openldap 2.4 向けのみの振る舞いを検証していた。今回は開発フェーズでは openldap 2.5 向けにもモジュールをビルドしてパッケージングしていた。その qa テストをしていて ldappasswd だけ、意図したパスワード連携が行われないという。
開発時に私が振る舞いを検証したつもりが ldapadd, ldapmodify は確認済みだったが、ldappasswd の確認をしていなかった。これは完全に私のミスで2つのフックポイントに対してカスタム overlay モジュールが動くのだから ldappasswd も大丈夫だろうと見通していた。しかし、そうではなかった。それぞれにフックポイントのコールバック設定があって、フックポイントもロジックが違うのだから当然ではあるのだけど、ちゃんと動作検証をしないといけないという、初歩的なミスをした。こんなこともあるんやと反省した。
gdb でデバッグしていて原因は 2.5.3 に含まれる次の修正だとわかった。私が検証していた openldap サーバーのバージョンは 2.5.14 だった。
Issue 8698 - ppolicy: responses from pwdCheckModule discarded when using an extended password modify ITS#8698 Propagate policy checker message through even if using PW Extop 簡潔に言えば、なんらかの不具合対応でもともと設定してあるコールバックを別のものに上書きしていた。カスタム overlay モジュールが設定したコールバックが別のものに上書きされてしまって意図した振る舞いをしないという現象が起きていた。これは明らかに openldap のリグレッションなので 2.5.15 で修正されてた。</description><content>&lt;p>1時に寝て3時に起きて5時に起きて6時半に起きた。あとひと踏ん張りなのでこのまま突っ切る。&lt;/p>
&lt;h2 id="openldap-25-の-ldappasswd-の振る舞い">openldap 2.5 の ldappasswd の振る舞い&lt;/h2>
&lt;p>openldap サーバーでパスワードを変更時の平文パスワードを連携するために &lt;a href="/diary/diary/posts/2023/0525/#カスタム-overlay-モジュールの改修">カスタム overlay モジュール&lt;/a> を使っている。前回の改修をしたときは openldap 2.4 向けのみの振る舞いを検証していた。今回は開発フェーズでは openldap 2.5 向けにもモジュールをビルドしてパッケージングしていた。その qa テストをしていて ldappasswd だけ、意図したパスワード連携が行われないという。&lt;/p>
&lt;p>開発時に私が振る舞いを検証したつもりが ldapadd, ldapmodify は確認済みだったが、ldappasswd の確認をしていなかった。これは完全に私のミスで2つのフックポイントに対してカスタム overlay モジュールが動くのだから ldappasswd も大丈夫だろうと見通していた。しかし、そうではなかった。それぞれにフックポイントのコールバック設定があって、フックポイントもロジックが違うのだから当然ではあるのだけど、ちゃんと動作検証をしないといけないという、初歩的なミスをした。こんなこともあるんやと反省した。&lt;/p>
&lt;p>gdb でデバッグしていて原因は 2.5.3 に含まれる次の修正だとわかった。私が検証していた openldap サーバーのバージョンは 2.5.14 だった。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://bugs.openldap.org/show_bug.cgi?id=8698">Issue 8698 - ppolicy: responses from pwdCheckModule discarded when using an extended password modify&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://git.openldap.org/openldap/openldap/-/merge_requests/304/diffs">ITS#8698 Propagate policy checker message through even if using PW Extop&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>簡潔に言えば、なんらかの不具合対応でもともと設定してあるコールバックを別のものに上書きしていた。カスタム overlay モジュールが設定したコールバックが別のものに上書きされてしまって意図した振る舞いをしないという現象が起きていた。これは明らかに openldap のリグレッションなので 2.5.15 で修正されてた。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://bugs.openldap.org/show_bug.cgi?id=9990">Issue 9990 - Part of the ITS#8698 fix breaks exop overlays that set a callback&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>たまたまピンポイントにバグを踏んだ形にはなったが、qa テストという別の人がテストをする仕組みでこのバグを検出できたことがうちの開発の品質基準を担保していることの表れでもある。&lt;/p>
&lt;blockquote>
&lt;p>生きるということは嬉しいこと半分、辛いこと半分なのですよ。 采王&lt;/p>
&lt;/blockquote></content></item><item><title>1行のミスによる1行の修正</title><link>/diary/posts/2023/0718/</link><pubDate>Tue, 18 Jul 2023 08:18:51 +0900</pubDate><guid>/diary/posts/2023/0718/</guid><description>0時に寝て何度か起きて6時半に起きた。朝から外はめっちゃ暑い。冷房をつけっぱなしのオフィスも朝からやっぱり暑い。根本的な空調の問題。
agent アプリケーションのメモリリーク正体 先週のメモリリーク調査 の続き。本当は週末にやればよかったんだけど、遊んでたりさぼってたりして放置してた。先週時点でリークしているのは go-zeromq/zmq4 側だというのはわかっていたが、何が原因でリークしているのかは分からなかった。一通りソースも読んでみたけど、いまひとつよく分からない。仕方ないから動的デバッグでソースコードに手を入れながら調査していて、すぐにみつけた。socket 構造体が保持しているコネクションの map がどんどん肥大化していく。なにも使っていない map にコネクションの値を保持して解放する処理がないことに気付いた。
sck.ids[uuid] = c 修正するかと思ってリポジトリの最新ブランチをみてもそのコードが見当たらない。すると次の pr で4月に修正されていた。まだリリースされていないからうちらのアプリケーションで使っているリビジョンにはその修正が含まれていなかった。
Deal with empty Identity for ROUTER socket #140 Additionally, remove sck.ids, which is unused and leaks *Conn.
メモリリークの調査を始めたときに github issues/pr を leak で検索して一通りチェックしているので、先週もこの pr をみかけているはずだが見逃してしまった。タイトルが全然違うし、ほんの1行の typo に近いミスなので修正内容をみて気付かなかったのだと思う。自分の観察力の無さに気付いた。leak で検索ヒットしているのだから、それが自分たちのアプリケーションで使っているコードに入っているのかどうか、その内容をもっと注意して調べるべきだった。そうすればこの調査時間を数時間は短縮できた。これは私のミスだと認めて Postmortem のラベルを付けた。次回の定例会議でふりかえりに使う。</description><content>&lt;p>0時に寝て何度か起きて6時半に起きた。朝から外はめっちゃ暑い。冷房をつけっぱなしのオフィスも朝からやっぱり暑い。根本的な空調の問題。&lt;/p>
&lt;h2 id="agent-アプリケーションのメモリリーク正体">agent アプリケーションのメモリリーク正体&lt;/h2>
&lt;p>&lt;a href="/diary/diary/posts/2023/0714/#agent-アプリケーションのメモリリーク調査">先週のメモリリーク調査&lt;/a> の続き。本当は週末にやればよかったんだけど、遊んでたりさぼってたりして放置してた。先週時点でリークしているのは &lt;a href="https://github.com/go-zeromq/zmq4">go-zeromq/zmq4&lt;/a> 側だというのはわかっていたが、何が原因でリークしているのかは分からなかった。一通りソースも読んでみたけど、いまひとつよく分からない。仕方ないから動的デバッグでソースコードに手を入れながら調査していて、すぐにみつけた。socket 構造体が保持しているコネクションの map がどんどん肥大化していく。なにも使っていない map にコネクションの値を保持して解放する処理がないことに気付いた。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">sck&lt;/span>.&lt;span style="color:#a6e22e">ids&lt;/span>[&lt;span style="color:#a6e22e">uuid&lt;/span>] = &lt;span style="color:#a6e22e">c&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>修正するかと思ってリポジトリの最新ブランチをみてもそのコードが見当たらない。すると次の pr で4月に修正されていた。まだリリースされていないからうちらのアプリケーションで使っているリビジョンにはその修正が含まれていなかった。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/go-zeromq/zmq4/pull/140">Deal with empty Identity for ROUTER socket #140&lt;/a>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>Additionally, remove sck.ids, which is unused and leaks *Conn.&lt;/p>
&lt;/blockquote>
&lt;p>メモリリークの調査を始めたときに github issues/pr を leak で検索して一通りチェックしているので、先週もこの pr をみかけているはずだが見逃してしまった。タイトルが全然違うし、ほんの1行の typo に近いミスなので修正内容をみて気付かなかったのだと思う。自分の観察力の無さに気付いた。leak で検索ヒットしているのだから、それが自分たちのアプリケーションで使っているコードに入っているのかどうか、その内容をもっと注意して調べるべきだった。そうすればこの調査時間を数時間は短縮できた。これは私のミスだと認めて &lt;code>Postmortem&lt;/code> のラベルを付けた。次回の定例会議でふりかえりに使う。&lt;/p></content></item><item><title>c 言語の開発は chatgpt と共に</title><link>/diary/posts/2023/0525/</link><pubDate>Thu, 25 May 2023 09:51:27 +0900</pubDate><guid>/diary/posts/2023/0525/</guid><description>1時に寝てやや吐き気で起きて休憩して3時ぐらいに寝たか寝てないかわからないうちに8時に起きた。ジンをたくさん飲んで帰ってきたのでうまく眠れなかった。
カスタム overlay モジュールの改修 OpenLDAP Overlays という機能がある。以前 ppolicy_hash_cleartext と カスタム overlay モジュール を組み合わせると ppolicy が平文パスワードをハッシュ化してしまって、自分たちのカスタム overlay モジュールから平文パスワードを取得できないことをデバッグで検証した。ppolicy_hash_cleartext の機能が必要なのかどうかが私はよくわかっていないけど、協調して自分たちのカスタム overlay モジュールが動くならそれに越したことはない。
gdb でデバッグして振る舞いと対応方法が分かったところで issue を作成していた。メンバーが暇だったらやってくれるかな？と思っていたら誰も手をつけないみたいなので私がやろうと決めた。最早、私は c 言語をなんも分からんのやけど、chatgpt に質問しながら教えてもらえる。例えば、c 言語についてもこんな感じにヒアリングしながら実装する。
Q. c 言語で関数の最初に変数を宣言するのと、実際に変数を割り当てるところで宣言するのでなにか振る舞いが違ったりしますか？どちらの方がよいのでしょうか？
C言語は伝統的に変数のスコープとライフタイムを管理するために、ブロック（通常は関数または制御構造内）の先頭で変数を宣言するスタイルを採用してきました。しかし、C99標準以降では、変数はその使用が初めて必要となる場所で宣言できるようになりました。 これら2つのスタイルの違いは、主にスコープ、可読性、そしてある程度はパフォーマンスに関連しています。
スコープとライフタイム
関数の先頭で変数を宣言すると、その変数は関数全体で使用できます。これは必要に応じて変数を再利用できるという利点がありますが、一方でスコープが広くなりすぎて変数の使用を追跡しにくくなるという欠点もあります。 一方、変数を使用が必要となる場所で宣言すると、その変数のスコープとライフタイムはその場所からブロックの終わりまでに制限されます。これは、変数の使用をより明確にし、未使用の変数を避けるという利点があります。
可読性
変数を使用が必要となる場所で宣言すると、その変数の目的と使用方法がより明確になるため、コードの可読性が向上することが多いです。一方で、関数の先頭で変数を一括して宣言すると、変数の目的が明確でない場合や、それらがどのように使用されるのかを追跡するのが難しくなることがあります。
パフォーマンス
パフォーマンスについては、現代のコンパイラは非常に高度に最適化されているため、変数の宣言場所がパフォーマンスに直接的な影響を及ぼすことはほとんどありません。
結論
どちらのスタイルを選ぶかは、主にプログラミングスタイルやチームのコーディング規約、または特定のタスクに対する特定の要件に依存します。しかし、変数を使用が初めて必要となる場所で宣言するスタイルは、コードの可読性を向上させ、変数のスコープとライフタイムを制限するという利点から、一般的には推奨されています。これにより、コードの可読性が向上し、変数の使用範囲が明確になるため、コードの理解と保守が容易になります。
そっか。C99 で変数宣言の制約が撤廃されたんだということを学んだ。そんな感じで openldap についても chatgpt にヒアリングしながら開発したら意外とすんなり実装できてローカルでは動いた。レビューまでできた。</description><content>&lt;p>1時に寝てやや吐き気で起きて休憩して3時ぐらいに寝たか寝てないかわからないうちに8時に起きた。ジンをたくさん飲んで帰ってきたのでうまく眠れなかった。&lt;/p>
&lt;h2 id="カスタム-overlay-モジュールの改修">カスタム overlay モジュールの改修&lt;/h2>
&lt;p>&lt;a href="https://www.openldap.org/doc/admin24/overlays.html">OpenLDAP Overlays&lt;/a> という機能がある。以前 ppolicy_hash_cleartext と &lt;a href="/diary/diary/posts/2023/0417/#openldap-のカスタム-overlay-モジュールのデバッグ">カスタム overlay モジュール&lt;/a> を組み合わせると ppolicy が平文パスワードをハッシュ化してしまって、自分たちのカスタム overlay モジュールから平文パスワードを取得できないことをデバッグで検証した。ppolicy_hash_cleartext の機能が必要なのかどうかが私はよくわかっていないけど、協調して自分たちのカスタム overlay モジュールが動くならそれに越したことはない。&lt;/p>
&lt;p>gdb でデバッグして振る舞いと対応方法が分かったところで issue を作成していた。メンバーが暇だったらやってくれるかな？と思っていたら誰も手をつけないみたいなので私がやろうと決めた。最早、私は c 言語をなんも分からんのやけど、chatgpt に質問しながら教えてもらえる。例えば、c 言語についてもこんな感じにヒアリングしながら実装する。&lt;/p>
&lt;blockquote>
&lt;p>Q. c 言語で関数の最初に変数を宣言するのと、実際に変数を割り当てるところで宣言するのでなにか振る舞いが違ったりしますか？どちらの方がよいのでしょうか？&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>C言語は伝統的に変数のスコープとライフタイムを管理するために、ブロック（通常は関数または制御構造内）の先頭で変数を宣言するスタイルを採用してきました。しかし、C99標準以降では、変数はその使用が初めて必要となる場所で宣言できるようになりました。
これら2つのスタイルの違いは、主にスコープ、可読性、そしてある程度はパフォーマンスに関連しています。&lt;/p>
&lt;p>&lt;strong>スコープとライフタイム&lt;/strong>&lt;/p>
&lt;p>関数の先頭で変数を宣言すると、その変数は関数全体で使用できます。これは必要に応じて変数を再利用できるという利点がありますが、一方でスコープが広くなりすぎて変数の使用を追跡しにくくなるという欠点もあります。
一方、変数を使用が必要となる場所で宣言すると、その変数のスコープとライフタイムはその場所からブロックの終わりまでに制限されます。これは、変数の使用をより明確にし、未使用の変数を避けるという利点があります。&lt;/p>
&lt;p>&lt;strong>可読性&lt;/strong>&lt;/p>
&lt;p>変数を使用が必要となる場所で宣言すると、その変数の目的と使用方法がより明確になるため、コードの可読性が向上することが多いです。一方で、関数の先頭で変数を一括して宣言すると、変数の目的が明確でない場合や、それらがどのように使用されるのかを追跡するのが難しくなることがあります。&lt;/p>
&lt;p>&lt;strong>パフォーマンス&lt;/strong>&lt;/p>
&lt;p>パフォーマンスについては、現代のコンパイラは非常に高度に最適化されているため、変数の宣言場所がパフォーマンスに直接的な影響を及ぼすことはほとんどありません。&lt;/p>
&lt;p>&lt;strong>結論&lt;/strong>&lt;/p>
&lt;p>どちらのスタイルを選ぶかは、主にプログラミングスタイルやチームのコーディング規約、または特定のタスクに対する特定の要件に依存します。しかし、変数を使用が初めて必要となる場所で宣言するスタイルは、コードの可読性を向上させ、変数のスコープとライフタイムを制限するという利点から、一般的には推奨されています。これにより、コードの可読性が向上し、変数の使用範囲が明確になるため、コードの理解と保守が容易になります。&lt;/p>
&lt;/blockquote>
&lt;p>そっか。C99 で変数宣言の制約が撤廃されたんだということを学んだ。そんな感じで openldap についても chatgpt にヒアリングしながら開発したら意外とすんなり実装できてローカルでは動いた。レビューまでできた。&lt;/p></content></item><item><title>カスタム overlay モジュールを完全にマスターした</title><link>/diary/posts/2023/0417/</link><pubDate>Mon, 17 Apr 2023 08:53:17 +0900</pubDate><guid>/diary/posts/2023/0417/</guid><description>0時に寝て何度か起きて7時に起きた。変な夢をみた気がするが、どんな夢だったかは思い出せない。
openldap のカスタム overlay モジュールのデバッグ 先週末から openldap のカスタム overlay モジュール の開発やデバッグをしている。openldap のソースコードや gdb のデバッグのやり方にも慣れてきて私の中でも理解度が増してきた。
openldap サーバーのデバッグログは次のコードが設定されている。
#define LDAP_DEBUG_TRACE 0x0001 このコードを slapd.conf の loglevel に設定するとデバッグログを出力できるようになる。
loglevel stats 0x0001 ... このときに ppolicy の overlay モジュールがどのタイミングで呼ばれるかをデバッグログを確認しながら検証した。
overlay ppolicy ppolicy_hash_cleartext on 結論から言うと次の2点になる。
overlay は slapd.conf の後ろに書いた方のカスタムモジュールが先に実行される ppolicy_hash_cleartext は ppolicy_add のタイミングで平文パスワードをハッシュ化している gdb でデバッグすると op-&amp;gt;o_request-&amp;gt;oq_add-&amp;gt;rs_modlist も op-&amp;gt;o_request-&amp;gt;oq_add-&amp;gt;rs_e-&amp;gt;e_attrs も同じアドレスを指す overlay の処理は db に書き込む前と後の2つのタイミングがある slap_passwd_hash( &amp;amp;(pa-&amp;gt;a_vals[0]), &amp;amp;hpw, &amp;amp;txt ); ... pa-&amp;gt;a_vals[0].bv_val = hpw.bv_val; pa-&amp;gt;a_vals[0].bv_len = hpw.bv_len; カスタム overlay モジュールを使って openldap からパスワードを取得するには次の順番で処理が行われることを理解しておく必要がある。</description><content>&lt;p>0時に寝て何度か起きて7時に起きた。変な夢をみた気がするが、どんな夢だったかは思い出せない。&lt;/p>
&lt;h2 id="openldap-のカスタム-overlay-モジュールのデバッグ">openldap のカスタム overlay モジュールのデバッグ&lt;/h2>
&lt;p>先週末から &lt;a href="/diary/diary/posts/2023/0414/#chatgpt-と一緒にデバッグ">openldap のカスタム overlay モジュール&lt;/a> の開発やデバッグをしている。openldap のソースコードや gdb のデバッグのやり方にも慣れてきて私の中でも理解度が増してきた。&lt;/p>
&lt;p>openldap サーバーのデバッグログは次のコードが設定されている。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define LDAP_DEBUG_TRACE 0x0001
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このコードを slapd.conf の loglevel に設定するとデバッグログを出力できるようになる。&lt;/p>
&lt;pre tabindex="0">&lt;code>loglevel stats 0x0001 ...
&lt;/code>&lt;/pre>&lt;p>このときに ppolicy の overlay モジュールがどのタイミングで呼ばれるかをデバッグログを確認しながら検証した。&lt;/p>
&lt;pre tabindex="0">&lt;code>overlay ppolicy
ppolicy_hash_cleartext on
&lt;/code>&lt;/pre>&lt;p>結論から言うと次の2点になる。&lt;/p>
&lt;ul>
&lt;li>overlay は slapd.conf の後ろに書いた方のカスタムモジュールが先に実行される&lt;/li>
&lt;li>ppolicy_hash_cleartext は ppolicy_add のタイミングで平文パスワードをハッシュ化している
&lt;ul>
&lt;li>gdb でデバッグすると op-&amp;gt;o_request-&amp;gt;oq_add-&amp;gt;rs_modlist も op-&amp;gt;o_request-&amp;gt;oq_add-&amp;gt;rs_e-&amp;gt;e_attrs も同じアドレスを指す&lt;/li>
&lt;li>overlay の処理は db に書き込む前と後の2つのタイミングがある&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">slap_passwd_hash&lt;/span>( &lt;span style="color:#f92672">&amp;amp;&lt;/span>(pa&lt;span style="color:#f92672">-&amp;gt;&lt;/span>a_vals[&lt;span style="color:#ae81ff">0&lt;/span>]), &lt;span style="color:#f92672">&amp;amp;&lt;/span>hpw, &lt;span style="color:#f92672">&amp;amp;&lt;/span>txt );
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pa&lt;span style="color:#f92672">-&amp;gt;&lt;/span>a_vals[&lt;span style="color:#ae81ff">0&lt;/span>].bv_val &lt;span style="color:#f92672">=&lt;/span> hpw.bv_val;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pa&lt;span style="color:#f92672">-&amp;gt;&lt;/span>a_vals[&lt;span style="color:#ae81ff">0&lt;/span>].bv_len &lt;span style="color:#f92672">=&lt;/span> hpw.bv_len;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>カスタム overlay モジュールを使って openldap からパスワードを取得するには次の順番で処理が行われることを理解しておく必要がある。&lt;/p>
&lt;ol>
&lt;li>mycustom_add &amp;lt;= このタイミングで平文パスワードを取得しないといけない&lt;/li>
&lt;li>ppolicy_add &amp;lt;= このタイミングで平文のパスワードをハッシュ化する&lt;/li>
&lt;li>mycustom_add_response &amp;lt;= このタイミングではすでにパスワードがハッシュ化されている&lt;/li>
&lt;/ol>
&lt;p>openldap のことを何も知らない素人が chatgpt と一緒にデバッグしてこのことを2日で理解できた。開発のやり方が変わっていく予兆を感じた。&lt;/p></content></item><item><title>休出デバッグ</title><link>/diary/posts/2023/0415/</link><pubDate>Sat, 15 Apr 2023 16:26:08 +0900</pubDate><guid>/diary/posts/2023/0415/</guid><description>昨日は久しぶりに飲みに行っきて1時に寝て8時に起きた。
ストレッチ 外がだいぶ暖かくなってきて散歩に行く機会も増えてきた気がする。今日の開脚幅は開始前157cmで、ストレッチ後159cmだった。先週と違って今週は忙しくて座っている時間が大幅に増えた。そして、その分の右腰の張りは強かった。腰の張り具合はその週の忙しさや労働時間で推測できるぐらいにはわかってきた。それ以外はだいたい可もなく不可もなくな感じだったと思う。
淡路牛の受け取り 姉からお肉が届くという連絡があったので日時を調整して受け取った。島サラダフェア2022 という懸賞に応募していたのが当たったらしい。5000円相当の淡路牛らしい。お正月に食べるようなお肉だと言えば伝わるかな。A賞の5名のうちの1人がここにいるので総応募数は推して知るべし。姉が言うには全然応募ないらしい。こういうの調べて真面目に応募してメルカリで売るみたいなことやったらそれなりに儲かるのかもしれない。運営はマーケティングのやり方を変えた方がいいんじゃないかとか心配になって話していた。
openldap の overlay のデバッグ 午後から昨日の続き。chatgpt と一緒に openldap サーバーのカスタム overlay モジュールのデバッグをしていた。昨日の時点では2つの問題があることを確認できていた。今日は個々の問題の詳細をデバッグしながらワークアラウンドとして動かすためのコードを書いた。1つはビルドの問題じゃないかと思える不可思議な現象が起きていて、もう1つは openldap の ppolicy の仕様とカスタム overlay モジュールの仕様のどちらが正しいのかを設計者に確認する必要がある。15年ぶりぐらいに c 言語のコードを書いている。かなり怪しいけど、gdb をインタラクティブな repl のようにして振る舞いを確認しながら書いている。カスタム overlay モジュールでエラーが発生すると openldap はその処理をスキップするようにみえて、なんのログも出ない。細かくログ出力してどこまで動いたのかを確認しながら開発するとよさそうな雰囲気がわかった。</description><content>&lt;p>昨日は久しぶりに飲みに行っきて1時に寝て8時に起きた。&lt;/p>
&lt;h2 id="ストレッチ">ストレッチ&lt;/h2>
&lt;p>外がだいぶ暖かくなってきて散歩に行く機会も増えてきた気がする。今日の開脚幅は開始前157cmで、ストレッチ後159cmだった。先週と違って今週は忙しくて座っている時間が大幅に増えた。そして、その分の右腰の張りは強かった。腰の張り具合はその週の忙しさや労働時間で推測できるぐらいにはわかってきた。それ以外はだいたい可もなく不可もなくな感じだったと思う。&lt;/p>
&lt;h2 id="淡路牛の受け取り">淡路牛の受け取り&lt;/h2>
&lt;p>姉からお肉が届くという連絡があったので日時を調整して受け取った。&lt;a href="https://www.awajikoku.com/shimasalad/2022/12/04/20221204094613/">島サラダフェア2022&lt;/a> という懸賞に応募していたのが当たったらしい。5000円相当の淡路牛らしい。お正月に食べるようなお肉だと言えば伝わるかな。A賞の5名のうちの1人がここにいるので総応募数は推して知るべし。姉が言うには全然応募ないらしい。こういうの調べて真面目に応募してメルカリで売るみたいなことやったらそれなりに儲かるのかもしれない。運営はマーケティングのやり方を変えた方がいいんじゃないかとか心配になって話していた。&lt;/p>
&lt;figure>&lt;img src="/diary/diary/img/2023/0415_awaji-beef.jpg"/>
&lt;/figure>
&lt;h2 id="openldap-の-overlay-のデバッグ">openldap の overlay のデバッグ&lt;/h2>
&lt;p>午後から昨日の続き。&lt;a href="https://openai.com/blog/chatgpt">chatgpt&lt;/a> と一緒に openldap サーバーのカスタム overlay モジュールのデバッグをしていた。昨日の時点では2つの問題があることを確認できていた。今日は個々の問題の詳細をデバッグしながらワークアラウンドとして動かすためのコードを書いた。1つはビルドの問題じゃないかと思える不可思議な現象が起きていて、もう1つは openldap の ppolicy の仕様とカスタム overlay モジュールの仕様のどちらが正しいのかを設計者に確認する必要がある。15年ぶりぐらいに c 言語のコードを書いている。かなり怪しいけど、gdb をインタラクティブな repl のようにして振る舞いを確認しながら書いている。カスタム overlay モジュールでエラーが発生すると openldap はその処理をスキップするようにみえて、なんのログも出ない。細かくログ出力してどこまで動いたのかを確認しながら開発するとよさそうな雰囲気がわかった。&lt;/p></content></item><item><title>oss な開発は chatgpt が猛威を振るう予感</title><link>/diary/posts/2023/0414/</link><pubDate>Fri, 14 Apr 2023 07:52:38 +0900</pubDate><guid>/diary/posts/2023/0414/</guid><description>2時に寝て6時半に起きた。開発の追い込みが佳境に入ってきて集中力が増してきた。
chatgpt と一緒にデバッグ openldap サーバーの拡張の仕組みに Overlays がある。c 言語でカスタム overlay を実装することで openldap サーバーに任意のフック処理を実装できる。いまやっていることはパスワードの追加や更新をフックしてそのパスワードを id 連携するためのモジュールを開発している。というか、開発済みだと聞いていたモジュールが意図したように動かないのでデバッグしている。例えば ppolicy という overlay を使って次のように設定すると、平文で送ったパスワードをディレクトリサービスの db へ格納する前に平文からパスワードをハッシュ化してくれる。この変換はパスワード変更を overlay でフックして実装されている。
overlay ppolicy ppolicy_hash_cleartext on overlay は slapd.conf に設定した順番に実行されるようで、それぞれの overlay に依存関係がある場合は実際の処理にも影響がある。そんな openldap サーバーの拡張モジュールの開発を引き継ぐことになったが、私がまったく openldap サーバーのことをわかっていないので chatgpt を使って理解しながらデバッグしている。これがそれなりにうまくいっていて調査が捗った。但し、chatgpt が教えてくれたことなので完全に正しいかどうかの保証がない。振る舞いで検証できるものはともかく、そうじゃないものは最後に有識者に正しいかどうかを確認する必要がある。
例えば、次のような ldif エントリーをサンプルとして、パスワードは userPassword という属性で扱う。ここで userPassword だけコロンが2重 (::) になっていることがわかる。これは属性の値が base64 でエンコーディングされていることを意味している。こういった2重コロンのような短いキーワードを検索で調べるのは難しい。chatgpt ならピンポイントに答えてくれる。
dn: uid=jdoe,ou=users,dc=example,dc=com objectClass: top objectClass: person objectClass: organizationalPerson objectClass: inetOrgPerson uid: jdoe cn: John Doe givenName: John sn: Doe mail: jdoe@example.</description><content>&lt;p>2時に寝て6時半に起きた。開発の追い込みが佳境に入ってきて集中力が増してきた。&lt;/p>
&lt;h2 id="chatgpt-と一緒にデバッグ">chatgpt と一緒にデバッグ&lt;/h2>
&lt;p>openldap サーバーの拡張の仕組みに &lt;a href="https://www.openldap.org/doc/admin24/overlays.html">Overlays&lt;/a> がある。c 言語でカスタム overlay を実装することで openldap サーバーに任意のフック処理を実装できる。いまやっていることはパスワードの追加や更新をフックしてそのパスワードを id 連携するためのモジュールを開発している。というか、開発済みだと聞いていたモジュールが意図したように動かないのでデバッグしている。例えば &lt;code>ppolicy&lt;/code> という overlay を使って次のように設定すると、平文で送ったパスワードをディレクトリサービスの db へ格納する前に平文からパスワードをハッシュ化してくれる。この変換はパスワード変更を overlay でフックして実装されている。&lt;/p>
&lt;pre tabindex="0">&lt;code>overlay ppolicy
ppolicy_hash_cleartext on
&lt;/code>&lt;/pre>&lt;p>overlay は slapd.conf に設定した順番に実行されるようで、それぞれの overlay に依存関係がある場合は実際の処理にも影響がある。そんな openldap サーバーの拡張モジュールの開発を引き継ぐことになったが、私がまったく openldap サーバーのことをわかっていないので &lt;a href="https://openai.com/blog/chatgpt">chatgpt&lt;/a> を使って理解しながらデバッグしている。これがそれなりにうまくいっていて調査が捗った。但し、chatgpt が教えてくれたことなので完全に正しいかどうかの保証がない。振る舞いで検証できるものはともかく、そうじゃないものは最後に有識者に正しいかどうかを確認する必要がある。&lt;/p>
&lt;p>例えば、次のような ldif エントリーをサンプルとして、パスワードは &lt;code>userPassword&lt;/code> という属性で扱う。ここで &lt;code>userPassword&lt;/code> だけコロンが2重 (&lt;code>::&lt;/code>) になっていることがわかる。これは属性の値が base64 でエンコーディングされていることを意味している。こういった2重コロンのような短いキーワードを検索で調べるのは難しい。chatgpt ならピンポイントに答えてくれる。&lt;/p>
&lt;pre tabindex="0">&lt;code>dn: uid=jdoe,ou=users,dc=example,dc=com
objectClass: top
objectClass: person
objectClass: organizationalPerson
objectClass: inetOrgPerson
uid: jdoe
cn: John Doe
givenName: John
sn: Doe
mail: jdoe@example.com
userPassword:: e1NTSEF9bm9ZMU5kdzN3WUdSbFhpdDJUaTY5UW9SeXpXaklEeXc=
&lt;/code>&lt;/pre>&lt;p>openldap は oss だし、ドキュメントもインターネット上にあるので構造体の定義や c 言語のサンプルコードも書いてくれる。それらが完全に正しいか、私には判断できないが、openldap のソースコードで調査するところの当たりをつけるには十分な情報を返してくれる。カスタム overlay を開発するときの主要なエントリーポイントと ldap 操作のタグ名は次になる。&lt;/p>
&lt;ul>
&lt;li>bi_op_bind: バインド（認証）操作に対応するエントリーポイント、LDAP_REQ_BIND&lt;/li>
&lt;li>bi_op_search: 検索操作に対応するエントリーポイント、LDAP_REQ_SEARCH&lt;/li>
&lt;li>bi_op_compare: 比較操作に対応するエントリーポイント、LDAP_REQ_COMPARE&lt;/li>
&lt;li>bi_op_modify: 修正（属性の追加、削除、変更）操作に対応するエントリーポイント、LDAP_REQ_MODIFY&lt;/li>
&lt;li>bi_op_modrdn: エントリ名の変更 (MODIFY RDN) 操作に対応するエントリーポイント、LDAP_REQ_MODRDN&lt;/li>
&lt;li>bi_op_add: エントリの追加操作に対応するエントリーポイント、LDAP_REQ_ADD&lt;/li>
&lt;li>bi_op_delete: エントリの削除操作に対応するエントリーポイント、LDAP_REQ_DELETE&lt;/li>
&lt;li>bi_op_abandon: 中止操作に対応するエントリーポイント、LDAP_REQ_ABANDON&lt;/li>
&lt;li>bi_op_extended: 拡張操作に対応するエントリーポイント、LDAP_REQ_EXTENDED&lt;/li>
&lt;/ul>
&lt;p>例えば、LDAP_REQ_ADD は ldap.h で次のように定義されている。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define LDAP_REQ_ADD ((ber_tag_t) 0x68U) &lt;/span>&lt;span style="color:#75715e">/* application + constructed */&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これを gdb でデバッグしてタグを確認するときは次のように Operation 構造体内の o_tag をチェックすればよい。gdb で16進数表示するときは &lt;code>/x&lt;/code> を指定する。&lt;/p>
&lt;pre tabindex="0">&lt;code>(gdb) print /x op-&amp;gt;o_tag
$8 = 0x68
&lt;/code>&lt;/pre>&lt;p>ppolicy よりも前にカスタム overlay を設定すれば平文のパスワードにアクセスできそうにみえるのだけど、gdb でデバッグしているとハッシュ化済みのパスワードになっていた。&lt;/p>
&lt;p>あと稼働している openldap サーバーに gdb で attach してデバッグする方法も chatgpt に聞きながら行った。やりたい操作に対して gdb のコマンドを教えてもらってすぐに検証してフィードバックからさらに質問できるのでインタラクティブな repl のような環境と chatgpt は相性がよいように思えた。gdb のコマンドを覚えておく必要も、ググる必要もないことに気付いた。&lt;/p>
&lt;h2 id="近況報告">近況報告&lt;/h2>
&lt;p>元同僚と &lt;a href="/diary/diary/posts/2022/0311/#近況報告">約1年ぶりの近況報告&lt;/a> の雑談会をしてきた。これで3回目かな。毎年の恒例行事のようになってきた。兵庫県の住みたい街ランキングでいつも上位にある &lt;a href="https://www.nishi.or.jp/">西宮市&lt;/a> でカレーを食べて、バーで飲んできた。三ノ宮から西宮は快速で15分程度の距離。すぐ行ける場所なんだが、とくに行く機会がなかったので神戸に引っ越してきて5年以上経つのに電車で行ったのは今回が初めてになる。いつも通り近況を聞きながら、みんな私と同じぐらいの世代なので今後のキャリアの方向性などを話していた。&lt;/p>
&lt;p>私は起業して税金やその仕組みに関心をもつようになり、起業する前より少し詳しくなった。知人から節税相談を受けることもある。税金の基本的な考え方として、1つの大きな収入に対して節税することはできない。自由に使えるお金がほしかったら基本的に節税できない。税金をたくさん払って貯金するしかない。一方で個人と会社に資産を分割したり、共済や基金を活用することで手取りの収入は減るが、支払う税金は少なくなって中長期でみると資産が増える。例えば、共済や基金に積み立てたお金は原則としては退職所得で戻ってくるので、ずっと優遇された &lt;a href="https://www.nta.go.jp/taxes/shiraberu/taxanswer/shotoku/1420.htm">退職所得の所得税&lt;/a> により、最終的に支払う税金が少なくなるからである。これが税金を支払う基本的な考え方。自分の手元にお金を残した上で税金を払いたくないが、どうすればよいか？とよく聞かれるが、そんなことはできないというのが模範回答になる。元同僚も私もそうなのだが、もはや自分の生活にお金をあまり必要としていない。私が節税の仕組みを調べたり実践したりするのは、税金の仕組みを学ぶために過ぎない。ただ知識として学ぶよりも、実際に実践して運用してみる方が学びになる。&lt;/p>
&lt;p>以前の &lt;a href="/diary/diary/posts/2023/0408/#もくもく会">出張もくもく会&lt;/a> の後で懇親会のときにそのうち資本主義は新しい制度にとって変わられるのではないかという話題があった。それは行き過ぎた資本主義の弊害と、資本主義である限り40時間/週の労働時間から抜け出すには資本家になるしかなくて、人類はすでにこれだけ技術があるのだからもっと多くの人が今よりも働かずに食べていけるのではないかと多くの人が考えている。私の場合も、実質は自分のやりたいことしかやってなくて、自分のために働きながらも、老後のために一応はお金をもらっておくみたいな働き方になっている。この考え方は資本主義の次の制度へ移行するときに活きてくればいいなと思う。&lt;/p></content></item></channel></rss>