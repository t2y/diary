<!doctype html><html lang=en><head><title>debug :: forest nook</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=/diary/tags/debug/><link rel=stylesheet href=/diary/styles.css><link rel=stylesheet href=/diary/style.css><link rel="shortcut icon" href=/diary/favicon.ico><meta name=twitter:card content="summary"><meta name=twitter:site content="t2y"><meta name=twitter:creator content><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:title" content="debug"><meta property="og:description" content><meta property="og:url" content="/diary/tags/debug/"><meta property="og:site_name" content="forest nook"><meta property="og:image" content="/diary/favicon.ico"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><link href=/diary/tags/debug/index.xml rel=alternate type=application/rss+xml title="forest nook"></head><body class=green><div class="container full headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/diary><div class=logo>forest nook</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/diary/about>自己紹介</a></li><li><a href=/diary/dates>月別一覧</a></li><li><a href=/diary/tags>タグ一覧</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/diary/about>自己紹介</a></li><li><a href=/diary/dates>月別一覧</a></li><li><a href=/diary/tags>タグ一覧</a></li></ul></nav></header><div class=content><div class=posts><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2023/0718/>1行のミスによる1行の修正</a></h1><div class=post-meta><time class=post-date>2023-07-18 (Tue.) ::</time></div><span class=post-tags>#<a href=/diary/tags/operation/>operation</a>&nbsp;
#<a href=/diary/tags/debug/>debug</a>&nbsp;</span><div class=post-content><p>0時に寝て何度か起きて6時半に起きた。朝から外はめっちゃ暑い。冷房をつけっぱなしのオフィスも朝からやっぱり暑い。根本的な空調の問題。</p><h2 id=agent-アプリケーションのメモリリーク正体>agent アプリケーションのメモリリーク正体</h2><p><a href=/diary/posts/2023/0714/#agent-アプリケーションのメモリリーク調査>先週のメモリリーク調査</a> の続き。本当は週末にやればよかったんだけど、遊んでたりさぼってたりして放置してた。先週時点でリークしているのは <a href=https://github.com/go-zeromq/zmq4>go-zeromq/zmq4</a> 側だというのはわかっていたが、何が原因でリークしているのかは分からなかった。一通りソースも読んでみたけど、いまひとつよく分からない。仕方ないから動的デバッグでソースコードに手を入れながら調査していて、すぐにみつけた。socket 構造体が保持しているコネクションの map がどんどん肥大化していく。なにも使っていない map にコネクションの値を保持して解放する処理がないことに気付いた。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>sck</span>.<span style=color:#a6e22e>ids</span>[<span style=color:#a6e22e>uuid</span>] = <span style=color:#a6e22e>c</span>
</span></span></code></pre></div><p>修正するかと思ってリポジトリの最新ブランチをみてもそのコードが見当たらない。すると次の pr で4月に修正されていた。まだリリースされていないからうちらのアプリケーションで使っているリビジョンにはその修正が含まれていなかった。</p><ul><li><a href=https://github.com/go-zeromq/zmq4/pull/140>Deal with empty Identity for ROUTER socket #140</a></li></ul><blockquote><p>Additionally, remove sck.ids, which is unused and leaks *Conn.</p></blockquote><p>メモリリークの調査を始めたときに github issues/pr を leak で検索して一通りチェックしているので、先週もこの pr をみかけているはずだが見逃してしまった。タイトルが全然違うし、ほんの1行の typo に近いミスなので修正内容をみて気付かなかったのだと思う。自分の観察力の無さに気付いた。leak で検索ヒットしているのだから、それが自分たちのアプリケーションで使っているコードに入っているのかどうか、その内容をもっと注意して調べるべきだった。そうすればこの調査時間を数時間は短縮できた。これは私のミスだと認めて <code>Postmortem</code> のラベルを付けた。次回の定例会議でふりかえりに使う。</p></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2023/0525/>c 言語の開発は chatgpt と共に</a></h1><div class=post-meta><time class=post-date>2023-05-25 (Thu.) ::</time></div><span class=post-tags>#<a href=/diary/tags/ldap/>ldap</a>&nbsp;
#<a href=/diary/tags/debug/>debug</a>&nbsp;
#<a href=/diary/tags/gpt/>gpt</a>&nbsp;</span><div class=post-content><p>1時に寝てやや吐き気で起きて休憩して3時ぐらいに寝たか寝てないかわからないうちに8時に起きた。ジンをたくさん飲んで帰ってきたのでうまく眠れなかった。</p><h2 id=カスタム-overlay-モジュールの改修>カスタム overlay モジュールの改修</h2><p><a href=https://www.openldap.org/doc/admin24/overlays.html>OpenLDAP Overlays</a> という機能がある。以前 ppolicy_hash_cleartext と <a href=/diary/posts/2023/0417/#openldap-のカスタム-overlay-モジュールのデバッグ>カスタム overlay モジュール</a> を組み合わせると ppolicy が平文パスワードをハッシュ化してしまって、自分たちのカスタム overlay モジュールから平文パスワードを取得できないことをデバッグで検証した。ppolicy_hash_cleartext の機能が必要なのかどうかが私はよくわかっていないけど、協調して自分たちのカスタム overlay モジュールが動くならそれに越したことはない。</p><p>gdb でデバッグして振る舞いと対応方法が分かったところで issue を作成していた。メンバーが暇だったらやってくれるかな？と思っていたら誰も手をつけないみたいなので私がやろうと決めた。最早、私は c 言語をなんも分からんのやけど、chatgpt に質問しながら教えてもらえる。例えば、c 言語についてもこんな感じにヒアリングしながら実装する。</p><blockquote><p>Q. c 言語で関数の最初に変数を宣言するのと、実際に変数を割り当てるところで宣言するのでなにか振る舞いが違ったりしますか？どちらの方がよいのでしょうか？</p></blockquote><blockquote><p>C言語は伝統的に変数のスコープとライフタイムを管理するために、ブロック（通常は関数または制御構造内）の先頭で変数を宣言するスタイルを採用してきました。しかし、C99標準以降では、変数はその使用が初めて必要となる場所で宣言できるようになりました。
これら2つのスタイルの違いは、主にスコープ、可読性、そしてある程度はパフォーマンスに関連しています。</p><p><strong>スコープとライフタイム</strong></p><p>関数の先頭で変数を宣言すると、その変数は関数全体で使用できます。これは必要に応じて変数を再利用できるという利点がありますが、一方でスコープが広くなりすぎて変数の使用を追跡しにくくなるという欠点もあります。
一方、変数を使用が必要となる場所で宣言すると、その変数のスコープとライフタイムはその場所からブロックの終わりまでに制限されます。これは、変数の使用をより明確にし、未使用の変数を避けるという利点があります。</p><p><strong>可読性</strong></p><p>変数を使用が必要となる場所で宣言すると、その変数の目的と使用方法がより明確になるため、コードの可読性が向上することが多いです。一方で、関数の先頭で変数を一括して宣言すると、変数の目的が明確でない場合や、それらがどのように使用されるのかを追跡するのが難しくなることがあります。</p><p><strong>パフォーマンス</strong></p><p>パフォーマンスについては、現代のコンパイラは非常に高度に最適化されているため、変数の宣言場所がパフォーマンスに直接的な影響を及ぼすことはほとんどありません。</p><p><strong>結論</strong></p><p>どちらのスタイルを選ぶかは、主にプログラミングスタイルやチームのコーディング規約、または特定のタスクに対する特定の要件に依存します。しかし、変数を使用が初めて必要となる場所で宣言するスタイルは、コードの可読性を向上させ、変数のスコープとライフタイムを制限するという利点から、一般的には推奨されています。これにより、コードの可読性が向上し、変数の使用範囲が明確になるため、コードの理解と保守が容易になります。</p></blockquote><p>そっか。C99 で変数宣言の制約が撤廃されたんだということを学んだ。そんな感じで openldap についても chatgpt にヒアリングしながら開発したら意外とすんなり実装できてローカルでは動いた。レビューまでできた。</p></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2023/0417/>カスタム overlay モジュールを完全にマスターした</a></h1><div class=post-meta><time class=post-date>2023-04-17 (Mon.) ::</time></div><span class=post-tags>#<a href=/diary/tags/ldap/>ldap</a>&nbsp;
#<a href=/diary/tags/debug/>debug</a>&nbsp;</span><div class=post-content><p>0時に寝て何度か起きて7時に起きた。変な夢をみた気がするが、どんな夢だったかは思い出せない。</p><h2 id=openldap-のカスタム-overlay-モジュールのデバッグ>openldap のカスタム overlay モジュールのデバッグ</h2><p>先週末から <a href=/diary/posts/2023/0414/#chatgpt-と一緒にデバッグ>openldap のカスタム overlay モジュール</a> の開発やデバッグをしている。openldap のソースコードや gdb のデバッグのやり方にも慣れてきて私の中でも理解度が増してきた。</p><p>openldap サーバーのデバッグログは次のコードが設定されている。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#define LDAP_DEBUG_TRACE  0x0001
</span></span></span></code></pre></div><p>このコードを slapd.conf の loglevel に設定するとデバッグログを出力できるようになる。</p><pre tabindex=0><code>loglevel stats 0x0001 ...
</code></pre><p>このときに ppolicy の overlay モジュールがどのタイミングで呼ばれるかをデバッグログを確認しながら検証した。</p><pre tabindex=0><code>overlay ppolicy
ppolicy_hash_cleartext on
</code></pre><p>結論から言うと次の2点になる。</p><ul><li>overlay は slapd.conf の後ろに書いた方のカスタムモジュールが先に実行される</li><li>ppolicy_hash_cleartext は ppolicy_add のタイミングで平文パスワードをハッシュ化している<ul><li>gdb でデバッグすると op->o_request->oq_add->rs_modlist も op->o_request->oq_add->rs_e->e_attrs も同じアドレスを指す</li><li>overlay の処理は db に書き込む前と後の2つのタイミングがある</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>slap_passwd_hash</span>( <span style=color:#f92672>&amp;</span>(pa<span style=color:#f92672>-&gt;</span>a_vals[<span style=color:#ae81ff>0</span>]), <span style=color:#f92672>&amp;</span>hpw, <span style=color:#f92672>&amp;</span>txt );
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>pa<span style=color:#f92672>-&gt;</span>a_vals[<span style=color:#ae81ff>0</span>].bv_val <span style=color:#f92672>=</span> hpw.bv_val;
</span></span><span style=display:flex><span>pa<span style=color:#f92672>-&gt;</span>a_vals[<span style=color:#ae81ff>0</span>].bv_len <span style=color:#f92672>=</span> hpw.bv_len;
</span></span></code></pre></div><p>カスタム overlay モジュールを使って openldap からパスワードを取得するには次の順番で処理が行われることを理解しておく必要がある。</p><ol><li>mycustom_add &lt;= このタイミングで平文パスワードを取得しないといけない</li><li>ppolicy_add &lt;= このタイミングで平文のパスワードをハッシュ化する</li><li>mycustom_add_response &lt;= このタイミングではすでにパスワードがハッシュ化されている</li></ol><p>openldap のことを何も知らない素人が chatgpt と一緒にデバッグしてこのことを2日で理解できた。開発のやり方が変わっていく予兆を感じた。</p></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2023/0415/>休出デバッグ</a></h1><div class=post-meta><time class=post-date>2023-04-15 (Sat.) ::</time></div><span class=post-tags>#<a href=/diary/tags/life/>life</a>&nbsp;
#<a href=/diary/tags/gpt/>gpt</a>&nbsp;
#<a href=/diary/tags/debug/>debug</a>&nbsp;</span><div class=post-content><p>昨日は久しぶりに飲みに行っきて1時に寝て8時に起きた。</p><h2 id=ストレッチ>ストレッチ</h2><p>外がだいぶ暖かくなってきて散歩に行く機会も増えてきた気がする。今日の開脚幅は開始前157cmで、ストレッチ後159cmだった。先週と違って今週は忙しくて座っている時間が大幅に増えた。そして、その分の右腰の張りは強かった。腰の張り具合はその週の忙しさや労働時間で推測できるぐらいにはわかってきた。それ以外はだいたい可もなく不可もなくな感じだったと思う。</p><h2 id=淡路牛の受け取り>淡路牛の受け取り</h2><p>姉からお肉が届くという連絡があったので日時を調整して受け取った。<a href=https://www.awajikoku.com/shimasalad/2022/12/04/20221204094613/>島サラダフェア2022</a> という懸賞に応募していたのが当たったらしい。5000円相当の淡路牛らしい。お正月に食べるようなお肉だと言えば伝わるかな。A賞の5名のうちの1人がここにいるので総応募数は推して知るべし。姉が言うには全然応募ないらしい。こういうの調べて真面目に応募してメルカリで売るみたいなことやったらそれなりに儲かるのかもしれない。運営はマーケティングのやり方を変えた方がいいんじゃないかとか心配になって話していた。</p><figure><img src=/diary/img/2023/0415_awaji-beef.jpg></figure><h2 id=openldap-の-overlay-のデバッグ>openldap の overlay のデバッグ</h2><p>午後から昨日の続き。<a href=https://openai.com/blog/chatgpt>chatgpt</a> と一緒に openldap サーバーのカスタム overlay モジュールのデバッグをしていた。昨日の時点では2つの問題があることを確認できていた。今日は個々の問題の詳細をデバッグしながらワークアラウンドとして動かすためのコードを書いた。1つはビルドの問題じゃないかと思える不可思議な現象が起きていて、もう1つは openldap の ppolicy の仕様とカスタム overlay モジュールの仕様のどちらが正しいのかを設計者に確認する必要がある。15年ぶりぐらいに c 言語のコードを書いている。かなり怪しいけど、gdb をインタラクティブな repl のようにして振る舞いを確認しながら書いている。カスタム overlay モジュールでエラーが発生すると openldap はその処理をスキップするようにみえて、なんのログも出ない。細かくログ出力してどこまで動いたのかを確認しながら開発するとよさそうな雰囲気がわかった。</p></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2023/0414/>oss な開発は chatgpt が猛威を振るう予感</a></h1><div class=post-meta><time class=post-date>2023-04-14 (Fri.) ::</time></div><span class=post-tags>#<a href=/diary/tags/ldap/>ldap</a>&nbsp;
#<a href=/diary/tags/gpt/>gpt</a>&nbsp;
#<a href=/diary/tags/debug/>debug</a>&nbsp;
#<a href=/diary/tags/tax/>tax</a>&nbsp;
#<a href=/diary/tags/drinking/>drinking</a>&nbsp;</span><div class=post-content><p>2時に寝て6時半に起きた。開発の追い込みが佳境に入ってきて集中力が増してきた。</p><h2 id=chatgpt-と一緒にデバッグ>chatgpt と一緒にデバッグ</h2><p>openldap サーバーの拡張の仕組みに <a href=https://www.openldap.org/doc/admin24/overlays.html>Overlays</a> がある。c 言語でカスタム overlay を実装することで openldap サーバーに任意のフック処理を実装できる。いまやっていることはパスワードの追加や更新をフックしてそのパスワードを id 連携するためのモジュールを開発している。というか、開発済みだと聞いていたモジュールが意図したように動かないのでデバッグしている。例えば <code>ppolicy</code> という overlay を使って次のように設定すると、平文で送ったパスワードをディレクトリサービスの db へ格納する前に平文からパスワードをハッシュ化してくれる。この変換はパスワード変更を overlay でフックして実装されている。</p><pre tabindex=0><code>overlay ppolicy
ppolicy_hash_cleartext on
</code></pre><p>overlay は slapd.conf に設定した順番に実行されるようで、それぞれの overlay に依存関係がある場合は実際の処理にも影響がある。そんな openldap サーバーの拡張モジュールの開発を引き継ぐことになったが、私がまったく openldap サーバーのことをわかっていないので <a href=https://openai.com/blog/chatgpt>chatgpt</a> を使って理解しながらデバッグしている。これがそれなりにうまくいっていて調査が捗った。但し、chatgpt が教えてくれたことなので完全に正しいかどうかの保証がない。振る舞いで検証できるものはともかく、そうじゃないものは最後に有識者に正しいかどうかを確認する必要がある。</p><p>例えば、次のような ldif エントリーをサンプルとして、パスワードは <code>userPassword</code> という属性で扱う。ここで <code>userPassword</code> だけコロンが2重 (<code>::</code>) になっていることがわかる。これは属性の値が base64 でエンコーディングされていることを意味している。こういった2重コロンのような短いキーワードを検索で調べるのは難しい。chatgpt ならピンポイントに答えてくれる。</p><pre tabindex=0><code>dn: uid=jdoe,ou=users,dc=example,dc=com
objectClass: top
objectClass: person
objectClass: organizationalPerson
objectClass: inetOrgPerson
uid: jdoe
cn: John Doe
givenName: John
sn: Doe
mail: jdoe@example.com
userPassword:: e1NTSEF9bm9ZMU5kdzN3WUdSbFhpdDJUaTY5UW9SeXpXaklEeXc=
</code></pre><p>openldap は oss だし、ドキュメントもインターネット上にあるので構造体の定義や c 言語のサンプルコードも書いてくれる。それらが完全に正しいか、私には判断できないが、openldap のソースコードで調査するところの当たりをつけるには十分な情報を返してくれる。カスタム overlay を開発するときの主要なエントリーポイントと ldap 操作のタグ名は次になる。</p><ul><li>bi_op_bind: バインド（認証）操作に対応するエントリーポイント、LDAP_REQ_BIND</li><li>bi_op_search: 検索操作に対応するエントリーポイント、LDAP_REQ_SEARCH</li><li>bi_op_compare: 比較操作に対応するエントリーポイント、LDAP_REQ_COMPARE</li><li>bi_op_modify: 修正（属性の追加、削除、変更）操作に対応するエントリーポイント、LDAP_REQ_MODIFY</li><li>bi_op_modrdn: エントリ名の変更 (MODIFY RDN) 操作に対応するエントリーポイント、LDAP_REQ_MODRDN</li><li>bi_op_add: エントリの追加操作に対応するエントリーポイント、LDAP_REQ_ADD</li><li>bi_op_delete: エントリの削除操作に対応するエントリーポイント、LDAP_REQ_DELETE</li><li>bi_op_abandon: 中止操作に対応するエントリーポイント、LDAP_REQ_ABANDON</li><li>bi_op_extended: 拡張操作に対応するエントリーポイント、LDAP_REQ_EXTENDED</li></ul><p>例えば、LDAP_REQ_ADD は ldap.h で次のように定義されている。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#define LDAP_REQ_ADD        ((ber_tag_t) 0x68U) </span><span style=color:#75715e>/* application + constructed */</span><span style=color:#75715e>
</span></span></span></code></pre></div><p>これを gdb でデバッグしてタグを確認するときは次のように Operation 構造体内の o_tag をチェックすればよい。gdb で16進数表示するときは <code>/x</code> を指定する。</p><pre tabindex=0><code>(gdb) print /x op-&gt;o_tag
$8 = 0x68
</code></pre><p>ppolicy よりも前にカスタム overlay を設定すれば平文のパスワードにアクセスできそうにみえるのだけど、gdb でデバッグしているとハッシュ化済みのパスワードになっていた。</p><p>あと稼働している openldap サーバーに gdb で attach してデバッグする方法も chatgpt に聞きながら行った。やりたい操作に対して gdb のコマンドを教えてもらってすぐに検証してフィードバックからさらに質問できるのでインタラクティブな repl のような環境と chatgpt は相性がよいように思えた。gdb のコマンドを覚えておく必要も、ググる必要もないことに気付いた。</p><h2 id=近況報告>近況報告</h2><p>元同僚と <a href=/diary/posts/2022/0311/#近況報告>約1年ぶりの近況報告</a> の雑談会をしてきた。これで3回目かな。毎年の恒例行事のようになってきた。兵庫県の住みたい街ランキングでいつも上位にある <a href=https://www.nishi.or.jp/>西宮市</a> でカレーを食べて、バーで飲んできた。三ノ宮から西宮は快速で15分程度の距離。すぐ行ける場所なんだが、とくに行く機会がなかったので神戸に引っ越してきて5年以上経つのに電車で行ったのは今回が初めてになる。いつも通り近況を聞きながら、みんな私と同じぐらいの世代なので今後のキャリアの方向性などを話していた。</p><p>私は起業して税金やその仕組みに関心をもつようになり、起業する前より少し詳しくなった。知人から節税相談を受けることもある。税金の基本的な考え方として、1つの大きな収入に対して節税することはできない。自由に使えるお金がほしかったら基本的に節税できない。税金をたくさん払って貯金するしかない。一方で個人と会社に資産を分割したり、共済や基金を活用することで手取りの収入は減るが、支払う税金は少なくなって中長期でみると資産が増える。例えば、共済や基金に積み立てたお金は原則としては退職所得で戻ってくるので、ずっと優遇された <a href=https://www.nta.go.jp/taxes/shiraberu/taxanswer/shotoku/1420.htm>退職所得の所得税</a> により、最終的に支払う税金が少なくなるからである。これが税金を支払う基本的な考え方。自分の手元にお金を残した上で税金を払いたくないが、どうすればよいか？とよく聞かれるが、そんなことはできないというのが模範回答になる。元同僚も私もそうなのだが、もはや自分の生活にお金をあまり必要としていない。私が節税の仕組みを調べたり実践したりするのは、税金の仕組みを学ぶために過ぎない。ただ知識として学ぶよりも、実際に実践して運用してみる方が学びになる。</p><p>以前の <a href=/diary/posts/2023/0408/#もくもく会>出張もくもく会</a> の後で懇親会のときにそのうち資本主義は新しい制度にとって変わられるのではないかという話題があった。それは行き過ぎた資本主義の弊害と、資本主義である限り40時間/週の労働時間から抜け出すには資本家になるしかなくて、人類はすでにこれだけ技術があるのだからもっと多くの人が今よりも働かずに食べていけるのではないかと多くの人が考えている。私の場合も、実質は自分のやりたいことしかやってなくて、自分のために働きながらも、老後のために一応はお金をもらっておくみたいな働き方になっている。この考え方は資本主義の次の制度へ移行するときに活きてくればいいなと思う。</p></div></article><div class=pagination><div class=pagination__buttons></div></div></div></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>© 2021 Tetsuya Morimoto</span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script type=text/javascript src=/diary/bundle.min.js></script></div></body></html>