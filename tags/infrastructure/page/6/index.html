<!doctype html><html lang=en><head><title>Infrastructure :: </title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=/diary/tags/infrastructure/><link rel=stylesheet href=/diary/styles.css><link rel=stylesheet href=/diary/style.css><link rel="shortcut icon" href=/diary/favicon.ico><meta name=twitter:card content="summary"><meta name=twitter:site content="t2y"><meta name=twitter:creator content><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:title" content="Infrastructure"><meta property="og:description" content><meta property="og:url" content="/diary/tags/infrastructure/"><meta property="og:site_name" content><meta property="og:image" content="/diary/favicon.ico"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><link href=/diary/tags/infrastructure/index.xml rel=alternate type=application/rss+xml title></head><body class=green><div class="container full headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/diary><div class=logo>forest nook</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/diary/about>自己紹介</a></li><li><a href=/diary/dates>月別一覧</a></li><li><a href=/diary/tags>タグ一覧</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/diary/about>自己紹介</a></li><li><a href=/diary/dates>月別一覧</a></li><li><a href=/diary/tags>タグ一覧</a></li></ul></nav></header><div class=content><h1>Posts for: #Infrastructure</h1><div class=posts><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2022/0408/>壊れた cf スタックのリストアと cdk の再同期</a></h1><div class=post-meta><time class=post-date>2022-04-08</time></div><span class=post-tags>#<a href=/diary/tags/cdk/>cdk</a>&nbsp;
#<a href=/diary/tags/infrastructure/>infrastructure</a>&nbsp;</span><div class=post-content><p>2時に寝て6時半に起きた。インフラエンジニアになったのでみんなが作業していない時間にインフラの保守作業をするようにしている。昼はアプリケーションエンジニア、夜はインフラエンジニアみたいな生活になっていてしんどい。</p><h2 id=壊れた-cf-スタックの更新>壊れた cf スタックの更新</h2><p>テスト環境の cf スタックを手動で更新して壊れているのを cdk で管理できるように直した。壊れていたのは次の3つ。</p><ul><li>rds をスナップショットからリストアしたので cf が管理している rds リソースが存在しない</li><li>iam の acl 設定が異なる</li><li>セキュリティグループのインバウンドルールが異なる</li></ul><p>aws 的にもそういった状況は認識していて cdk で同期できなくなった cf スタックを更新する手順を提供している。</p><ul><li><a href=https://aws.amazon.com/jp/premiumsupport/knowledge-center/delete-cf-stack-retain-resources/>AWS CloudFormation スタックを削除したときにリソースの一部を保持する方法を教えてください。</a></li></ul><p>ざっくり手順をまとめると次になる。</p><ol><li>対象のリソースに DeletetionPolicy=Retain にセットする</li><li>テンプレートからリソースを削除して、スタックの更新を実行する</li><li>テンプレート内のリソースの実際の状態を describe して、スタック内に既存のリソースをインポートする</li></ol><p>リソースの設定ぐらいなら既存のリソースからインポートしなくても cf のテンプレートを直接書き換えたものをアップロードしてスタックを更新するのでも大丈夫だったりする。しかし、cdk もそのテンプレートにあうように修正しないといけないため、cdk のコードとテンプレートのコードの両方をチェックしながら検証する必要がある。cdk でリソース管理ができるようになったからといって、それが変更前の既存のリソースの設定と同じかどうかは人間が目でみて検証しないといけない。これがあちこちで参照されているリソースだと追跡するのが面倒くさいといった手間暇がかかる。</p><p>cdk がよいものかどうか、私はまだ判断がつかないけど、cf を抽象化して便利になっているところは認めるものの、cf のスタックが壊れたときのトラブルシューティングが必要以上に複雑で厄介というのも事実ではある。一方で壊れた cf スタックを5時間ぐらいかけて直したのではまりポイントはいくつかも学ぶことができた。しんどかったけど。例えば、あるセキュリティグループのインバウンドルールに別のセキュリティグループを関連付けるとき、1つの設定ではうまくいかなくて次の2つの設定を追加した。これが適切かどうかわからないが、この設定で cdk でデプロイしたスタックの環境と既存リソースとの環境が整合した状態 (ドリフトが解消される) になった。こういうのが cdk の抽象化による訳のわからないところの1つ。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#a6e22e>otherSecurityGroup</span>.<span style=color:#a6e22e>addIngressRule</span>(
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>ec2</span>.<span style=color:#a6e22e>SecurityGroup</span>.<span style=color:#a6e22e>fromSecurityGroupId</span>(<span style=color:#66d9ef>this</span>, <span style=color:#e6db74>&#39;my security group&#39;</span>, <span style=color:#a6e22e>mySgId</span>),
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>ec2</span>.<span style=color:#a6e22e>Port</span>.<span style=color:#a6e22e>tcp</span>(<span style=color:#ae81ff>80</span>),
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;my inboud rule&#34;</span>,
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>otherSecurityGroup</span>.<span style=color:#a6e22e>addIngressRule</span>(
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>ec2</span>.<span style=color:#a6e22e>Peer</span>.<span style=color:#a6e22e>securityGroupId</span>(<span style=color:#a6e22e>mySgId</span>),
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>ec2</span>.<span style=color:#a6e22e>Port</span>.<span style=color:#a6e22e>tcp</span>(<span style=color:#ae81ff>80</span>),
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;my inboud rule&#34;</span>,
</span></span><span style=display:flex><span>)
</span></span></code></pre></div></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2022/0407/>cdk のメジャーバージョンのマイグレーション</a></h1><div class=post-meta><time class=post-date>2022-04-07</time></div><span class=post-tags>#<a href=/diary/tags/cdk/>cdk</a>&nbsp;
#<a href=/diary/tags/infrastructure/>infrastructure</a>&nbsp;</span><div class=post-content><p>0時に寝て5時に起きた。開発者にインフラ変更の影響を出さないように6時半からインフラのお仕事してた。</p><h2 id=cdk-v1-と-v2-の違い>cdk v1 と v2 の違い</h2><p><a href=https://docs.aws.amazon.com/cdk/api/versions.html>AWS CDK Versions</a> には v1 と v2 の2つがある。新規で作るものは v2 を選択すればよいけど、既存のスタックが v1 だとマイグレーションが必要になる。cdk は bootstrap したときに CDKToolkit というスタックを生成する。cdk をアップグレードするというのはこのスタックの設定も更新する必要がある。デフォルト設定をそのまま使っていればマイグレーションはそんなに難しくはないはずだけど、設定をカスタマイズしていたりするといくつかパラメーターを調整したりしなかったりしてややこしいかもしれない。</p><ul><li><a href=https://docs.aws.amazon.com/cdk/v2/guide/migrating-v2.html>Migrating to AWS CDK v2</a></li><li><a href=https://docs.aws.amazon.com/cdk/v2/guide/bootstrapping.html>Bootstrapping</a></li></ul><p>また v2 は v1 の experimental な機能は移行されていないため、v1 のライブラリを直接使うか、自前でその機能を実装するといったことも必要になる可能性がある。</p><blockquote class=twitter-tweet><p lang=ja dir=ltr>cdk v2 を使っていて v1 にある機能が v2 になくてあれー？って感じで調べてたら experimental な機能はまだ移行されてないらしい。<a href=https://t.co/SbRZ5ddrTj>https://t.co/SbRZ5ddrTj</a></p>&mdash; Tetsuya Morimoto (@t2y) <a href="https://twitter.com/t2y/status/1511924087450640386?ref_src=twsrc%5Etfw">April 7, 2022</a></blockquote><script async src=https://platform.twitter.com/widgets.js></script><p>例えば、v1 の apigwv2.VpcLink というメソッドは experimental で v2 に移行されていないため、v2 に移行されている stable な CfnVpcLink という機能を使って次のように実装した。これは v1 の cdk の実装をみて同じように実装しただけ。</p><ul><li><a href=https://github.com/aws/aws-cdk/pull/10531/files#diff-1cf3aaf7b2b6b2e72123b93cb3108eb9e9a3291e588d62eb2cd34dd0509d3045>https://github.com/aws/aws-cdk/pull/10531/files#diff-1cf3aaf7b2b6b2e72123b93cb3108eb9e9a3291e588d62eb2cd34dd0509d3045</a></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#f92672>-    const apiGwVpcLink = new apigwv2.VpcLink(this, &#39;ApiGwVpcLink&#39;, {
</span></span></span><span style=display:flex><span><span style=color:#f92672>-      vpc: vpc,
</span></span></span><span style=display:flex><span><span style=color:#f92672>-      vpcLinkName: &#39;my-vpc-link&#39;,
</span></span></span><span style=display:flex><span><span style=color:#f92672>-      securityGroups: [mySecurityGroup]
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+    const apiGwVpcLink = new  apigwv2.CfnVpcLink(this, &#39;ApiGwVpcLink&#39;, {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+     name: &#39;my-vpc-link&#39;,
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+     subnetIds: vpc.privateSubnets.map(sb =&gt; sb.subnetId),
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+     securityGroupIds: [mySecurityGroup.securityGroupId]
</span></span></span></code></pre></div></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2022/0406/>ecs の draining とタスクの停止時間</a></h1><div class=post-meta><time class=post-date>2022-04-06</time></div><span class=post-tags>#<a href=/diary/tags/infrastructure/>infrastructure</a>&nbsp;</span><div class=post-content><p>0時に寝て4時に起きた。なんか起きてから sns のタイムラインを眺めてた。6時半にはオフィスについて cdk のコードを読み始めた。</p><h2 id=ecs-の-draining-に時間がかかる>ecs の draining に時間がかかる？</h2><p>cdk でインフラのデプロイをしていて、ecs のタスクの置き換えにやたら時間がかかっているのに気付いた。調べてみると、aws のドキュメントがすぐにヒットした。デフォルトでは停止するまでに5分ぐらいかかってしまうようだけど、それを調整したかったらいくつかパラメーターがある。</p><ul><li><a href=https://aws.amazon.com/jp/premiumsupport/knowledge-center/ecs-tasks-stop-delayed-draining/>コンテナインスタンスが DRAINING に設定されているときに、Amazon ECS タスクが停止するのに時間がかかるトラブルシューティング方法を教えてください。</a></li></ul><h4 id=ecs-サービスの-deployment-configuration>ecs サービスの deployment configuration</h4><ul><li>minimumHealthyPercent: 同時に停止できるタスクの割合設定</li><li>maximumPercent: draining されるタスクが停止するまで置き換えるタスクを開始するかどうかの設定？</li></ul><h4 id=ロードバランサーの-deregistration-delay>ロードバランサーの deregistration delay</h4><ul><li>deregistrationDelay: elb(nlb) が登録解除処理が完了するまでに待つ時間。タスクが draining の状態になってこの時間が過ぎた後に登録解除して target が未使用になる</li></ul><h4 id=ecs-タスク定義の-stop-timeout>ecs タスク定義の stop timeout</h4><ul><li>stopTimeout: コンテナーが正常終了しないときに ecs が強制的にプロセスを kill するまでの待ち時間</li></ul><p>それぞれのインフラの状況にあわせて適切なパラメーターを変更すればよい。私が管理しているのは次の2つを変更した。</p><ul><li>maximumPercent: 100 -> 200 (%)</li><li>deregistrationDelay: 300 -> 30 (秒)</li></ul><p>これで18分ほどかかっていたデプロイ時間を8分ぐらいまで短縮できた。テスト環境の設定なので多少のエラーが発生したとしても速い方がよい。</p></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2022/0405/>再びのインフラエンジニア</a></h1><div class=post-meta><time class=post-date>2022-04-05</time></div><span class=post-tags>#<a href=/diary/tags/infrastructure/>infrastructure</a>&nbsp;</span><div class=post-content><p>0時に寝て7時に起きた。</p><h2 id=インフラタスクに専念>インフラタスクに専念</h2><p>本当はインフラ担当者が別途いるのだけど、多忙過ぎて、インフラタスクが1ヶ月近く遅延していて、プロジェクト内で合意を得て私がすべて巻き取ることにした。内容の如何に依らず、その一切合切をすべて巻き取ると宣言した。過去に働いた会社でも他の担当者ができなかった業務を後からリカバリするのはよくやってたのでそれ自体は構わない。ただ他人のタスクを肩代わりしても評価されないことも多くて、もともと私のタスクではないから誰がやったかなんか忘れてしまうんよね。私もとくにアピールしないからそう認識されても構わないのだけど、そういう業務が増えてくるとその職場を辞めるきっかけにもなってた。</p><p>インフラ担当者や他の社員さんにヒアリングしながら現時点でも十数個のタスクがある。過去のインフラの負債も含めて2-3週間ぐらい、私が集中的にやればすべて片がつくのではないかと考えている。今日たまたまスクラムのリファインメントやってて、業務の人から他の機能開発が遅れているのに2-3週間もインフラ作業に専念するってどういうこと？インフラタスクってインフラ担当者にやってもらえないんですか？と質問を受けて、できるんならその方が望ましいけど、過去の実績からまったく進捗しないのでこちらでやるざるを得ない状況というのを説明した。業務の人からみたらインフラなんか何をやっているかわからないからそんなもんよね。これから2-3週間経って蓄積したインフラタスクをすべて解決した後で少し時間が経つとインフラ担当者が全部やったように外部からはみえてしまうというのを、過去に何度も経験した。</p></div></article><div class=pagination><div class=pagination__buttons><a href=/diary/tags/infrastructure/page/5/ class="button previous"><span class=button__icon>←</span>
<span class=button__text>最近の日記</span></a></div></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2024 Powered by <a href=https://gohugo.io>Hugo</a></span>
<span>:: <a href=https://github.com/panr/hugo-theme-terminal target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/diary/bundle.min.js></script></div></body></html>