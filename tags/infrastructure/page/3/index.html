<!doctype html><html lang=en>
<head>
<title>infrastructure :: forest nook</title>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content>
<meta name=keywords content>
<meta name=robots content="noodp">
<link rel=canonical href=/diary/tags/infrastructure/>
<link rel=stylesheet href=/diary/assets/style.css>
<link rel=stylesheet href=/diary/assets/green.css>
<link rel=stylesheet href=/diary/style.css>
<link rel=apple-touch-icon href=/diary/img/apple-touch-icon-192x192.png>
<link rel="shortcut icon" href=/diary/favicon.ico>
<meta name=twitter:card content="summary">
<meta name=twitter:site content="t2y">
<meta name=twitter:creator content>
<meta property="og:locale" content="en">
<meta property="og:type" content="website">
<meta property="og:title" content="infrastructure">
<meta property="og:description" content>
<meta property="og:url" content="/diary/tags/infrastructure/">
<meta property="og:site_name" content="forest nook">
<meta property="og:image" content="/diary/favicon.ico">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">
<link href=/diary/tags/infrastructure/index.xml rel=alternate type=application/rss+xml title="forest nook">
</head>
<body class=green>
<div class="container full headings--one-size">
<header class=header>
<div class=header__inner>
<div class=header__logo>
<a href=/diary>
<div class=logo>
forest nook
</div>
</a>
</div>
<div class=menu-trigger>menu</div>
</div>
<nav class=menu>
<ul class="menu__inner menu__inner--desktop">
<li><a href=/diary/about>自己紹介</a></li>
<li><a href=/diary/dates>月別一覧</a></li>
<li><a href=/diary/tags>タグ一覧</a></li>
</ul>
<ul class="menu__inner menu__inner--mobile">
<li><a href=/diary/about>自己紹介</a></li>
<li><a href=/diary/dates>月別一覧</a></li>
<li><a href=/diary/tags>タグ一覧</a></li>
</ul>
</nav>
</header>
<div class=content>
<div class=posts>
<div class="post on-list">
<h1 class=post-title>
<a href=/diary/posts/2022/0513/>マーケティング施策の取り組み開始</a>
</h1>
<div class=post-meta>
<span class=post-date>
2022-05-13
</span>
</div>
<span class=post-tags>
#<a href=/diary/tags/cdk/>cdk</a>&nbsp;
#<a href=/diary/tags/infrastructure/>infrastructure</a>&nbsp;
</span>
<div class=post-content>
<p>23時に寝て1時に起きて漫画を読んで6時に起きて漫画読んでた。</p>
<h2 id=隔週の雑談>隔週の雑談</h2>
<p>顧問のはらさんと隔週の打ち合わせ。今日の議題は <a href=/diary/posts/2022/0503/#打ち合わせ資料の作成>先日作成した第4期の展望</a> について雑談した。あまり深く考えずに起業して初期の頃に作った10ヶ年計画に対してわりとその通りに推移している。来期ぐらいで業務委託のお仕事は終える予定。来期か再来期ぐらいからプロダクト開発の期間に入る。自社プロダクトを作る前から徐々にマーケティングもしていかないといけない。そのため、今期からマーケティング施策を少しずつ増やしていて、まずは会社の信頼度を上げるところからやっていく。売上を上げるためのマーケティングではなく信頼度を上げるためのマーケティングを行う。金森氏が言うようにどんなに優れたプロダクトを作ったとしても売れるかどうかは別問題だ。</p>
<iframe width=500 height=250 scrolling=no src="https://alu.jp/series/%E6%98%A0%E5%83%8F%E7%A0%94%E3%81%AB%E3%81%AF%E6%89%8B%E3%82%92%E5%87%BA%E3%81%99%E3%81%AA%EF%BC%81/crop/embed/X8MNLWdDgPeZ5RIF25sD/0?referer=oembed" style=margin:auto></iframe>
<h2 id=eks-クラスターの-helm-管理の調査>eks クラスターの helm 管理の調査</h2>
<p>昨日の続き。権限設定がなんもわからんみたいな様相になったので調査のやり方を変えることにした。検証用の eks クラスターを cdk から新規に作成して helm をインストールするときのリソースや権限設定がどうなるのかを調査した。lambda 関数が5個ぐらい、ロールは10個ぐらい作成された。lambda の生成に時間がかかるのか？新規作成するのに25分、削除するときは30分ぐらいかかった。rds もそうだけど、eks のような複雑なインフラを cdk で管理すると実行するのにけっこう時間がかかる。設定が難しくなければ別によいけど、eks のような権限やリソースの設定が複雑なインフラはトライ&エラーで何度も実行する必要があるから、こういうものは cdk で管理するのには向かないインフラだと言えると思う。一定の設定のプラクティスが溜まるまでは eks は cdk で管理しない方がよいかもしれない。</p>
<p>CreationRole というのが設定されて trust relationships に次のような設定が追加される。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
    <span style=color:#f92672>&#34;Version&#34;</span>: <span style=color:#e6db74>&#34;2012-10-17&#34;</span>,
    <span style=color:#f92672>&#34;Statement&#34;</span>: [
        {
            <span style=color:#f92672>&#34;Effect&#34;</span>: <span style=color:#e6db74>&#34;Allow&#34;</span>,
            <span style=color:#f92672>&#34;Principal&#34;</span>: {
                <span style=color:#f92672>&#34;AWS&#34;</span>: <span style=color:#e6db74>&#34;arn:aws:iam::${accountId}:root&#34;</span>
            },
            <span style=color:#f92672>&#34;Action&#34;</span>: <span style=color:#e6db74>&#34;sts:AssumeRole&#34;</span>
        }
    ]
}
</code></pre></div><p>このロールに含まれるカスタムポリシーには次のような設定がある。たぶんこんな感じのロールを新規に作成して <code>kubectlRoleArn</code> として指定してやればいいんじゃないかと思う。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
    <span style=color:#f92672>&#34;Version&#34;</span>: <span style=color:#e6db74>&#34;2012-10-17&#34;</span>,
    <span style=color:#f92672>&#34;Statement&#34;</span>: [
        {
            <span style=color:#f92672>&#34;Action&#34;</span>: <span style=color:#e6db74>&#34;iam:PassRole&#34;</span>,
            <span style=color:#f92672>&#34;Resource&#34;</span>: <span style=color:#e6db74>&#34;arn:aws:iam::${accountId}:role/${EksClusterIamRole}&#34;</span>,
            <span style=color:#f92672>&#34;Effect&#34;</span>: <span style=color:#e6db74>&#34;Allow&#34;</span>
        },
        {
            <span style=color:#f92672>&#34;Action&#34;</span>: [
                <span style=color:#e6db74>&#34;eks:CreateCluster&#34;</span>,
                <span style=color:#e6db74>&#34;eks:DescribeCluster&#34;</span>,
                <span style=color:#e6db74>&#34;eks:DescribeUpdate&#34;</span>,
                <span style=color:#e6db74>&#34;eks:DeleteCluster&#34;</span>,
                <span style=color:#e6db74>&#34;eks:UpdateClusterVersion&#34;</span>,
                <span style=color:#e6db74>&#34;eks:UpdateClusterConfig&#34;</span>,
                <span style=color:#e6db74>&#34;eks:CreateFargateProfile&#34;</span>,
                <span style=color:#e6db74>&#34;eks:TagResource&#34;</span>,
                <span style=color:#e6db74>&#34;eks:UntagResource&#34;</span>
            ],
            <span style=color:#f92672>&#34;Resource&#34;</span>: [
                <span style=color:#e6db74>&#34;arn:aws:eks:ap-northeast-1:${accountId}:cluster/tmp-test-eks-cluster-by-morimoto&#34;</span>,
                <span style=color:#e6db74>&#34;arn:aws:eks:ap-northeast-1:${accountId}:cluster/tmp-test-eks-cluster-by-morimoto/*&#34;</span>
            ],
            <span style=color:#f92672>&#34;Effect&#34;</span>: <span style=color:#e6db74>&#34;Allow&#34;</span>
        },
        {
            <span style=color:#f92672>&#34;Action&#34;</span>: [
                <span style=color:#e6db74>&#34;eks:DescribeFargateProfile&#34;</span>,
                <span style=color:#e6db74>&#34;eks:DeleteFargateProfile&#34;</span>
            ],
            <span style=color:#f92672>&#34;Resource&#34;</span>: <span style=color:#e6db74>&#34;arn:aws:eks:ap-northeast-1:${accountId}:fargateprofile/tmp-test-eks-cluster-by-morimoto/*&#34;</span>,
            <span style=color:#f92672>&#34;Effect&#34;</span>: <span style=color:#e6db74>&#34;Allow&#34;</span>
        },
        {
            <span style=color:#f92672>&#34;Action&#34;</span>: [
                <span style=color:#e6db74>&#34;iam:GetRole&#34;</span>,
                <span style=color:#e6db74>&#34;iam:listAttachedRolePolicies&#34;</span>
            ],
            <span style=color:#f92672>&#34;Resource&#34;</span>: <span style=color:#e6db74>&#34;*&#34;</span>,
            <span style=color:#f92672>&#34;Effect&#34;</span>: <span style=color:#e6db74>&#34;Allow&#34;</span>
        },
        {
            <span style=color:#f92672>&#34;Action&#34;</span>: <span style=color:#e6db74>&#34;iam:CreateServiceLinkedRole&#34;</span>,
            <span style=color:#f92672>&#34;Resource&#34;</span>: <span style=color:#e6db74>&#34;*&#34;</span>,
            <span style=color:#f92672>&#34;Effect&#34;</span>: <span style=color:#e6db74>&#34;Allow&#34;</span>
        },
        {
            <span style=color:#f92672>&#34;Action&#34;</span>: [
                <span style=color:#e6db74>&#34;ec2:DescribeInstances&#34;</span>,
                <span style=color:#e6db74>&#34;ec2:DescribeNetworkInterfaces&#34;</span>,
                <span style=color:#e6db74>&#34;ec2:DescribeSecurityGroups&#34;</span>,
                <span style=color:#e6db74>&#34;ec2:DescribeSubnets&#34;</span>,
                <span style=color:#e6db74>&#34;ec2:DescribeRouteTables&#34;</span>,
                <span style=color:#e6db74>&#34;ec2:DescribeDhcpOptions&#34;</span>,
                <span style=color:#e6db74>&#34;ec2:DescribeVpcs&#34;</span>
            ],
            <span style=color:#f92672>&#34;Resource&#34;</span>: <span style=color:#e6db74>&#34;*&#34;</span>,
            <span style=color:#f92672>&#34;Effect&#34;</span>: <span style=color:#e6db74>&#34;Allow&#34;</span>
        }
    ]
}
</code></pre></div>
</div>
</div>
<div class="post on-list">
<h1 class=post-title>
<a href=/diary/posts/2022/0512/>cdk と eks と lambda と iam がわからん</a>
</h1>
<div class=post-meta>
<span class=post-date>
2022-05-12
</span>
</div>
<span class=post-tags>
#<a href=/diary/tags/cdk/>cdk</a>&nbsp;
#<a href=/diary/tags/infrastructure/>infrastructure</a>&nbsp;
</span>
<div class=post-content>
<p>0時に寝て3時に起きて漫画読んで5時に寝て8時に起きた。</p>
<h2 id=eks-クラスターの-helm-管理>eks クラスターの helm 管理</h2>
<p>昨日の続き。helm のよさはわかったので dapr を helm で管理しようとしている。その際になるべく cdk で管理できた方がよい。eks は cdk の外部で管理しているのだけど、既存の eks クラスターをインポートする機能も提供されていることに気付いた。</p>
<ul>
<li><a href=https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_eks-readme.html#using-existing-clusters>Using existing clusters</a></li>
</ul>
<p>それなら既存の eks クラスターをインポートして cdk で helm だけ管理しようと思って始めたものの、これがとても難しくて丸1日作業してわからなかった。設定項目は少ないけど、権限の問題で動かない。1回あたりの実行に15分ぐらいかかるのでトライ&エラーするのもなかなか大変。</p>
<blockquote>
<p><code>kubectlRoleArn</code> - the ARN of an IAM role mapped to the system:masters RBAC role. If the cluster you are importing was created using the AWS CDK, the CloudFormation stack has an output that includes an IAM role that can be used. Otherwise, you can create an IAM role and map it to system:masters manually. The trust policy of this role should include the the arn:aws::iam::${accountId}:root principal in order to allow the execution role of the kubectl resource to assume it.</p>
</blockquote>
<p><code>kubectlRoleArn</code> の設定をどうするかだけなんだが、この説明でどう設定していいか理解できなかった。cdk で新規に eks クラスターを作成するなら自動で作ってくれるけど、既存の eks クラスターの場合は自分で設定しないといけない。ややこしいことに cdk は kubectl の実行を lambda 経由で実行するので eks と lambda と iam のロールやポリシーを適切に設定する必要がある。lambda にどういう権限を設定するのが適切なのかは本当に難しい。サーバーレスはよいアイディアだとは思うけど、lambda は難し過ぎて私はなるべく使いたくないサービスではある。結局わからなくて翌日に持ち越し。</p>
</div>
</div>
<div class="post on-list">
<h1 class=post-title>
<a href=/diary/posts/2022/0427/>障害調査と先入観</a>
</h1>
<div class=post-meta>
<span class=post-date>
2022-04-27
</span>
</div>
<span class=post-tags>
#<a href=/diary/tags/cdk/>cdk</a>&nbsp;
#<a href=/diary/tags/infrastructure/>infrastructure</a>&nbsp;
</span>
<div class=post-content>
<p>23時に寝て5時過ぎに起きた。</p>
<h2 id=インフラの不具合調査>インフラの不具合調査</h2>
<p>本番環境に初回デプロイして ecs から secrets manager のアクセスに失敗しているエラーが出ていたので調査した。エラーメッセージでググるとクラスメソッドさんの記事が出てきた。</p>
<ul>
<li><a href=https://dev.classmethod.jp/articles/tsnote-ecs-resourceinitializationerror/>ECSでコンテナ環境変数をSecretManagerから取得する際にResourceInitializationErrorが発生したときの対処方法</a></li>
</ul>
<p>この記事によると、次のどちらかの原因かなと推測していた。</p>
<ul>
<li>実行 IAM ロールの権限不足</li>
<li>SecretsManager エンドポイントへの不到達</li>
</ul>
<p>調べども調べどもテスト環境との違いがわからなくてはまってしまった。ある検証をしていたときに、テスト環境を手動で構築した担当者から datadog の api key を設定してないんじゃない？と言われて、まさにそれが原因だった。cdk のコード上は設定済みのものとして ecs の datadog のサイドカーに設定していた。先入観で rds の credential 情報を取得できずにエラーになっていると思い込んでいたが、サイドカーの datadog の api key が原因ではまるべくしてはまったという感じ。</p>
<p>一方で secrets manager に登録するサードパーティの api key をどこで管理するかというのは難しい問題でもある。cdk のコードの中に書いてしまうというのも1つのやり方ではあるが、昨今の github 関連のサードパーティから派生したセキュリティインシデントで private リポジトリのソースコードにアクセスされることも発生しているのでソースコードには書きたくない。で、手動で secrets manager に設定しないといけないから、今回みたいな初回デプロイ時に誰も気付かないみたいなことが起きる。</p>
</div>
</div>
<div class="post on-list">
<h1 class=post-title>
<a href=/diary/posts/2022/0425/>本番環境反映の監督</a>
</h1>
<div class=post-meta>
<span class=post-date>
2022-04-25
</span>
</div>
<span class=post-tags>
#<a href=/diary/tags/cdk/>cdk</a>&nbsp;
#<a href=/diary/tags/infrastructure/>infrastructure</a>&nbsp;
</span>
<div class=post-content>
<p>昨日は思いっきり昼寝してしまったせいか、夜に眠れなくて3時ぐらいまで起きてて、寝たのか寝てのかよくわからない雰囲気で7時前に起きた。</p>
<h2 id=インフラ作業の本番反映>インフラ作業の本番反映</h2>
<p>先週対応した <a href=/diary/posts/2022/0419/>api gateway のコード化</a> を本番環境に反映した。手動で作成されていた api gateway, vpc link, セキュリティグループとそれに関連するリソース群を cdk 管理のコードで置き換える。既存のリソースを削除してから cdk でデプロイするため、失敗しても切り戻しできないのでプレッシャーがかかる。とはいえ、想定通りに作業が進捗して2時間ほどで完了した。それと並行してテスト環境では、手動で作成された rds を cdk 管理のコードで置き換える移行作業をしていた。これも一筋縄ではいかなくて右往左往しながら作業してた。これを本番環境でやるのもまた億劫だなぁと思いながら発生したエラーや事象を書き綴っていた。あと本番環境で行う大きな移行作業はこれだけ。</p>
</div>
</div>
<div class="post on-list">
<h1 class=post-title>
<a href=/diary/posts/2022/0421/>rds の再作成</a>
</h1>
<div class=post-meta>
<span class=post-date>
2022-04-21
</span>
</div>
<span class=post-tags>
#<a href=/diary/tags/cdk/>cdk</a>&nbsp;
#<a href=/diary/tags/infrastructure/>infrastructure</a>&nbsp;
</span>
<div class=post-content>
<p>23時に寝て5時半に起きた。久しぶりによく眠れた気がする。</p>
<h2 id=rds-を独立したスタックに分離>rds を独立したスタックに分離</h2>
<p>昨日の続き。ライフサイクルにあわせたスタックに分割し、スタック間の依存関係を適切に定義することで堅牢なインフラコードになる。最後に残った DatabaseStack を分離するところを朝からやっていた。</p>
<ul>
<li>DatabaseStack
<ul>
<li>BackendStack
<ul>
<li>GatewayStack
<ul>
<li>FrontendStack</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>rds を壊して、バージョンを aurora postgresql 最新の 13.x にアップグレードして、cf のテンプレートで小細工をしながら既存の環境を移行したりしていた。<a href=https://www.postgresql.org/docs/13/app-pgdump.html>pg_dump</a> を使ってテキストに dump したデータを、psql を使ってリストアしたりもした。データ量が少なかったらこれで移行してもいいかもしれない。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ pg_dump --host mydb.xxx.ap-northeast-1.rds.amazonaws.com --username user mydb &gt; mydb.dump
$ psql --host mydb.xxx.ap-northeast-1.rds.amazonaws.com --username user --dbname mydb --file ./mydb.dump
</code></pre></div>
</div>
</div>
<div class="post on-list">
<h1 class=post-title>
<a href=/diary/posts/2022/0420/>堅牢なインフラコード</a>
</h1>
<div class=post-meta>
<span class=post-date>
2022-04-20
</span>
</div>
<span class=post-tags>
#<a href=/diary/tags/life/>life</a>&nbsp;
#<a href=/diary/tags/cdk/>cdk</a>&nbsp;
#<a href=/diary/tags/infrastructure/>infrastructure</a>&nbsp;
</span>
<div class=post-content>
<p>23時に寝て5時に起きた。</p>
<h2 id=駐輪場の定期更新>駐輪場の定期更新</h2>
<p>3ヶ月ごとの更新。ちょうどいまのお仕事の契約と同じ更新月になっている。前回と同じ金額だったのでまだ駐輪場の料金は値上げされていない。世界的にインフレしているのに日本が全然インフレしていない理由の1つとして不動産が値上げしていないからというのを日銀の記事で見かけた気がする。どこかのタイミングで不動産関連の値上げも始まるのかもしれない。</p>
<h2 id=インフラコードの抜本的リファクタリング>インフラコードの抜本的リファクタリング</h2>
<p>約2週間かけて、新規インフラ環境の構築、既存インフラの cdk/cf と同期されていなかったインフラ (rds, security group, croudfront, api gateway, waf) の同期など、インフラコードの大きな変更をやり終えた。一部 <code>fromLookup</code> でインポートしているリソースもあるが、いま完全に cdk/cf 管理なインフラとなった。ここからはせっかく cdk でコードを書いているので、モジュール化や共通化など、再利用可能なリソースとして定義して、複数の Stack でコードを再利用するといったリファクタリングをしていく。ひとまずこのことをボーナスステージと呼ぼう。いま完全に同期されたインフラがあるため、インフラ上のリソースの差分が出なければリファクタリングは正しいことが保証される。cdk は <a href=https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib-readme.html#dependencies>Stack 間の依存関係</a> も定義できるため、適切な依存関係を定義することでより堅牢なインフラコードとなるはずである。具体的には次のような依存関係になる。然るべき堅牢なインフラコードに書き換えていく。</p>
<ul>
<li>DatabaseStack
<ul>
<li>BackendStack
<ul>
<li>GatewayStack
<ul>
<li>FrontendStack</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div class="post on-list">
<h1 class=post-title>
<a href=/diary/posts/2022/0419/>api gateway のデプロイ検証</a>
</h1>
<div class=post-meta>
<span class=post-date>
2022-04-19
</span>
</div>
<span class=post-tags>
#<a href=/diary/tags/cdk/>cdk</a>&nbsp;
#<a href=/diary/tags/infrastructure/>infrastructure</a>&nbsp;
</span>
<div class=post-content>
<p>0時に寝て6時に起きた。</p>
<h2 id=api-gateway-のデプロイ検証>api gateway のデプロイ検証</h2>
<p>昨日の続き。api gateway を再作成すると、当然、既存のテスト環境は疎通できなくなってしまう。他の開発者を妨害しないようにまた21時から深夜にかけて作業しようと考えていたら、いまは閑散期でテスト環境を使わないといけないような開発の状況にはないと他の開発者から教えてもらった。PO の人たちも検証は一段落しているとのこと。午後からテスト環境壊してもよいという確認が取れたので13時からインフラ作業をしていた。早ければ1時間ぐらい、遅ければ4時間と見積もって、実際にデプロイしてみると、あれやこれやの抜け・漏れ、手動で設定されていたリソースの弊害などもあって、3時間ぐらいかかった。もう2週間ほどインフラの作業ばかりやっているせいか、何が起こっても4時間ぐらいあれば調査とリストアを完了できるぐらいの自信がついてきた。最終的に cdk で再作成した api gateway を使って cloudfront の distribution 経由で web api 呼び出しが繋がった。当たり前の話なんだけど、繋がる瞬間、ローカルで web api のエンドポイントを叩いてレスポンスが返ってくるときが嬉しい。最後の大物だったインフラもたった2日でやっつけることができた。これからはボーナスステージ。</p>
</div>
</div>
<div class="post on-list">
<h1 class=post-title>
<a href=/diary/posts/2022/0418/>api gateway のコード化</a>
</h1>
<div class=post-meta>
<span class=post-date>
2022-04-18
</span>
</div>
<span class=post-tags>
#<a href=/diary/tags/cdk/>cdk</a>&nbsp;
#<a href=/diary/tags/infrastructure/>infrastructure</a>&nbsp;
</span>
<div class=post-content>
<p>1時に寝て7時に起きた。</p>
<h2 id=api-gateway-のコード化>api gateway のコード化</h2>
<p>いま cdk で管理していない大きなインフラとして <a href=https://aws.amazon.com/jp/api-gateway/>api gateway</a> がある。さらに restful api ではなく http api という新しい仕組みを使っているため、cdk 側も experimental な機能として提供されている。experimental と言っても本番環境で使われいるので十分に production ready と言える。弊害としては cdk のサンプルコードが少なく、公式の api reference に付いているサンプルコードぐらいしか参考になるものがなく、適当にコードを書いてでデプロイし、管理画面で意図した設定になっているかを確認するといったトライ&エラーみたいなやり方しかない。今日の時点では pr まで作ってデプロイと検証は翌日にまわることにした。</p>
<p>さらに cdk の v2 系では <code>-alpha</code> というパッケージが experimental 向けの機能を提供している。バージョン番号ではなく、パッケージ名に alpha が付くという分かりにくさに拍車をかけている。お手伝い先で使っている設定は次の3つのパッケージを使うことで実現できた。api gateway, vpc link, integration, route, authorization, stage など、複数のリソースを連携して設定しないといけないのでちょっとややこしい。</p>
<ul>
<li><a href=https://www.npmjs.com/package/@aws-cdk/aws-apigatewayv2-alpha>https://www.npmjs.com/package/@aws-cdk/aws-apigatewayv2-alpha</a></li>
<li><a href=https://www.npmjs.com/package/@aws-cdk/aws-apigatewayv2-authorizers-alpha>https://www.npmjs.com/package/@aws-cdk/aws-apigatewayv2-authorizers-alpha</a></li>
<li><a href=https://www.npmjs.com/package/@aws-cdk/aws-apigatewayv2-integrations-alpha>https://www.npmjs.com/package/@aws-cdk/aws-apigatewayv2-integrations-alpha</a></li>
</ul>
</div>
</div>
<div class="post on-list">
<h1 class=post-title>
<a href=/diary/posts/2022/0414/>コロナワクチン3回目</a>
</h1>
<div class=post-meta>
<span class=post-date>
2022-04-14
</span>
</div>
<span class=post-tags>
#<a href=/diary/tags/life/>life</a>&nbsp;
#<a href=/diary/tags/infrastructure/>infrastructure</a>&nbsp;
</span>
<div class=post-content>
<p>22時に寝て3時に起きた6時に起きた。季節の変わり目のせいか、いつも眠い。</p>
<h2 id=ワクチン3回目接種>ワクチン3回目接種</h2>
<p><a href=/diary/posts/2021/0927/#コロナワクチン2回目摂取>2回目は昨年の9月27日</a> に接種した。6ヶ月以上経たないといけないので3月27日以降に接種資格を得て、実際に接種券が届いたのが4月7日だった。神戸市は初回のときにまごまごしたので他の自治体よりも遅れている。これまでファイザーを2回接種したので今回はモデルナを受けてみることにした。モデルナを扱っていてネット予約できるもっとも近くの診療所を予約した。オフィスから自転車で15分ぐらいのところ。16:30の予約なのに16時過ぎぐらいに行ったら普通に受け付けしてくれてすぐに接種もできた。16:05に接種終えて16:20まで待機してオフィスに戻ってきて普通にお仕事してた。その1時間半後に熱を測ったら37.0℃だった。その後もやや熱っぽいけど、平気とは言えば平気。</p>
<h2 id=インフラ移行作業>インフラ移行作業</h2>
<p>昨日の続き。フロントエンドのテスト環境が壊れる可能性があるため、他メンバーが使っていない夜に移行作業を行う。POの人たちがQA検証を19-21時ぐらいにやっていることが多いので21時以降に作業すると連絡しておいた。なかなか大変だった。最悪の場合、数時間テスト環境を使えませんと伝えていたものの、その通りで4時間ぐらい検証作業をしていた。cloudfront の distribution 設定を CloudFrontWebDistribution から Distribution へ移行して、新しいやり方であるマネージドポリシーを使うようにした。この設定が意図した振る舞いにならなくて検証作業に時間を割いた。</p>
<p>cloudfront 経由で web api を呼び出すルートがあってキャッシュを無効にしたいのだが、無効にしたキャッシュポリシー (ttl をゼロにする) を作るとヘッダーの設定ができない。次のようなエラーになる。</p>
<pre tabindex=0><code>The parameter HeaderBehavior is invalid for policy with caching disabled.
</code></pre><p><a href=https://github.com/aws/aws-cdk/issues/13441>(cloudfront): Cache Policy cannot forward Authorization header. #13441</a> によると、maxTTL を1秒にして <code>Authorization</code> ヘッダーをオリジンに転送するようには設定できる。キャッシュメソッドは GET と HEAD なので実運用上は問題ないとは思うが、この回避策がないかどうかを調べて検証していた。結果としてはなかった。<a href=https://docs.amazonaws.cn/en_us/AmazonCloudFront/latest/DeveloperGuide/add-origin-custom-headers.html#add-origin-custom-headers-forward-authorization>Configuring CloudFront to forward the Authorization header</a> には <code>Authorization</code> ヘッダーを転送する方法は次の2通りとある。</p>
<ol>
<li>cache key に含める</li>
<li>Managed-AllViewer という origin request policy をすべての viewer requests に含める</li>
</ol>
<p>最終的には1番目のやり方で対応はしたが、2番目のオリジンリクエストポリシーを設定する方法も検証してみた。オリジンリクエストポリシーを単体で設定することはできなくて、キャッシュポリシーも一緒に設定しないといけないことからキャッシュポリシーの設定の影響を受けて意図したように <code>Authorization</code> ヘッダーの転送はできなかった。</p>
<ul>
<li>cache policy: Managed-CachingDisabled</li>
<li>origin request policy: Managed-AllViewer</li>
</ul>
</div>
</div>
<div class="post on-list">
<h1 class=post-title>
<a href=/diary/posts/2022/0413/>cdk の cloudfront の distribution 設定の移行</a>
</h1>
<div class=post-meta>
<span class=post-date>
2022-04-13
</span>
</div>
<span class=post-tags>
#<a href=/diary/tags/cdk/>cdk</a>&nbsp;
#<a href=/diary/tags/infrastructure/>infrastructure</a>&nbsp;
</span>
<div class=post-content>
<p>0時に寝て5時過ぎに起きた。</p>
<h2 id=フロントエンドのインフラ作業の続き>フロントエンドのインフラ作業の続き</h2>
<p>昨日、cloudfront の distribution 設定のビヘイビアのキャッシュ設定が誤っていることに気付いたので cdk のコードを修正していく。<a href=https://aws.amazon.com/jp/blogs/news/amazon-cloudfront-announces-cache-and-origin-request-policies/>Amazon CloudFront キャッシュポリシーとオリジンリクエストポリシーを発表</a> によると、2020年ぐらいに distribution ごとに個別設定していたのをマネージドポリシーというリソースを参照することで一元管理できるようになったらしい。cdk のコードで言えば、次の issue で対応されているが、これらの機能は <a href=https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_cloudfront.Distribution.html>aws_cloudfront.Distribution</a> のみに追加されている。従来の CloudFrontWebDistribution では使えないので distribution 設定そのものを新しいやり方に移行する必要がある。</p>
<ul>
<li><a href=https://github.com/aws/aws-cdk/issues/9644>https://github.com/aws/aws-cdk/issues/9644</a></li>
<li><a href=https://github.com/aws/aws-cdk/issues/9647>https://github.com/aws/aws-cdk/issues/9647</a></li>
</ul>
<p>基本的には同じ設定を行うので新しいクラスのメンバーや構造にあわせて移行するだけなので難しくはないけれど、1つずつ設定内容の移行方法を確認していかないといけないから手間暇はかかる。cdk のドキュメントをみると、型に対してどういった設定をすればよいかが書いてあって、あとはメソッドの定義などもみながら自分たちの設定に近いものを選択していくといった作業になる。難しくはないけど時間はかかる。半日ほどやって移行のための pr を作成した。</p>
</div>
</div>
<div class="post on-list">
<h1 class=post-title>
<a href=/diary/posts/2022/0412/>cloudfront のキャッシュ設定</a>
</h1>
<div class=post-meta>
<span class=post-date>
2022-04-12
</span>
</div>
<span class=post-tags>
#<a href=/diary/tags/infrastructure/>infrastructure</a>&nbsp;
</span>
<div class=post-content>
<p>1時に寝て5時に起きた。</p>
<h2 id=フロントエンドのインフラ作業>フロントエンドのインフラ作業</h2>
<p>これまでバックエンドのインフラ作業をしてきたが、そちらの移行作業は完了した。フロントエンドのインフラも積み残しが多々あるのでこの機にリファクタリングする。差分が出ないことを確認して cf のテンプレートのドリフト結果を解消したものをデプロイしたらフロントエンドが壊れた。具体的には xhr の web api 呼び出しに対して認可エラーが返るようになった。数時間ほどの調査の結果、cloudfront の distribution 設定のビヘイビアのキャッシュ設定で web api 呼び出しのときに authorization ヘッダーを転送するための設定が漏れていることがわかった。cdk のコードにはそんな設定がどこにもなく差分も表示されないことから、フロントエンドの cdk コードも全く保守されていないことがわかった。デプロイするときに前回のデプロイが半年前だったのでなんか悪い予感はしたんよね。インフラ担当者の怠慢が度を越し過ぎてもう何が起きても私は驚かないけど。設定に漏れがある前提でフロントエンドのインフラをリファクタリングしていかないといけない。</p>
</div>
</div>
<div class="post on-list">
<h1 class=post-title>
<a href=/diary/posts/2022/0411/>cdk/cf の Stack とライフサイクル</a>
</h1>
<div class=post-meta>
<span class=post-date>
2022-04-11
</span>
</div>
<span class=post-tags>
#<a href=/diary/tags/cdk/>cdk</a>&nbsp;
#<a href=/diary/tags/infrastructure/>infrastructure</a>&nbsp;
</span>
<div class=post-content>
<p>0時に寝て5時に起きた。</p>
<h2 id=インフラ変更の本番作業>インフラ変更の本番作業</h2>
<p>先週やっていた様々なインフラ構築の改善を本番環境に適用する。cf の changeset は23とかになっていた気がする。大きな括りで次の3つの移行作業をした。</p>
<ul>
<li>rds をスタックから切り離す</li>
<li>cdk の v1 から v2 へのアップグレード</li>
<li>ポリシーとセキュリティグループのドリフト解消</li>
</ul>
<p>私は本番環境へのアクセス権限をもっていないので社員さんの作業内容を伝えてやってもらう。cf のテンプレートの更新やドリフトの解消など、テスト環境で10時間以上は費やした検証結果が功を奏して、本番作業は想定外の事象も発生せず1.5時間で完了した。cdk のコードも意図した設定になるように修正済みだし、なにも問題は発生しない。cdk のコードを書くときは cf のイベントログやドリフト結果と実際のインフラの振る舞いを確認するといった検証には時間がかかるが、それができてしまえば本番環境の構築はうまくできる。それがわかっているインフラ担当者がいなくなると、また1から担当者が検証する必要があって保守は大変かもしれないけど。</p>
<p>同じ Stack でどういったリソースを管理するかというライフサイクルは難しい問題かもしれない。今回 rds を削除したのは、なんらかの理由で手動運用で rds を変更することがあって、アプリケーション Stack から外してしまった方が保守しやすいのではないかという意見が出たため。それが正しいかどうかはわからないが、一度作ったリソースを削除しないもの (vpc や s3 bucket など) をアプリケーション Stack で管理すると、再作成できなくて面倒くさいことがある。というのは、再作成は新規に作成 → 古いリソースを削除の順番で処理されるため、一意な名前をもつリソースは基本的に再作成できない。</p>
</div>
</div>
<div class="post on-list">
<h1 class=post-title>
<a href=/diary/posts/2022/0408/>壊れた cf スタックのリストアと cdk の再同期</a>
</h1>
<div class=post-meta>
<span class=post-date>
2022-04-08
</span>
</div>
<span class=post-tags>
#<a href=/diary/tags/cdk/>cdk</a>&nbsp;
#<a href=/diary/tags/infrastructure/>infrastructure</a>&nbsp;
</span>
<div class=post-content>
<p>2時に寝て6時半に起きた。インフラエンジニアになったのでみんなが作業していない時間にインフラの保守作業をするようにしている。昼はアプリケーションエンジニア、夜はインフラエンジニアみたいな生活になっていてしんどい。</p>
<h2 id=壊れた-cf-スタックの更新>壊れた cf スタックの更新</h2>
<p>テスト環境の cf スタックを手動で更新して壊れているのを cdk で管理できるように直した。壊れていたのは次の3つ。</p>
<ul>
<li>rds をスナップショットからリストアしたので cf が管理している rds リソースが存在しない</li>
<li>iam の acl 設定が異なる</li>
<li>セキュリティグループのインバウンドルールが異なる</li>
</ul>
<p>aws 的にもそういった状況は認識していて cdk で同期できなくなった cf スタックを更新する手順を提供している。</p>
<ul>
<li><a href=https://aws.amazon.com/jp/premiumsupport/knowledge-center/delete-cf-stack-retain-resources/>AWS CloudFormation スタックを削除したときにリソースの一部を保持する方法を教えてください。</a></li>
</ul>
<p>ざっくり手順をまとめると次になる。</p>
<ol>
<li>対象のリソースに DeletetionPolicy=Retain にセットする</li>
<li>テンプレートからリソースを削除して、スタックの更新を実行する</li>
<li>テンプレート内のリソースの実際の状態を describe して、スタック内に既存のリソースをインポートする</li>
</ol>
<p>リソースの設定ぐらいなら既存のリソースからインポートしなくても cf のテンプレートを直接書き換えたものをアップロードしてスタックを更新するのでも大丈夫だったりする。しかし、cdk もそのテンプレートにあうように修正しないといけないため、cdk のコードとテンプレートのコードの両方をチェックしながら検証する必要がある。cdk でリソース管理ができるようになったからといって、それが変更前の既存のリソースの設定と同じかどうかは人間が目でみて検証しないといけない。これがあちこちで参照されているリソースだと追跡するのが面倒くさいといった手間暇がかかる。</p>
<p>cdk がよいものかどうか、私はまだ判断がつかないけど、cf を抽象化して便利になっているところは認めるものの、cf のスタックが壊れたときのトラブルシューティングが必要以上に複雑で厄介というのも事実ではある。一方で壊れた cf スタックを5時間ぐらいかけて直したのではまりポイントはいくつかも学ぶことができた。しんどかったけど。例えば、あるセキュリティグループのインバウンドルールに別のセキュリティグループを関連付けるとき、1つの設定ではうまくいかなくて次の2つの設定を追加した。これが適切かどうかわからないが、この設定で cdk でデプロイしたスタックの環境と既存リソースとの環境が整合した状態 (ドリフトが解消される) になった。こういうのが cdk の抽象化による訳のわからないところの1つ。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=color:#a6e22e>otherSecurityGroup</span>.<span style=color:#a6e22e>addIngressRule</span>(
  <span style=color:#a6e22e>ec2</span>.<span style=color:#a6e22e>SecurityGroup</span>.<span style=color:#a6e22e>fromSecurityGroupId</span>(<span style=color:#66d9ef>this</span>, <span style=color:#e6db74>&#39;my security group&#39;</span>, <span style=color:#a6e22e>mySgId</span>),
  <span style=color:#a6e22e>ec2</span>.<span style=color:#a6e22e>Port</span>.<span style=color:#a6e22e>tcp</span>(<span style=color:#ae81ff>80</span>),
  <span style=color:#e6db74>&#34;my inboud rule&#34;</span>,
)
<span style=color:#a6e22e>otherSecurityGroup</span>.<span style=color:#a6e22e>addIngressRule</span>(
  <span style=color:#a6e22e>ec2</span>.<span style=color:#a6e22e>Peer</span>.<span style=color:#a6e22e>securityGroupId</span>(<span style=color:#a6e22e>mySgId</span>),
  <span style=color:#a6e22e>ec2</span>.<span style=color:#a6e22e>Port</span>.<span style=color:#a6e22e>tcp</span>(<span style=color:#ae81ff>80</span>),
  <span style=color:#e6db74>&#34;my inboud rule&#34;</span>,
)
</code></pre></div>
</div>
</div>
<div class="post on-list">
<h1 class=post-title>
<a href=/diary/posts/2022/0407/>cdk のメジャーバージョンのマイグレーション</a>
</h1>
<div class=post-meta>
<span class=post-date>
2022-04-07
</span>
</div>
<span class=post-tags>
#<a href=/diary/tags/cdk/>cdk</a>&nbsp;
#<a href=/diary/tags/infrastructure/>infrastructure</a>&nbsp;
</span>
<div class=post-content>
<p>0時に寝て5時に起きた。開発者にインフラ変更の影響を出さないように6時半からインフラのお仕事してた。</p>
<h2 id=cdk-v1-と-v2-の違い>cdk v1 と v2 の違い</h2>
<p><a href=https://docs.aws.amazon.com/cdk/api/versions.html>AWS CDK Versions</a> には v1 と v2 の2つがある。新規で作るものは v2 を選択すればよいけど、既存のスタックが v1 だとマイグレーションが必要になる。cdk は bootstrap したときに CDKToolkit というスタックを生成する。cdk をアップグレードするというのはこのスタックの設定も更新する必要がある。デフォルト設定をそのまま使っていればマイグレーションはそんなに難しくはないはずだけど、設定をカスタマイズしていたりするといくつかパラメーターを調整したりしなかったりしてややこしいかもしれない。</p>
<ul>
<li><a href=https://docs.aws.amazon.com/cdk/v2/guide/migrating-v2.html>Migrating to AWS CDK v2</a></li>
<li><a href=https://docs.aws.amazon.com/cdk/v2/guide/bootstrapping.html>Bootstrapping</a></li>
</ul>
<p>また v2 は v1 の experimental な機能は移行されていないため、v1 のライブラリを直接使うか、自前でその機能を実装するといったことも必要になる可能性がある。</p>
<blockquote class=twitter-tweet><p lang=ja dir=ltr>cdk v2 を使っていて v1 にある機能が v2 になくてあれー？って感じで調べてたら experimental な機能はまだ移行されてないらしい。<a href=https://t.co/SbRZ5ddrTj>https://t.co/SbRZ5ddrTj</a></p>&mdash; Tetsuya Morimoto (@t2y) <a href="https://twitter.com/t2y/status/1511924087450640386?ref_src=twsrc%5Etfw">April 7, 2022</a></blockquote>
<script async src=https://platform.twitter.com/widgets.js></script>
<p>例えば、v1 の apigwv2.VpcLink というメソッドは experimental で v2 に移行されていないため、v2 に移行されている stable な CfnVpcLink という機能を使って次のように実装した。これは v1 の cdk の実装をみて同じように実装しただけ。</p>
<ul>
<li><a href=https://github.com/aws/aws-cdk/pull/10531/files#diff-1cf3aaf7b2b6b2e72123b93cb3108eb9e9a3291e588d62eb2cd34dd0509d3045>https://github.com/aws/aws-cdk/pull/10531/files#diff-1cf3aaf7b2b6b2e72123b93cb3108eb9e9a3291e588d62eb2cd34dd0509d3045</a></li>
</ul>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=color:#f92672>-    const apiGwVpcLink = new apigwv2.VpcLink(this, &#39;ApiGwVpcLink&#39;, {
</span><span style=color:#f92672>-      vpc: vpc,
</span><span style=color:#f92672>-      vpcLinkName: &#39;my-vpc-link&#39;,
</span><span style=color:#f92672>-      securityGroups: [mySecurityGroup]
</span><span style=color:#f92672></span><span style=color:#a6e22e>+    const apiGwVpcLink = new  apigwv2.CfnVpcLink(this, &#39;ApiGwVpcLink&#39;, {
</span><span style=color:#a6e22e>+     name: &#39;my-vpc-link&#39;,
</span><span style=color:#a6e22e>+     subnetIds: vpc.privateSubnets.map(sb =&gt; sb.subnetId),
</span><span style=color:#a6e22e>+     securityGroupIds: [mySecurityGroup.securityGroupId]
</span></code></pre></div>
</div>
</div>
<div class="post on-list">
<h1 class=post-title>
<a href=/diary/posts/2022/0406/>ecs の draining とタスクの停止時間</a>
</h1>
<div class=post-meta>
<span class=post-date>
2022-04-06
</span>
</div>
<span class=post-tags>
#<a href=/diary/tags/infrastructure/>infrastructure</a>&nbsp;
</span>
<div class=post-content>
<p>0時に寝て4時に起きた。なんか起きてから sns のタイムラインを眺めてた。6時半にはオフィスについて cdk のコードを読み始めた。</p>
<h2 id=ecs-の-draining-に時間がかかる>ecs の draining に時間がかかる？</h2>
<p>cdk でインフラのデプロイをしていて、ecs のタスクの置き換えにやたら時間がかかっているのに気付いた。調べてみると、aws のドキュメントがすぐにヒットした。デフォルトでは停止するまでに5分ぐらいかかってしまうようだけど、それを調整したかったらいくつかパラメーターがある。</p>
<ul>
<li><a href=https://aws.amazon.com/jp/premiumsupport/knowledge-center/ecs-tasks-stop-delayed-draining/>コンテナインスタンスが DRAINING に設定されているときに、Amazon ECS タスクが停止するのに時間がかかるトラブルシューティング方法を教えてください。</a></li>
</ul>
<h4 id=ecs-サービスの-deployment-configuration>ecs サービスの deployment configuration</h4>
<ul>
<li>minimumHealthyPercent: 同時に停止できるタスクの割合設定</li>
<li>maximumPercent: draining されるタスクが停止するまで置き換えるタスクを開始するかどうかの設定？</li>
</ul>
<h4 id=ロードバランサーの-deregistration-delay>ロードバランサーの deregistration delay</h4>
<ul>
<li>deregistrationDelay: elb(nlb) が登録解除処理が完了するまでに待つ時間。タスクが draining の状態になってこの時間が過ぎた後に登録解除して target が未使用になる</li>
</ul>
<h4 id=ecs-タスク定義の-stop-timeout>ecs タスク定義の stop timeout</h4>
<ul>
<li>stopTimeout: コンテナーが正常終了しないときに ecs が強制的にプロセスを kill するまでの待ち時間</li>
</ul>
<p>それぞれのインフラの状況にあわせて適切なパラメーターを変更すればよい。私が管理しているのは次の2つを変更した。</p>
<ul>
<li>maximumPercent: 100 -> 200 (%)</li>
<li>deregistrationDelay: 300 -> 30 (秒)</li>
</ul>
<p>これで18分ほどかかっていたデプロイ時間を8分ぐらいまで短縮できた。テスト環境の設定なので多少のエラーが発生したとしても速い方がよい。</p>
</div>
</div>
<div class="post on-list">
<h1 class=post-title>
<a href=/diary/posts/2022/0405/>再びのインフラエンジニア</a>
</h1>
<div class=post-meta>
<span class=post-date>
2022-04-05
</span>
</div>
<span class=post-tags>
#<a href=/diary/tags/infrastructure/>infrastructure</a>&nbsp;
</span>
<div class=post-content>
<p>0時に寝て7時に起きた。</p>
<h2 id=インフラタスクに専念>インフラタスクに専念</h2>
<p>本当はインフラ担当者が別途いるのだけど、多忙過ぎて、インフラタスクが1ヶ月近く遅延していて、プロジェクト内で合意を得て私がすべて巻き取ることにした。内容の如何に依らず、その一切合切をすべて巻き取ると宣言した。過去に働いた会社でも他の担当者ができなかった業務を後からリカバリするのはよくやってたのでそれ自体は構わない。ただ他人のタスクを肩代わりしても評価されないことも多くて、もともと私のタスクではないから誰がやったかなんか忘れてしまうんよね。私もとくにアピールしないからそう認識されても構わないのだけど、そういう業務が増えてくるとその職場を辞めるきっかけにもなってた。</p>
<p>インフラ担当者や他の社員さんにヒアリングしながら現時点でも十数個のタスクがある。過去のインフラの負債も含めて2-3週間ぐらい、私が集中的にやればすべて片がつくのではないかと考えている。今日たまたまスクラムのリファインメントやってて、業務の人から他の機能開発が遅れているのに2-3週間もインフラ作業に専念するってどういうこと？インフラタスクってインフラ担当者にやってもらえないんですか？と質問を受けて、できるんならその方が望ましいけど、過去の実績からまったく進捗しないのでこちらでやるざるを得ない状況というのを説明した。業務の人からみたらインフラなんか何をやっているかわからないからそんなもんよね。これから2-3週間経って蓄積したインフラタスクをすべて解決した後で少し時間が経つとインフラ担当者が全部やったように外部からはみえてしまうというのを、過去に何度も経験した。</p>
</div>
</div>
<div class=pagination>
<div class=pagination__buttons>
<span class="button previous">
<a href=/diary/tags/infrastructure/page/2/>
<span class=button__icon>←</span>
<span class=button__text>最近の日記</span>
</a>
</span>
</div>
</div>
</div>
</div>
<footer class=footer>
<div class=footer__inner>
<div class="copyright copyright--user">
<span>© 2021 Tetsuya Morimoto</span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span>
</div>
</div>
</footer>
<script src=/diary/assets/main.js></script>
<script src=/diary/assets/prism.js></script>
</div>
</body>
</html>