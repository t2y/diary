<!doctype html><html lang=en><head><title>Infrastructure :: </title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=/diary/tags/infrastructure/><link rel=stylesheet href=/diary/styles.css><link rel=stylesheet href=/diary/style.css><link rel="shortcut icon" href=/diary/favicon.ico><meta name=twitter:card content="summary"><meta name=twitter:site content="t2y"><meta name=twitter:creator content><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:title" content="Infrastructure"><meta property="og:description" content><meta property="og:url" content="/diary/tags/infrastructure/"><meta property="og:site_name" content><meta property="og:image" content="/diary/favicon.ico"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><link href=/diary/tags/infrastructure/index.xml rel=alternate type=application/rss+xml title></head><body class=green><div class="container full headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/diary><div class=logo>forest nook</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/diary/about>自己紹介</a></li><li><a href=/diary/dates>月別一覧</a></li><li><a href=/diary/tags>タグ一覧</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/diary/about>自己紹介</a></li><li><a href=/diary/dates>月別一覧</a></li><li><a href=/diary/tags>タグ一覧</a></li></ul></nav></header><div class=content><h1>Posts for: #Infrastructure</h1><div class=posts><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2024/1121/>ipv6 による疎通検証</a></h1><div class=post-meta><time class=post-date>2024-11-21</time></div><span class=post-tags>#<a href=/diary/tags/network/>network</a>&nbsp;
#<a href=/diary/tags/infrastructure/>infrastructure</a>&nbsp;</span><div class=post-content><p>今日は神戸へ帰ってきてバテバテでしんどかったのでバドミントン練習はおやすみ。出張で体調を崩してしんどい。</p><h2 id=ipv6-とリバースプロキシと-xff-ヘッダーの扱い>ipv6 とリバースプロキシと xff ヘッダーの扱い</h2><p>要件の1つに ipv6 での通信ができることという項目がある。<a href=https://ja.wikipedia.org/wiki/OSI%E5%8F%82%E7%85%A7%E3%83%A2%E3%83%87%E3%83%AB>OSI参照モデル</a> の概念から言うと ipv6 は第3層であるネットワーク層の話しになる。実際に世の中で運用されている tcp/ip のプロトコルスタックにおいてもネットワーク層の話しであり、レイヤーが異なることからアプリケーション層では影響を受けないはずではある。アプリケーション層からみたら ipv4 であろうと ipv6 であろうと、ネットワーク周りのライブラリやフレームワークが対応していれば問題ないだろうと考えていた。それ自体の認識は誤っていない。</p><p>プロキシを経由するときに <a href=https://developer.mozilla.org/ja/docs/Web/HTTP/Headers/X-Forwarded-For>X-Forwarded-For</a> (以下 xff) ヘッダーをセットすると、そのプロキシへアクセスしてきたリクエスト元の ip アドレスを保持できる。api サーバーでは xff ヘッダーを参照すれば ipv4 または ipv6 でアクセスしてきたクライアントの ip アドレスがわかる。<a href=/diary/posts/2024/0901/#x-forwarded-for-ヘッダーの制御>フレームワークの echo における対応</a> も過去に行っていた。1つ対応漏れがあって xff ヘッダーはプロキシを経由するごとに途中の ip アドレスを追加していく。原則として信頼できるネットワークのアクセス元の ip アドレスを使う。例えば、次のような xff ヘッダーを考える。</p><pre tabindex=0><code>X-Forwarded-For: 203.0.113.3, 192.0.2.5, 198.51.100.7&#34;
</code></pre><p>このとき信頼できるネットワークが 198.51.100.0/24 である場合は xff ヘッダーによるクライアントの ip アドレスは 192.0.2.5 となる。信頼できるネットワークが 192.0.2.0/24 と 198.51.100.0/24 の2つである場合は 203.0.113.3 の ip アドレスを使う。基本的には信頼できるネットワークの左側にある ip アドレスを使うと考えればよい。一方で途中経路のネットワークを知っていて信頼できるネットワークであることを設定しないと、意図したクライアントの ip アドレスを取得することはできない。</p><p>さらにリバースプロキシでアクセス制限をしたいという要件がある。docker compose を使うと通常は NAT の構成となり、コンテナネットワークのリバースプロキシ (nginx) からホスト os のリクエスト元の ip アドレスを参照できない。コンテナネットワークのゲートウェイ (172.18.0.1) からアクセスを受けたようにみえる。この振る舞い自体も正しくはあるが、調査したところ、docker の <a href=https://docs.docker.com/engine/security/rootless/>rootless</a>　モードだとリクエスト元の ip アドレスを参照できないということがわかった。次の issue によると port forwarder と呼ばれるモジュールがあり、デフォルトものから <a href=https://github.com/rootless-containers/slirp4netns>slirp4netns</a> に変更すれば参照できると次の issue で紹介されていた。</p><pre tabindex=0><code>Environment=&#34;DOCKERD_ROOTLESS_ROOTLESSKIT_PORT_DRIVER=slirp4netns&#34;
</code></pre><ul><li><a href=https://github.com/moby/moby/issues/41789>Rootless mode overwrites public IP to Docker&rsquo;s IP #41789</a><ul><li><a href=https://rootlesscontaine.rs/getting-started/docker/#changing-the-port-forwarder>Changing the port forwarder</a></li></ul></li></ul><p>実際にやってみて ipv4 の ip アドレスを参照することはできたものの ipv6 は未対応らしい。</p><ul><li><a href=https://github.com/rootless-containers/slirp4netns/issues/253>Support IPv6 port forwarding (libslirp 4.5) #253</a></li></ul><p>他のやり方も調査してコンテナネットワーク内の nginx から ipv6 の ip アドレスを参照することができなかった。要件を満たせないことからリバースプロキシをコンテナネットワークから外出しして構築することに決めた。rootless モードでなければ ipv4/ipv6 の両方を取得できるという話しもお手伝い先の同僚から聞いた。こんなところではまるとは思わなかった。</p><p>ping や curl コマンドも ipv6 対応されていてオプションを付けなくてもよいけど、ipv6 であることを明示する上では <code>-6</code> とオプションを付けてもよいかもしれない。それにしても検証するときに ipv6 アドレスを手打ちするのは煩雑なのでいちいちアドレスをコピペすることになって面倒だなと感じた。</p><pre tabindex=0><code>$ ping -6 2001:DB8:0:0:8:800:200C:417A
$ curl -s -6 &#39;http://[2001:DB8:0:0:8:800:200C:417A]:8080/api&#39;
</code></pre></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2024/1107/>ミドルウェアのコンテナの振る舞い検証</a></h1><div class=post-meta><time class=post-date>2024-11-07</time></div><span class=post-tags>#<a href=/diary/tags/mongodb/>mongodb</a>&nbsp;
#<a href=/diary/tags/rabbitmq/>rabbitmq</a>&nbsp;
#<a href=/diary/tags/container/>container</a>&nbsp;
#<a href=/diary/tags/infrastructure/>infrastructure</a>&nbsp;</span><div class=post-content><p>今日もバドミントン練習はお休み。</p><h2 id=mongodb-の-healthcheck>mongodb の healthcheck</h2><p><a href=/diary/posts/2023/1214/#コンテナを使ったレプリカセットの初期設定>bitnami/mongodb というサードパーティのコンテナ</a> を使って mongodb サービスを設定している。docker compose でコンテナサービスの依存関係を記述できるが、特別な設定をしないとコンテナサービスの起動をトリガーに依存関係を制御する。実際はコンテナが起動して内部のサーバー／デーモンが正常に起動するまで少し時間がかかる。たとえば mongodb のコンテナであれば mongod デーモンに初期設定をして再起動したりといった処理を内部的に行っている。そんなときに <a href=https://docs.docker.com/reference/dockerfile/#healthcheck>healthcheck</a> を使うことで実際に mongod デーモンに接続できるかどうかでコンテナのサービス間の依存関係を制御できる。</p><p>これまで mongodb には healthcheck の設定をしていなかったので調査して次の設定を追加した。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#f92672>healthcheck</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>test</span>: <span style=color:#ae81ff>mongosh &#34;mongodb://localhost:37017/test?directConnection=false&amp;replicaSet=${MONGO_REPLICA_SET}&#34; --eval &#39;db.runCommand(&#34;ping&#34;).ok&#39; --quiet</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>interval</span>: <span style=color:#ae81ff>60s</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>timeout</span>: <span style=color:#ae81ff>5s</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>retries</span>: <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>start_period</span>: <span style=color:#ae81ff>30s</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>start_interval</span>: <span style=color:#ae81ff>3s</span>
</span></span></code></pre></div><p>mongosh で db に接続して ping を実行するだけなら認証は必要ない。mongosh でなにもパラメーターを指定せずに接続すると direct 接続になってしまう。replica set の設定が完了していることを検証するために replica set 接続にしている。また interval は起動中もずっと死活監視に test コマンドを実行している。それとは別に start_interval を指定することでサービス開始時と通常の運用時の test コマンドによる制御をわけて管理できる。</p><h2 id=rabbitmq-のアップグレード>rabbitmq のアップグレード</h2><p>19時過ぎに業務終了報告をして、帰ろうと思ったときにふと rabbitmq のバージョンを最近あまり確認していないことに気付いた。いま 3.12.14 を使っているが、<a href=https://www.rabbitmq.com/release-information>Release Information</a> をみるとコミュニティサポートは切れていて、現行バージョンは 4.0 になっていることに気付いた。試しに結合テストの rabbitmq のバージョンを 4.0.3 に上げてみたところ、問題なく動作している。テスト環境の移行は他のメンバーが使っていない夜にやった方がいいかと帰ることをやめて普通に移行作業をやり始めてしまった。メッセージキューは永続化したデータを基本的には保持しないため、メジャーバージョンアップで互換性がなかったとしても volume 配下のデータを削除して exchange/queue を移行すればよい。</p><p>rabbitmq の http api client として rabbit-hole というツールを使っている。それも v2 から v3 へアップグレードしていて <a href=https://github.com/michaelklishin/rabbit-hole/releases/tag/v3.1.0>Changes Between 2.16.0 and 3.1.0 (Oct 31, 2024)</a> に書いてあるが、機能的な変更も非互換の変更もいまのところはないが、4.0 にあわせて将来的に非互換な変更をやりやすいよう、メジャーバージョンを上げると書いてある。go.mod の依存関係も更新したりした。</p><p>19時過ぎに帰ろうと思ってから、なんやらかんやらしているうちに最終的には21時半まで作業していた。</p></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2024/1106/>sveltekit の base path 設定</a></h1><div class=post-meta><time class=post-date>2024-11-06</time></div><span class=post-tags>#<a href=/diary/tags/svelte/>svelte</a>&nbsp;
#<a href=/diary/tags/infrastructure/>infrastructure</a>&nbsp;</span><div class=post-content><p>昨日遅くまで作業していたせいか、体調があまりよくなくて19時でお仕事を終えて帰って休んでいた。21時過ぎにはベッドに入って寝てた。</p><h2 id=base-path-移行とビルド>base path 移行とビルド</h2><p><a href=/diary/posts/2024/1030/#nginx-のリバースプロキシ>リバースプロキシのルーティング検証</a> を終えて path based routing を採用することに決まった。そのため、nginx の設定にあわせて sveltekit の ui の base path を設定し直し、テスト環境にデプロイして検証していた。デプロイ先の制約によって base path が変わるというのはよくある状況なので sveltekit も <a href=https://svelte.dev/docs/kit/configuration#paths>Configuration paths</a> で <code>svelte.config.js</code> に base path が設定できるようになっている。当初は環境変数で切り替えできるように設定して修正したものの、実際にビルドしてコンテナでテスト環境へデプロイしてみると有効にならない。adapter-node を使ってビルドしたソースコードを調べてみると <code>svelte.config.js</code> に設定した値がリテラルで埋め込まれていることがわかった。node.js サーバーの起動時に環境変数などを参照して動的に設定することはできない。次の issue が登録されている。</p><ul><li><a href=https://github.com/sveltejs/kit/issues/7242>make adapter-node base path configurable via environment variable #7242</a></li></ul><p>ビルド時にパスを固定にしないと、他のスクリプトソースやアセットの管理で煩雑になるところがあるのだろうと推測する。本当は環境変数で起動時に動的に変更できると、お客さんの環境にあわせて base path の値を変えたりもできるが、現状ではこちらが決めた値を固定で使ってもらうしかないことがわかった。</p></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2024/1030/>nginx の設定調査</a></h1><div class=post-meta><time class=post-date>2024-10-30</time></div><span class=post-tags>#<a href=/diary/tags/infrastructure/>infrastructure</a>&nbsp;
#<a href=/diary/tags/linux/>linux</a>&nbsp;
#<a href=/diary/tags/container/>container</a>&nbsp;
#<a href=/diary/tags/security/>security</a>&nbsp;</span><div class=post-content><p>開発合宿の準備をしていて今日のバドミントン練習はお休み。</p><h2 id=nginx-のリバースプロキシ>nginx のリバースプロキシ</h2><p>compose に起動している2つのサービスを同じポート番号で共有したい。nginx を tls 終端にしていてリバースプロキシとして構築している。ルーティングするには2つの方法がある。次のような compose.yml を作ってローカルのファイルシステムをマウントして設定変更しながら検証する。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#f92672>services</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>proxy</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>container_name</span>: <span style=color:#ae81ff>proxy</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>docker.io/library/nginx:stable</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>8443</span>:<span style=color:#ae81ff>8443</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>network_mode</span>: <span style=color:#e6db74>&#34;host&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>restart</span>: <span style=color:#ae81ff>unless-stopped</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>volumes</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>./nginx:/etc/nginx</span>
</span></span></code></pre></div><h3 id=sub-domain-based-routing>sub-domain based routing</h3><p>クラウドでは普通のやり方がサブドメインのホスト名でルーティングを行う。設定もシンプルでファイルも管理しやすいように分割できてよいと思える。システム変更時の移行も名前を切り替えればよいので移行しやすい。</p><ul><li>nginx.conf</li></ul><pre tabindex=0><code>http {
    sendfile on;

    upstream web-api1 {
        server localhost:8801;
    }

    upstream web-api2 {
        server localhost:8802;
    }

    ssl_certificate /etc/nginx/ssl/sample.crt;
    ssl_certificate_key /etc/nginx/ssl/sample.key;

    include /etc/nginx/sites-enabled/*;
}
</code></pre><ul><li>nginx/sites-enabled/www.sub1.example.com</li></ul><pre tabindex=0><code>server {
    listen 8443 ssl;
    server_name sub1.example.com;
    location / {
        include     /etc/nginx/common_proxy.conf;
        proxy_pass  http://web-api1;
    }
}
</code></pre><h3 id=path-based-routing>path based routing</h3><p>サブドメインの方が私は好みではあるが、サブドメインをネームサーバーに登録したり、tls の証明書にも複数ホストの考慮が必要になってくる。パスでルーティングするなら1台のマシンのように仮想的にみせられるというメリットはある。</p><pre tabindex=0><code>http {
    sendfile on;

    upstream web-api1 {
        server localhost:8801;
    }

    upstream web-api2 {
        server localhost:8802;
    }

    ssl_certificate /etc/nginx/ssl/sample.crt;
    ssl_certificate_key /etc/nginx/ssl/sample.key;

    server {
        listen 8443 ssl;

        location /app1/ {
            include     /etc/nginx/common_proxy.conf;
            proxy_pass  http://web-api1;
        }

        location /app2/ {
            include     /etc/nginx/common_proxy.conf;
            proxy_pass  http://web-api2;
        }
    }
}
</code></pre><h2 id=コンテナの-capability>コンテナの capability</h2><p>docker compose を rootless mode で使っていて 443 ポートを使いたいと言われてどうしたらいいのだろう？といままで考えていないことに気付いた。調べたらすぐにやり方が書いてあった。</p><ul><li><a href=https://docs.docker.com/engine/security/rootless/#exposing-privileged-ports>Exposing privileged ports</a></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ sudo setcap cap_net_bind_service<span style=color:#f92672>=</span>ep <span style=color:#66d9ef>$(</span>which rootlesskit<span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span>$ systemctl --user restart docker
</span></span></code></pre></div><p>これだけで compose サービスの1つにポート設定できた。めちゃ簡単だった。いままで capability を設定したことがなかったのと、権限周りはややこしいという先入観もあって触る機会がなかった。いろいろ洗練されて抽象化されているのだと推測する。バックエンドの場合は任意のポート番号を使えばよいから capability の設定をして 1024 以下のポート番号を使わないといけない理由はあまりない気はするが、そういう設定もできるようにはみえる。そういう話題すら聞いたことがなかった。</p><ul><li><a href=https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-capabilities-for-a-container>Set capabilities for a Container</a></li></ul></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2024/1018/>exec とスクリプト</a></h1><div class=post-meta><time class=post-date>2024-10-18</time></div><span class=post-tags>#<a href=/diary/tags/badminton/>badminton</a>&nbsp;
#<a href=/diary/tags/cli/>cli</a>&nbsp;
#<a href=/diary/tags/infrastructure/>infrastructure</a>&nbsp;</span><div class=post-content><p>今日のバドミントン練習はエアシャトルでリフティングを60分した。連続最大回数は191回だった。もう少しで200回だったのに残念。木曜日は睡眠をたくさんとって疲れは少し取れたし、安定的に50回前後は続くようになりつつも、100回までに失敗してしまう。今日は100回を超えたのが2回だけだった。ラケットのスィートスポットでとらえたときにきれいに真上にあがる感覚が楽しい。うまくいくときは数回は続く。それが自然にできるときとそうじゃないときの違いを私は制御できてなくて言語化もできない。</p><p>エアシャトルとメイビスにおけるリフティングの違いを比べてみると、メイビスの方が打ち上げて落ちてくるときにあまり回転せずコルクが下を向く傾向が多いようにみえる。エアシャトルの方がコルクが重い分、縦方向に回転し始めるとその回転が止まらず、回転しているからラケット面でとらえるのが難しくなる。だからエアシャトルの方がメイビスよりもリフティングが難しいといえる。シャトルを高く打ち上げると、落下してくる距離が長くなりその回転が落ち着く傾向があるからリフティングしやすくなるのではないかと仮説を考えた。伸び悩みかもしれないし、地道に練習を継続するときかもしれない。</p><h2 id=exec-とエントリーポイントのスクリプト>exec とエントリーポイントのスクリプト</h2><p>コンテナを起動して stop すると SIGTERM が送られる。そのときに api サーバーでシグナルの処理をしているのに、気付いたらシグナル処理が行われずタイムアウトするようになっていた。デフォルトでは10秒でタイムアウトして強制終了となる。なぜシグナルを捕捉しなくなったかを調査したら、あるときサーバーの起動前に前処理が必要になってエントリーポイントをシェルスクリプトにしていた。そのときに exec しないと、シェルスクリプトのプロセスに対してシグナルが送られるため、api サーバーがシグナルを検知できなくなるという副作用があることに気付いた。これまでも <a href=https://ja.wikipedia.org/wiki/Exec>exec</a> を使うとプロセス ID は変更されないという知識を知っていたが、それがどういう状況で役に立つかを理解できていなかった。シグナルを用いた同期処理に exec が役に立つ状況があることを学んだ。修正は次の1行のみ。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#f92672>--- a/docker/entrypoint.sh
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+++ b/docker/entrypoint.sh
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span><span style=color:#75715e>@@ -2,4 +2,4 @@
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> ...
</span></span><span style=display:flex><span> ... (pre process)
</span></span><span style=display:flex><span> ...
</span></span><span style=display:flex><span><span style=color:#f92672>-./bin/api &#34;$@&#34;
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+exec ./bin/api &#34;$@&#34;
</span></span></span></code></pre></div><h2 id=go-test-からバイナリをビルドしてサーバーを起動する>go test からバイナリをビルドしてサーバーを起動する</h2><p>先日 <a href=/diary/posts/2024/1011/#go-の結合テスト向けカバレッジ計測の考察>結合テスト向けカバレッジ計測の調査</a> をした成果を使って実際に go test からカバレッジ計測のカスタマイズを施したバイナリをビルドしてサーバー起動するコードを書いてみた。やや手間取ったが、一通り動いてカバレッジを計測できた。例えば、単体テストのカバレッジを計測するための makefile のターゲットは次のようになる。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=display:flex><span>GO_COVER_DIR<span style=color:#f92672>:=</span><span style=color:#66d9ef>$(</span>CURDIR<span style=color:#66d9ef>)</span>/tests/coverage
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>coverage</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>	@mkdir -p <span style=color:#66d9ef>$(</span>GO_COVER_DIR<span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span>	go test -tags<span style=color:#f92672>=</span>integration -race -cover ./... -covermode atomic -args -test.gocoverdir<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>GO_COVER_DIR<span style=color:#66d9ef>)</span>
</span></span></code></pre></div><p>go は <a href=https://ja.wikipedia.org/wiki/Fork>fork</a> ができない。fork の代わりに exec を使う。<a href=https://stackoverflow.com/a/28371586>How do I fork a go process?</a> に go の goroutine のスケジューリングと fork は相性が悪くてうまく動かないということが背景だと説明されている。それはともかく exec を使ってもサーバープロセスを非同期に起動できたのでそのスニペットを書いておく。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>binaryPath</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>buildBinary</span>()
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>args</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>string</span>{
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;-verbose&#34;</span>,
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;-port&#34;</span>,
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>strconv</span>.<span style=color:#a6e22e>Itoa</span>(<span style=color:#a6e22e>ServerPort</span>),
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>r</span>, <span style=color:#a6e22e>w</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>Pipe</span>()
</span></span><span style=display:flex><span><span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bufio</span>.<span style=color:#a6e22e>NewScanner</span>(<span style=color:#a6e22e>r</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Scan</span>() {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Text</span>())
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>cmd</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>exec</span>.<span style=color:#a6e22e>Command</span>(<span style=color:#a6e22e>binaryPath</span>, <span style=color:#a6e22e>args</span><span style=color:#f92672>...</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>cmd</span>.<span style=color:#a6e22e>Stdout</span> = <span style=color:#a6e22e>w</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>cmd</span>.<span style=color:#a6e22e>Start</span>(); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>slog</span>.<span style=color:#a6e22e>Error</span>(<span style=color:#e6db74>&#34;failed to start api server&#34;</span>, <span style=color:#e6db74>&#34;err&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>cmd</span>.<span style=color:#a6e22e>Process</span>.<span style=color:#a6e22e>Signal</span>(<span style=color:#a6e22e>syscall</span>.<span style=color:#a6e22e>SIGTERM</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>slog</span>.<span style=color:#a6e22e>Error</span>(<span style=color:#e6db74>&#34;failed to terminate the api process&#34;</span>, <span style=color:#e6db74>&#34;err&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>cmd</span>.<span style=color:#a6e22e>Process</span>.<span style=color:#a6e22e>Wait</span>(); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>slog</span>.<span style=color:#a6e22e>Error</span>(<span style=color:#e6db74>&#34;failed to wait terminating the api process&#34;</span>, <span style=color:#e6db74>&#34;err&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Close</span>()
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>slog</span>.<span style=color:#a6e22e>Info</span>(<span style=color:#e6db74>&#34;completed to terminate the api process&#34;</span>, <span style=color:#e6db74>&#34;s&#34;</span>, <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>String</span>())
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// サーバーに対するテストを実行
</span></span></span></code></pre></div><p>サーバープロセスの標準出力のログを <a href=/diary/posts/2024/0919/>io.Pipe</a> を使って出力することもできる。exec で生成したプロセスに対してもシグナルを送ったり終了を待つこともできる。デバッグしている分にはこれで意図したように制御できた。この知見は将来的に役に立つ気がする。0時過ぎから調査を再開して4時前ぐらいまでやっていた。少しはまって時間はかかったものの、久しぶりに集中してデバッグしていた。</p></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2024/0205/>寝台特急に初乗車</a></h1><div class=post-meta><time class=post-date>2024-02-05</time></div><span class=post-tags>#<a href=/diary/tags/infrastructure/>infrastructure</a>&nbsp;
#<a href=/diary/tags/testing/>testing</a>&nbsp;
#<a href=/diary/tags/biztrip/>biztrip</a>&nbsp;</span><div class=post-content><p>2時に寝て6時過ぎに起きた。本当はもっと早く寝た方がよいのに22時半から2時前まで作業してた。<a href=/diary/posts/2024/0204/>格闘家に学ぶ体脂肪コントロール</a> 本に睡眠をとることや疲労を溜めないことが代謝をよくすると書いてあって、その通りだとは思うのだけど、なぜかここ最近は2時ぐらいまで作業していることが多い。いろいろうまくいかない。</p><p>今日の運動は腕立て,スクワット,背筋をした。統計を <a href="https://docs.google.com/spreadsheets/d/1bg85QtM-LciUgey8I79uI7vW2PEwsP6TVdeIRVkACBg/edit?usp=sharing">運動の記録</a> にまとめる。</p><h2 id=テスト環境の再構築>テスト環境の再構築</h2><p><a href=/diary/posts/2024/0126/#テスト環境の見直し>テスト環境の見直し</a> の都築。先週末から <a href=https://cockpit-project.org/>cockpit</a> 上の仮想マシンに OS をインストールしたりしていた。今日はテスト対象のアプリケーションをインストールして設定をしたり、既存のテスト環境を移行したりしていた。</p><p>いまテスト環境は1つしかないが、機能が増えてきて、複数の運用要件を満たす必要があって、1つの環境ですべてを検証するには不便な状態になっていた。そこで1つに全部入りするから相反する要件が競合するのであって、いまわかっている要件を用途別に、1つを3つの環境に分割した。1つしかないものを複数にすると、その重複するところのコストもかかる。その辺りの調整もしていた。テスト環境の構築について、過去に私が作ったものではあるけど、1回作って終わりだと思っていたのか、構築の issue にはなにか書いてあるかもしれないが、wiki には残していなかった。今回3つに作り直すにあたってドキュメントがあれば思い出したり、トライアンドエラーを行うコストも省略できて、ちゃんとドキュメントを書かないとあかんなと反省した。新規に設置した仮想マシンに openldap サーバーを構築する以外の作業は完了したはず。</p><h2 id=サンライズ出雲の乗車と遅延>サンライズ出雲の乗車と遅延</h2><p><a href=/diary/posts/2024/0108/#サンライズ出雲の予約>1ヶ月前に予約した</a> 0時11分発の特急サンライズ出雲で東京へ向かう。</p><p>20時半にオフィスから家に帰ってきて、洗い物して、お風呂入って、ストレッチして、荷造りして、3時間もあれば余裕で出発できる。初めて寝台特急に乗る。間違いがないよう、改札で駅員に問い合わせる。すると、動物(シカ)と接触して列車が止まってしまっているという。再開予定ではあるが、駅員さんに話しかけた時点ではいつ再開するかはわかっておらず、その情報も乗客からオンラインでは調べられず、駅員さんしか状況を知る方法はないとのこと。動物とぶつかったぐらいで運休はないやろうという話しもあってそのままホームで待つことに。</p><p>ホームのアナウンスを聞いていると「運転しています。」と言い切るので再開したのかな？と期待するものの、35分遅れ→40分遅れ→45分遅れと遅延時間がどんどん増えていくので実際には停車していて点検中でも「運転している」とアナウンスするらしいということがわかった。最終的には80分遅れて三ノ宮に到着した。待合室で半分寝てたよ。そのまま目を覚さなくなるところでしたよ。</p><p>この時点で今日はゆっくり睡眠をとろうと思っていたのに大きな誤算だった。待ち疲れていたのもあったせいか、部屋に入って消灯してそのままわりとすぐに寝てしまった。列車に乗ったのが1時半、トイレに行って、駅員さんが切符確認に来て、2時頃には寝てしまったのではないかと思う。わりとよく眠れたと思う。列車の揺れと移動音は普通にはあるものの、私はこの手の環境には強いので、もちろん身体は疲労するかもしれないが、感覚的には気にせずそのまま寝ていたと思う。この状態で眠れるかどうかによって寝台特急の是非は変わってくるだろう。カプセルホテルよりは天井も高く、スペースも一回り広くて余裕がある。今回は下の真ん中ぐらいの部屋だったのだけど、場所によって揺れや移動音の聞こえ方も変わるという。通な人は部屋の位置もこだわるのかもしれない。</p><p>あと薄い毛布しかないため、冬はちょっと寒い。暖房入れて上着もかけてぎりぎりの暖かさかな。べつに眠れないほど寒いわけではないが、冬なんだからもう一枚布団を用意してくれてもいいのになという感覚はある。朝に起きて窓から線路は延々と眺められる。線路が好きな人にもよさそう。けっこうよかったのでまた来月も予約して寝台特急で出張へ行く。</p><p><figure><img src=/diary/img/2024/0205_train1.jpeg></figure><figure><img src=/diary/img/2024/0205_train2.jpeg></figure><figure><img src=/diary/img/2024/0205_train3.jpeg></figure></p></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2024/0116/>テスト環境を作り直す</a></h1><div class=post-meta><time class=post-date>2024-01-16</time></div><span class=post-tags>#<a href=/diary/tags/testing/>testing</a>&nbsp;
#<a href=/diary/tags/infrastructure/>infrastructure</a>&nbsp;
#<a href=/diary/tags/hugo/>hugo</a>&nbsp;</span><div class=post-content><p>21時頃から寝て何度か起きて7時半に起きた。昨日は頭が痛かったら早く帰って安静にしてた。安静にしたら直ったので大したことはなかったみたい。</p><p>今日の筋トレは腹筋:15x2,腕立て:10x1,スクワット15x2をした。</p><h2 id=テスト環境の見直し>テスト環境の見直し</h2><p>いまどきの開発の定番としては ci/cd でコミット単位にテスト環境にデプロイする仕組みを構築している。テスト環境は1つだけになるのだけど、プロダクトの開発を1年以上やってきて機能が増えたことによって、1つのテスト環境で相容れない複数の要件や機能を混在させることで管理や運用が煩雑になってきた。気付いたタイミングがよい時期だと思うのでこの機会に1つのテスト環境を3つのテスト環境に分散させようと思う。既存データを確認するだけなら1つでもよいが、id 連携という機能の特性上、複数のシステム間でデータ連携するため、システム間での依存関係が発生する。それを整理しないといけなくなったという次第。今日のところは現状把握や移行に必要な段取りなどを設計していた。</p><h2 id=hugo-のハンズオン資料作り>hugo のハンズオン資料作り</h2><p><a href=/diary/posts/2024/0115/>昨日の続き</a> 。23時過ぎに外に出たついでにオフィスに寄り道して書き始めたらまた熱中してしまって2時ぐらいまで書いていた。ハンズオンで説明する内容は一通り書いたつもり。せっかくの機会だから上級者向けにもう少し知っていることを書いてみようとは思う。</p></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2023/1214/>コンテナイメージの移行</a></h1><div class=post-meta><time class=post-date>2023-12-14</time></div><span class=post-tags>#<a href=/diary/tags/mongodb/>mongodb</a>&nbsp;
#<a href=/diary/tags/infrastructure/>infrastructure</a>&nbsp;
#<a href=/diary/tags/container/>container</a>&nbsp;
#<a href=/diary/tags/life/>life</a>&nbsp;</span><div class=post-content><p>1時に寝て3時に起きて6時半に起きた。スマホで呪術廻戦のゲームを開いたまま寝てた。</p><h2 id=サードパーティの-mongodb-コンテナへの移行>サードパーティの mongodb コンテナへの移行</h2><p>昨日の <a href=/diary/posts/2023/1211/>mongodb のサードパーティのコンテナイメージ調査</a> の続き。</p><h3 id=レプリカセットの削除>レプリカセットの削除</h3><p>基本的に一度作ったレプリカセットを削除することはないせいか、レプリカセットを削除するユーティリティは提供されていない。なんらかの理由でレプリカセットを再作成したいときは、レプリカセットの設定が保存されている local database を削除する。</p><p>またレプリカセットの稼働中に local database を削除することはできないため、mongod サーバーを <code>--replSet</code> を指定していない状態で起動させ、そのときに次のようにして local database を削除できる。</p><pre tabindex=0><code>test&gt; use admin
admin&gt; db.grantRolesToUser(&#34;root&#34;, [&#34;__system&#34;]);
{ ok: 1 }
admin&gt; use local
switched to db local
local&gt; db.dropDatabase()
{ ok: 1, dropped: &#39;local&#39; }
local&gt; use admin
switched to db admin
admin&gt; db.revokeRolesFromUser(&#34;root&#34;, [&#34;__system&#34;]);
{ ok: 1 }
</code></pre><h3 id=コンテナを使ったレプリカセットの初期設定>コンテナを使ったレプリカセットの初期設定</h3><p><a href=https://hub.docker.com/r/bitnami/mongodb>bitnami/mongodb</a> を使うと、ローカルのシングルノードでレプリカセットを使うには次のような設定になる。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>  <span style=color:#f92672>mongo</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>docker.io/bitnami/mongodb:7.0.1</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>user</span>: <span style=color:#ae81ff>root </span> <span style=color:#75715e># デフォルトは非 root ユーザーで起動するのでローカルの開発環境なら root で実行した方が手間がない</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>volumes</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>./volumes/mongodb:/bitnami/mongodb</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>environment</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>MONGODB_ROOT_USER</span>: <span style=color:#e6db74>&#34;${MONGO_USER}&#34;</span>  <span style=color:#75715e># 認証ユーザー</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>MONGODB_ROOT_PASSWORD</span>: <span style=color:#e6db74>&#34;${MONGO_PASSWORD}&#34;</span>  <span style=color:#75715e># 認証ユーザーのパスワード</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>MONGODB_ADVERTISED_HOSTNAME</span>: <span style=color:#e6db74>&#34;mongo-primary&#34;</span>  <span style=color:#75715e># レプリカセットのノードを ip アドレスではなくホスト名で指定する</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>MONGODB_REPLICA_SET_NAME</span>: <span style=color:#e6db74>&#34;myrs&#34;</span>  <span style=color:#75715e># レプリカセットの名前</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>MONGODB_REPLICA_SET_MODE</span>: <span style=color:#e6db74>&#34;primary&#34;</span>  <span style=color:#75715e># プライマリノードとして設定</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>MONGODB_REPLICA_SET_KEY</span>: <span style=color:#e6db74>&#34;my/replication/common/key123&#34;</span>  <span style=color:#75715e># キーファイルのコンテンツ (base64 でデコードできる値)</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>MONGODB_SYSTEM_LOG_VERBOSITY</span>: <span style=color:#ae81ff>0</span>  <span style=color:#75715e># ログレベル</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>hostname</span>: <span style=color:#ae81ff>mongo-primary </span> <span style=color:#75715e># コンテナの内外から解決できるホスト名を指定</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>container_name</span>: <span style=color:#ae81ff>mongo </span> <span style=color:#75715e># コンテナ名 (docker container ls で表示される名前)</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>27017</span>:<span style=color:#ae81ff>27017</span>  <span style=color:#75715e># レプリカセットを運用する場合はポート番号のマッピングを一致させる必要がある</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>restart</span>: <span style=color:#e6db74>&#34;always&#34;</span>
</span></span></code></pre></div><p>この設定でレプリカセットを初期した場合、レプリカセットの initialize 処理は、次のような config/member をもつ。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>members</span><span style=color:#f92672>:</span> [{ <span style=color:#a6e22e>_id</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>host</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;mongo-primary:27017&#34;</span>, <span style=color:#a6e22e>priority</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>5</span> }]
</span></span></code></pre></div><p>コンテナの内部からは mongo-primary というホスト名に対して、コンテナネットワーク内のローカル ip アドレスが解決される。</p><pre tabindex=0><code>c67a5ca94a77:/app# dig +short mongo-primary
192.168.240.3
</code></pre><p>ここで host os 上のアプリケーションから mongo コンテナに対してレプリカセット接続をする場合 <code>replicaSet=${レプリカセットの名前}</code> のパラメーターを追加する。</p><pre tabindex=0><code>mongodb://root:password@localhost:27017/?authMechanism=DEFAULT&amp;replicaSet=myrs
</code></pre><p>これは localhost:27017 にレプリカセットの接続を試行し、接続できるとレプリカセットのメンバーが返される。</p><p>レプリカセットのメンバーには <code>mongo-primary:27017</code> という設定が行われているため、mongo-primary というホスト名に対して host os 上で名前解決できる必要がある。そのために /etc/hosts に次の設定を行う。</p><pre tabindex=0><code>$ sudo vi /etc/hosts
...
127.0.0.1 	mongo-primary
</code></pre><p><a href=https://www.mongodb.com/products/tools/compass>compass</a> で接続した場合、レプリカセット接続であれば、レプリカセットの名前が接続情報として表示される。</p><h2 id=ダイニングテーブル引き取り>ダイニングテーブル引き取り</h2><p>実は火曜日にも長机を引き取りに行ってきて、今日はダイニングテーブルを引き取りに行ってきた。この3日間で2つもテーブルが手に入った。いつも目ぼしいと思ったものは、すぐに他の人と取り引きが成立してしまうのに、たまたま続けて私と取り引きが成立した。車で20分ぐらいの距離のマンションまで引き取りに行った。20時の予定を、19時10分には着いてしまって、先方も快く対応してくれた。私よりも見た目すこし年配の方で人当たりのよい感じの方だった。ジモティのやり取りはその人の性格が出るもので、受け渡しだけささっとやって余計な話しはしないパターンもあれば、愛想よく話しながら受け渡しをするパターンもある。先方によると、大事に使っていたテーブルのようにみえるので私も離れのオフィススペースで大事に使おうと思う。</p></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2023/1213/>mongodb のサードパーティのコンテナイメージ</a></h1><div class=post-meta><time class=post-date>2023-12-13</time></div><span class=post-tags>#<a href=/diary/tags/go/>go</a>&nbsp;
#<a href=/diary/tags/design/>design</a>&nbsp;
#<a href=/diary/tags/mongodb/>mongodb</a>&nbsp;
#<a href=/diary/tags/infrastructure/>infrastructure</a>&nbsp;
#<a href=/diary/tags/container/>container</a>&nbsp;</span><div class=post-content><p>23時に寝て3時に起きて寝たかどうか覚えていないうちに6時半になっていて7時半に起きた。</p><h2 id=json-を介した-go-の-bool-値のバリエーション>json を介した go の bool 値のバリエーション</h2><p><a href=https://github.com/go-playground/validator>go-playground/validator</a> のバリデータには <a href=https://pkg.go.dev/github.com/go-playground/validator/v10#hdr-Required>required</a> というバリデーションオプションがある。しかし、このオプションは go のゼロ値でないことをチェックするという仕様になっている。bool のゼロ値は false となるため、リクエストした JSON データに false を設定していたのか、未設定だったのかの違いを検出できない。これはバリデータの問題ではなく、go の json ライブラリの制約のようなもので使い勝手のよい仕様とは言えない。私もこの振る舞いに起因する不具合に遭遇したこともあるし、こういうときにどうしたらよいかも過去に3回ぐらいは調べている気がする。</p><ul><li><a href=https://github.com/go-playground/validator/issues/142>How to validate bool #142</a></li></ul><p>現時点での私の最適化は次のコードになる。データ構造として <code>*bool</code> 型にすれば、ポインタ型のゼロ値は nil となるため、true, false, nil の3値でバリデーションできる。しかし、私はこのデータ構造を好ましく思わない。というのは、内部的には true/false の2値でしか管理しないメンバーを、json のバリデーションのためだけに nil も許容する3値にすることがよい設計だと私は思えない。そこでバリデータによるバリデーションは諦めて、json の Unmarshal 処理をフックしてバリデーション相当の処理を自分で実装する。このやり方のデメリットはメンバーが追加されたときに自分で UnmarshalJSON() メソッドを保守する必要がある点になる。しかし、メリットとして内部のデータ構造の型は <code>bool</code> 型で扱える。一概にどちらがよいとは言いにくいかもしれないし、設計上の好みかもしれない。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>reqMyData</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Name</span>       <span style=color:#66d9ef>string</span> <span style=color:#e6db74>`json:&#34;name&#34;`</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>View</span>       <span style=color:#f92672>*</span><span style=color:#66d9ef>bool</span>  <span style=color:#e6db74>`json:&#34;view&#34;`</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>MyData</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Name</span>       <span style=color:#66d9ef>string</span> <span style=color:#e6db74>`json:&#34;name&#34;`</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>View</span>       <span style=color:#66d9ef>bool</span>   <span style=color:#e6db74>`json:&#34;view&#34;`</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>d</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>MyData</span>) <span style=color:#a6e22e>UnmarshalJSON</span>(<span style=color:#a6e22e>data</span> []<span style=color:#66d9ef>byte</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>tmp</span> <span style=color:#a6e22e>reqMyData</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>json</span>.<span style=color:#a6e22e>Unmarshal</span>(<span style=color:#a6e22e>data</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>tmp</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;failed to unmarshal as reqMyData&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>tmp</span>.<span style=color:#a6e22e>View</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;required view field&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>Name</span> = <span style=color:#a6e22e>tmp</span>.<span style=color:#a6e22e>Name</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>d</span>.<span style=color:#a6e22e>View</span> = <span style=color:#f92672>*</span><span style=color:#a6e22e>tmp</span>.<span style=color:#a6e22e>View</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=サードパーティの-mongodb-コンテナイメージ>サードパーティの mongodb コンテナイメージ</h2><p>先日の <a href=/diary/posts/2023/1211/>mongodb のレプリカセット調査</a> の続き。コードレビューをしていて <a href=https://hub.docker.com/r/bitnami/mongodb>bitnami/mongodb</a> というサードパーティのコンテナイメージを使った方がよいのではないか？というコメントがあったのでその調査をしてみた。VMware 社が提供しているサードパーティのコンテナイメージらしい。</p><blockquote><p>MongoDB(R) is run and maintained by MongoDB, which is a completely separate project from Bitnami.</p></blockquote><p>まず MongoDB プロジェクトとはまったく別管理であることが書いてある。</p><blockquote><p>Bitnami イメージを使用する理由</p><ul><li>Bitnamiはアップストリームソースの変更を綿密に追跡し、自動化されたシステムを使用してこのイメージの新しいバージョンを迅速に公開します。</li><li>Bitnami イメージでは、最新のバグ修正と機能をできるだけ早く利用できます。</li><li>Bitnamiのコンテナ、仮想マシン、クラウドイメージは、同じコンポーネントと構成アプローチを使用しているため、プロジェクトのニーズに応じて形式を簡単に切り替えることができます。</li><li>Bitnamiのイメージはすべて、minideb（最小限のDebianベースのコンテナイメージ）またはscratch（明示的に空のイメージ）をベースにしています。</li><li>Docker Hubで利用可能なすべてのBitnamiイメージは、Docker Content Trust（DCT）で署名されています。DOCKER_CONTENT_TRUST=1 を使用して、イメージの完全性を確認できます。</li><li>Bitnamiコンテナイメージは定期的にリリースされ、最新のディストリビューションパッケージが利用可能です。</li></ul><p>MongoDB®を本番環境で使用したいですか？Bitnami Application Catalogのエンタープライズ版であるVMware Tanzu Application Catalogをお試しください。</p></blockquote><p><a href=https://hub.docker.com/_/mongo>mongo</a> の公式イメージは ubuntu をベースイメージにしている。ubuntu よりは minideb の方が軽いのかな？そしてちゃんと upstream にも追随しているみたい。このベースイメージの違いによるものかは定かではないが、結合テストのイメージも移行してみたところ、10-20秒ほど結合テストの実行時間が速くなった。割合にすると10%程度かな。</p><blockquote><p>KubernetesにMongoDB®をデプロイするには？</p><p>Bitnami アプリケーションを Helm Chart としてデプロイすることは、Kubernetes 上で当社のアプリケーションを使い始める最も簡単な方法です。インストールの詳細については、Bitnami MongoDB® Chart GitHub リポジトリを参照してください。</p><p>Bitnami コンテナは、クラスタへの Helm Charts のデプロイと管理に Kubeapps と一緒に使用できます。</p></blockquote><p>helm chart も提供しているようで、いずれクラウド版を作るときに MongoDB も k8s 上にデプロイする上でこのことは都合がよいように思える。</p><p>レプリケーションを前提とした初期設定があり、entrypoint スクリプトもいくつか読んでみた感じだと、きれいに管理されていて保守もちゃんとやってくれそうにみえる。</p><ul><li><a href=https://github.com/bitnami/containers/tree/main/bitnami/mongodb>https://github.com/bitnami/containers/tree/main/bitnami/mongodb</a></li></ul><p>昨日、導入したばかりの公式イメージ + 自作スクリプトによるレプリケーション設定を廃止して、Bitnami のコンテナイメージを使うことに決めた。</p></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2023/1211/>owner/permission の違うファイルとリポジトリ管理</a></h1><div class=post-meta><time class=post-date>2023-12-11</time></div><span class=post-tags>#<a href=/diary/tags/mongodb/>mongodb</a>&nbsp;
#<a href=/diary/tags/infrastructure/>infrastructure</a>&nbsp;
#<a href=/diary/tags/container/>container</a>&nbsp;
#<a href=/diary/tags/event/>event</a>&nbsp;
#<a href=/diary/tags/blog/>blog</a>&nbsp;</span><div class=post-content><p>23時に寝て2時に起きて6時に起きて7時過ぎに起きた。なんか微妙な寝方をした。</p><p>先日の <a href=/diary/posts/2023/1207/>mongodb のレプリカセットの調査</a> の整理をしてマージリクエストを作成した。共通鍵の keyFile をどう扱えばいいのか、わからなくて、一旦コンテナ内の tmp 領域にコピーして、それを entrypoint スクリプトでコピーしてから owner/permission を変更するというやり方で、リポジトリ管理で共有しやすいようにしてみた。entrypoint スクリプトは root 権限で実行されることも理解した。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>volumes</span>:
</span></span><span style=display:flex><span>  - <span style=color:#ae81ff>./mongo/keyfile:/var/tmp/keyfile.orig</span>
</span></span><span style=display:flex><span><span style=color:#f92672>command</span>:
</span></span><span style=display:flex><span>  - <span style=color:#ae81ff>mongod</span>
</span></span><span style=display:flex><span>  - --<span style=color:#ae81ff>keyFile</span>
</span></span><span style=display:flex><span>  - <span style=color:#ae81ff>/data/keyfile</span>
</span></span><span style=display:flex><span>  - --<span style=color:#ae81ff>replSet</span>
</span></span><span style=display:flex><span>  - <span style=color:#e6db74>&#34;myrs&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>entrypoint</span>:
</span></span><span style=display:flex><span>  - <span style=color:#ae81ff>bash</span>
</span></span><span style=display:flex><span>  - -<span style=color:#ae81ff>c</span>
</span></span><span style=display:flex><span>  - |<span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    if [[ ! -f /data/keyfile ]]; then
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      cp /var/tmp/keyfile.orig /data/keyfile
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      chmod 400 /data/keyfile
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      chown mongodb:mongodb /data/keyfile
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    fi
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    exec docker-entrypoint.sh $$@</span>    
</span></span></code></pre></div><h2 id=テックブログを読む会>テックブログを読む会</h2><p>昨日、西原さんに教えてもらった <a href=/diary/posts/2023/1210/>テックブログを読むイベント</a> を探したら毎週月曜日に行われているようだった。早速 <a href=https://blogreading.connpass.com/event/304979/>テックブログ一気読み選手権20231211杯</a> に参加した。HackMD で読んだメモを管理している。記事を選択して、読んで、所感をまとめて、他の人たちと共有する。ただそれだけのイベント。ちょうど30分で終わって、自分の勉強にもなったし、他の人の話しも聞いて参考になった。たった30分でも、なにもやらないよりずっとよい。1ヶ月ほど参加してやり方を学んだらチームにも展開してみようかと考えている。</p></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2023/1207/>mongodb のレプリカセットのデプロイ調査</a></h1><div class=post-meta><time class=post-date>2023-12-07</time></div><span class=post-tags>#<a href=/diary/tags/mongodb/>mongodb</a>&nbsp;
#<a href=/diary/tags/infrastructure/>infrastructure</a>&nbsp;
#<a href=/diary/tags/container/>container</a>&nbsp;
#<a href=/diary/tags/go/>go</a>&nbsp;
#<a href=/diary/tags/testing/>testing</a>&nbsp;</span><div class=post-content><p>4時前に寝て6時半に起きた。1時過ぎまで作業して、帰って少しゲームして、うまく眠れなくてだらだらしていた。</p><h2 id=mongodb-のレプリカセットの調査>mongodb のレプリカセットの調査</h2><p>以前 <a href=/diary/posts/2023/1101/#mongo-とトランザクションとレプリカセット>mongodb でトランザクションを使うときにレプリカセットが必要</a> なことがわかった。他機能の開発途中だったので一旦後回しにしていたものを回収している。状況によってはメンバーに委譲してもよかったんだけど、私が遊撃で出張ってみることにした。実際に調べてみてコンテナの運用も考慮するとけっこう難しいことがわかってきた。</p><p><a href=https://www.mongodb.com/docs/mongodb-shell/>mongosh</a> からは <a href=https://www.mongodb.com/docs/v7.0/reference/method/js-replication/>Replication Methods</a> を使ってレプリカセットの操作ができる。これはユーティリティのようなもので mongodb としての低レベルのコマンド操作は <a href=https://www.mongodb.com/docs/manual/reference/command/nav-replication/>Replication Commands</a> になる。<a href=https://github.com/mongodb/mongo-go-driver>mongo-go-driver</a> はレプリカセット向けのユーティリティを提供していないため、Replication Commands を RunCommand() の低レベル API を使って自分で実装しないといけない。</p><p>例えば、レプリカセットの初期化をするときは次のように <code>replSetInitiate</code> というコマンドを適切なパラメーターで呼び出す。あまりドキュメントで丁寧に説明されていないので試行錯誤でエラーメッセージをみながら実装することになる。とくにはまるのが mongod のサーバーは <code>--replSet myrs</code> のようにレプリカセットを指定して起動させるものの、初期化コマンドを実行するときはまだレプリカセットを設定していないため、レプリカセットを指定せず、且つ <code>direct</code> パラメーターをセットしないと mongod サーバーに接続できない。この微妙な設定を把握するのにはまった。これが正しい手順かどうかもわからないが、ググったりしているとフォーラムでそういったコメントが散見されたりする。おそらく mongosh の Replication Methods を使うと、クライアントからサーバー接続は裏方でよしなにやってくれるのでそっちの方が簡単ではある。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>ReplicaSet</span>) <span style=color:#a6e22e>Initiate</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>config</span> <span style=color:#a6e22e>bson</span>.<span style=color:#a6e22e>M</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>client</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>connectDirect</span>(<span style=color:#a6e22e>ctx</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;failed to connect with direct: %w&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>client</span>.<span style=color:#a6e22e>Disconnect</span>(<span style=color:#a6e22e>ctx</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>result</span> <span style=color:#a6e22e>bson</span>.<span style=color:#a6e22e>M</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>cmd</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bson</span>.<span style=color:#a6e22e>D</span>{{<span style=color:#a6e22e>Key</span>: <span style=color:#e6db74>&#34;replSetInitiate&#34;</span>, <span style=color:#a6e22e>Value</span>: <span style=color:#a6e22e>config</span>}}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>client</span>.<span style=color:#a6e22e>Database</span>(<span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>db</span>).<span style=color:#a6e22e>RunCommand</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>cmd</span>).<span style=color:#a6e22e>Decode</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>result</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;failed to run replSetInitiate(): %w&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>PrettyPrint</span>(<span style=color:#e6db74>&#34;completed to initiate&#34;</span>, <span style=color:#a6e22e>result</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>ReplicaSet</span>) <span style=color:#a6e22e>connectDirect</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>mongo</span>.<span style=color:#a6e22e>Client</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>opts</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>options</span>.<span style=color:#a6e22e>Client</span>().
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>SetAuth</span>(<span style=color:#a6e22e>options</span>.<span style=color:#a6e22e>Credential</span>{
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>Username</span>: <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>User</span>,
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>Password</span>: <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>Passwd</span>.<span style=color:#a6e22e>String</span>(),
</span></span><span style=display:flex><span>		}).
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>SetHosts</span>(<span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>Hosts</span>).
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>SetDirect</span>(<span style=color:#66d9ef>true</span>) <span style=color:#75715e>// must be true
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>mongo</span>.<span style=color:#a6e22e>Connect</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>opts</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>InitSingleReplicaSet</span>(
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>cfg</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>MongoDB</span>,
</span></span><span style=display:flex><span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>rs</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>NewReplicaSet</span>(<span style=color:#a6e22e>cfg</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>initConfig</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bson</span>.<span style=color:#a6e22e>M</span>{
</span></span><span style=display:flex><span>		<span style=color:#e6db74>&#34;_id&#34;</span>: <span style=color:#a6e22e>cfg</span>.<span style=color:#a6e22e>ReplicaSet</span>,
</span></span><span style=display:flex><span>		<span style=color:#e6db74>&#34;members&#34;</span>: []<span style=color:#a6e22e>bson</span>.<span style=color:#a6e22e>M</span>{
</span></span><span style=display:flex><span>			{<span style=color:#e6db74>&#34;_id&#34;</span>: <span style=color:#ae81ff>0</span>, <span style=color:#e6db74>&#34;host&#34;</span>: <span style=color:#e6db74>&#34;localhost:27017&#34;</span>},
</span></span><span style=display:flex><span>		},
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>rs</span>.<span style=color:#a6e22e>Initiate</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>initConfig</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>さらに mongod サーバーを起動するときに <code>--replSet</code> と <code>--keyFile</code> (認証が必要な場合のみ？) という2つのパラメーターを指定する必要がある。<code>--replSet</code> はレプリカセットの識別子を指定する。そして <code>--keyFile</code> は共通鍵を指定する。この共通鍵を生成するには次のようにする。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ openssl rand -base64 <span style=color:#ae81ff>756</span> &gt; my-mongo-keyfile
</span></span><span style=display:flex><span>$ chown mongodb:mongodb my-mongo-keyfile
</span></span><span style=display:flex><span>$ chmod <span style=color:#ae81ff>400</span> my-mongo-keyfile
</span></span></code></pre></div><p>普通のサーバーインスタンスならすぐできることだが、コンテナの運用において面倒なのが owner とパーミッションを設定しないといけないところ。mongo のコンテナは mongodb ユーザーで起動するため、root でマウントされたファイルシステムには書き込みできなかったりして keyFile の配置をどう扱えばよいのかが難しい。docker hub の mongo の issues でもどうやって設定したらいいの？って議論が発散している。mongo 本体が公式のスクリプトや仕組みを提供していれば済む話しだけど、どうもそうではないみたい。だから泥臭い方法で自分でなんとかしないといけないようにみえる。</p><ul><li><a href=https://github.com/docker-library/mongo/issues/246>Creating a mongo image set with &ndash;replSet #246</a></li><li><a href=https://github.com/docker-library/mongo/issues/339>Cannot configure replica sets with entrypoint-initdb #339</a></li></ul><p>dockertest でもレプリカセットの設定について次の issue として登録されている。mongo のコンテナを使ったテストの場合、dockertest のレイヤーが挟まるのでさらにわかりにくくなっている。テストを動かすためにどういった設定が必要かは把握できたのでなにかよい方法を考えてコントリビュートしたい。</p><ul><li><a href=https://github.com/ory/dockertest/issues/480>Create an example for starting mongodb as a replica set #480</a></li></ul></div></article><div class=pagination><div class=pagination__buttons><a href=/diary/tags/infrastructure/page/2/ class="button next"><span class=button__text>過去の日記</span>
<span class=button__icon>→</span></a></div></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2024 Powered by <a href=https://gohugo.io>Hugo</a></span>
<span>:: <a href=https://github.com/panr/hugo-theme-terminal target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/diary/bundle.min.js></script></div></body></html>