<!doctype html><html lang=en><head><title>refactoring :: forest nook</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=/diary/tags/refactoring/><link rel=stylesheet href=/diary/styles.css><link rel=stylesheet href=/diary/style.css><link rel="shortcut icon" href=/diary/favicon.ico><meta name=twitter:card content="summary"><meta name=twitter:site content="t2y"><meta name=twitter:creator content><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:title" content="refactoring"><meta property="og:description" content><meta property="og:url" content="/diary/tags/refactoring/"><meta property="og:site_name" content="forest nook"><meta property="og:image" content="/diary/favicon.ico"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><link href=/diary/tags/refactoring/index.xml rel=alternate type=application/rss+xml title="forest nook"></head><body class=green><div class="container full headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/diary><div class=logo>forest nook</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/diary/about>自己紹介</a></li><li><a href=/diary/dates>月別一覧</a></li><li><a href=/diary/tags>タグ一覧</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/diary/about>自己紹介</a></li><li><a href=/diary/dates>月別一覧</a></li><li><a href=/diary/tags>タグ一覧</a></li></ul></nav></header><div class=content><div class=posts><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2023/0620/>go の channel 制御の学び</a></h1><div class=post-meta><time class=post-date>2023-06-20 (Tue.) ::</time></div><span class=post-tags>#<a href=/diary/tags/go/>go</a>&nbsp;
#<a href=/diary/tags/design/>design</a>&nbsp;
#<a href=/diary/tags/refactoring/>refactoring</a>&nbsp;
#<a href=/diary/tags/rabbitmq/>rabbitmq</a>&nbsp;</span><div class=post-content><p>0時に寝て2時に起きて5時に起きて6時に起きた。久しぶりに夢をみたような気がする。</p><h2 id=go-の-channel-とクローズ制御>go の channel とクローズ制御</h2><p><a href=https://github.com/rabbitmq/amqp091-go>rabbitmq/amqp091-go</a> を使った pubsub の consumer の実装で次のような for ループでメッセージを取得していた。この場合 <code>deliveries</code> の channel が閉じられると内側の for ループが終了して、外側の for ループの接続処理へ遷移する。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// コネクションの接続処理
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>d</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>deliveries</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// メッセージ処理
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>この処理を context を使ってキャンセルできるよう、次に書き換えた。channel の <a href=https://go.dev/ref/spec#Receive_operator>Receive operator</a> のドキュメントによると、channel は2値を返すことができて、戻り値の2番目の <code>ok</code> の値を調べることでその channel がクローズされているかどうかを判定できる。この仕組みを知っていれば select で ok を調べてエラー処理を実装できる。そうしないと <code>deliveries</code> の channel が閉じられれたときに select では常にゼロ値のメッセージが返るようになって意図したメッセージ処理とならない。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// コネクションの接続処理
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>select</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>Done</span>():
</span></span><span style=display:flex><span>            <span style=color:#75715e>// context がキャンセルされたら終了処理
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>ch</span>.<span style=color:#a6e22e>Cancel</span>(<span style=color:#a6e22e>cid</span>, <span style=color:#66d9ef>false</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;failed to cancel channel: %w&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>d</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>deliveries</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ok</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// メッセージ処理
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// エラー処理
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// コネクションが閉じていればループを抜けて再接続
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>conn</span>.<span style=color:#a6e22e>IsClosed</span>() <span style=color:#f92672>||</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>ch</span>.<span style=color:#a6e22e>IsClosed</span>() {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Info</span>(<span style=color:#e6db74>&#34;the session was closed, try to reconnect&#34;</span>, <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>同じ channel からメッセージを取り出すループ処理でも用途によって使い分けがあるなぁと今更ながら学んだ。というか、自分でバグを埋め込んで自分で直した (´・ω・｀)</p><h2 id=マージまで約1ヶ月>マージまで約1ヶ月</h2><p>先日送った <a href=/diary/posts/2023/0515/#amqp091-go-の-context-制御>amqp091-go の pr</a> が最終的にはほぼそのままマージされた。約1ヶ月ぐらいの議論やレビューがあって取り込まれた。新しいリリースバージョン (次は 1.9.0?) が出たらうちのアプリケーションでもこの新しいメソッドを使うようにして実績を積ませる。この pr は「あったら便利」程度の機能なのでそれほど重要ではない。</p><ul><li><a href=https://github.com/rabbitmq/amqp091-go/pull/192>Add Channel.ConsumeWithContext to be able to cancel delivering #192</a></li></ul><p>この成功体験をもって次は本命の <a href=/diary/posts/2023/0605/#レビュー対応>go-ldap の pr</a> のマージに向けて勢いをつける。こっちの pr は業務に直結しているので本気でやり取りしている。</p></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2023/0226/>コードを書いていると後から改善点に気づく</a></h1><div class=post-meta><time class=post-date>2023-02-26 (Sun.) ::</time></div><span class=post-tags>#<a href=/diary/tags/refactoring/>refactoring</a>&nbsp;
#<a href=/diary/tags/design/>design</a>&nbsp;</span><div class=post-content><p>1時に寝て7時に起きた。起きてからドラクエタクトをだらだらやってて10時前に起き上がってそれからオフィスへ行って活動してた。</p><h2 id=リファクタリングのリファクタリング>リファクタリングのリファクタリング</h2><p>昨日書いたマージリクエストの変更点についてドキュメントの更新だけしようと作業していたら、その後、一緒に修正した方がよい追加の機能拡張に気付いて3時間ほど追加の実装をしていた。その後、お昼ご飯を食べているときに午前中に書いた実装を改善した方がよいところに気付いて、さらに追加で1時間ほどリファクタリングしていた。コードを書いていて、一旦はできたつもりになってその時点ではよさそうに思うのだけど、時間が経ってから考え直すと考慮漏れやもっとよい実装のアイディアを思い付いたりする。私の頭が悪いだけかもしれないが、最初からよい実装や設計を行うことは多くの人にとって難しいことだと思いたい。何度も考えて作り直したり改善したりしているうちにもっとよい方法に気付く。</p><p>多くの開発者はもっとよいアイディアを思い付いたとしても実際にリファクタリングをしようとしない。動いているコードを修正して壊れるリスクや他に優先度の高い作業があるとか、いろいろやらない理由を言う人たちもいる。私はそのやらない理由を議論している合間にリファクタリングしてしまう。というのは、誇張した比喩で実際にはもっと時間がかかることもあるけど、設計も見直す数千行レベルの変更を気軽に行う。もしそれで壊れたらどうすると聞かれてもシンプルに謝るだけ。謝ってから直す、テストを書く、再発防止のための仕組みを考える。やることはそれだけ。問題のあるコードを見て見ぬ振りをする開発者の方が普通という感覚がある。10年以上開発をやってきて思うこととして、そういう価値観を上位の開発者が壊していって模範を示すことがよい開発文化への第一歩となる。しんどいことに対して口だけでは人は動かない。個々の開発者が問題だと思ったらどんどん書き直していく、リファクタリングしていくという文化は一朝一夕ではできない。そういう開発文化を醸成していくと大きな技術的負債が溜まるといったことはなくなるのではないかと考えている。</p></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2023/0225/>リファクタリング一段落</a></h1><div class=post-meta><time class=post-date>2023-02-25 (Sat.) ::</time></div><span class=post-tags>#<a href=/diary/tags/life/>life</a>&nbsp;
#<a href=/diary/tags/go/>go</a>&nbsp;
#<a href=/diary/tags/design/>design</a>&nbsp;
#<a href=/diary/tags/refactoring/>refactoring</a>&nbsp;</span><div class=post-content><p>1時に寝て7時に起きた。前日も21時頃までオフィスにいて、今日も午後からコードを書いていて22時ぐらいまでやってた。コードを書いていると時間がどんどんなくなる。本当は三宮.dev の勉強会があったんだけど、このリファクタリングは週末にやってしまわないとやばいという野生の勘でキャンセルした。</p><h2 id=ストレッチ>ストレッチ</h2><p>今日の開脚幅は開始前156cmで、ストレッチ後160cmだった。だいたいいつも通り。先週から右すねの外側の筋に張りがある。先週よりちょっとよくなった気もするけれど、まだ張りが継続している。あと今週は右腰に張りがあった。今週はリファクタリングしていて座ってきる時間がいつもより長かったためだろうと推測する。どんなに忙しくてもストレッチだけは休まないようにしている。ストレッチに通い始めて2年以上経つが身体的に体調が悪いということは記憶にほぼない。日記にはその週のどこそこに張りがあるとか調子が悪いといったことを書いたりしているが、それは日常生活を送る上で支障が出るようなレベルではない。そうならないように予防している。健康を維持する上でストレッチは大きな影響を与えているため、中長期の展望から忙しくても継続するようにしている。</p><h2 id=機能拡張とリファクタリング>機能拡張とリファクタリング</h2><p>今日は休日出勤して go のコードを書いていた。ある機能を作るときに内部的には汎用の api にしてしまって他のコレクションのデータ型でも再利用できるようにしたい。先週ずっと go の generics を使って mongodb 周りのコレクションとそのクライアントのリファクタリングをしていた。go の generics の理解も進んで crud なインターフェースを generics でどのように定義して実装すればいいかわかってきた。その過程で web api のアプリケーション層と mongodb のインフラ層 (データ層) の役割分担も明確になりつつある。どちらも generics を駆使して型チェックされた上でソースコードを共通化し、汎用 api としてリファクタリングしながら設計している。その集大成としてアプリケーション側で汎用的な機能を追加するときに、理想的には1つのコードを追加・変更すれば、別のデータ型でもすべて同じように動くといった機能として実装した。4つのコレクションのデータ型で同じ振る舞い (機能) を共通化する。その実装も丸1日やれば完了できるぐらいに設計の効率化ができてきた。</p><p>go はオブジェクト指向言語ではないので generics を駆使しても、java でいうところの抽象既定クラスを用いたテンプレートパターンの実装ができない。それぞれの構造体で基本的にはコピペとなる構造体のメソッドを定義しないといけない。もちろん別のヘルパーに移譲するといったことはできるけど、状態をもっていないコードの再利用はたしかに安全ではあるけれど、状態を参照できないからそのために値をコピーするといった整合性の懸念やボイラープレート的なコードを書く必要がある。これは設計におけるトレードオフになるので go の処理系の設計に不満があるわけではない。但し、generics でできることにはまだ機能不足がある。とくに直和型の扱い。できないのかな？とググると proposal の issue がみつかるので今後の機能拡張に期待したい。</p><p>正直マネージャーが開発に工数使っていて何やってるんだとみられているかもしれない。1-2週間集中してリファクタリングしてみて、いまのアプリケーションの設計の勘所が以前よりも理解が進んだ。コードレビューだけではわからないフィードバックがある。結合テストもいくつか追加したので今後の開発で役に立つはず。これで私の (リファクタリング) 開発は終了しようと思う。</p><p>今日作ったマージリクエストの diff が次になる。</p><pre tabindex=0><code>51 files +1314 -648
</code></pre><p>diff の行数だけ数えると今週だけで1万行近くは変更したと思う。</p></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2023/0220/>コンテキストによるキャンセル処理</a></h1><div class=post-meta><time class=post-date>2023-02-20 (Mon.) ::</time></div><span class=post-tags>#<a href=/diary/tags/go/>go</a>&nbsp;
#<a href=/diary/tags/refactoring/>refactoring</a>&nbsp;</span><div class=post-content><p>1時に寝て7時に起きた。昨日がっつりコードを書いていたせいか、起きてから今日は休みたいと思いながらだらだらしてた。休めないのだけど。貧乏暇なし。</p><h2 id=echo-のリクエストコンテキスト>echo のリクエストコンテキスト</h2><p>昨日の続きで mongodb のリファクタリングをしている。mongodb はほぼすべての処理で <a href=https://www.mongodb.com/docs/drivers/go/current/fundamentals/context/>コンテキスト</a> を受け取れるように設計されている。メンバーが <a href=https://pkg.go.dev/context>go の context</a> の扱いを理解していないのでコンテキストを渡すようなインターフェースになっていない。私もこれまでのコードレビューでキャンセル処理は些事なのでそれよりも機能開発を優先して後回しにしていた。それで、いま機能が一通り開発完了したのでインターフェースにコンテキストを受け取るようにリファクタリングした。デフォルトのコンテキストとして echo のリクエストコンテキストを渡す。<a href=https://github.com/labstack/echo/discussions/1815>Canceling request #1815</a> によると、echo のリクエストコンテキストは次の状況のときにキャンセルしてくれる。</p><ul><li>クライアントのコネクションがクローズされたとき</li><li>http2 でリクエストがキャンセルされたとき</li><li>ServeHTTP() が返るとき<ul><li>サーバーがシャットダウンするタイミング？</li></ul></li></ul><p>使い方はこんなイメージ。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>ctx</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Request</span>().<span style=color:#a6e22e>Context</span>()
</span></span><span style=display:flex><span><span style=color:#a6e22e>store</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#a6e22e>myStore</span>).(<span style=color:#a6e22e>Store</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>store</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>request</span>.<span style=color:#a6e22e>From</span>, <span style=color:#a6e22e>request</span>.<span style=color:#a6e22e>To</span>)
</span></span></code></pre></div></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2023/0219/>mongodb の view 調査</a></h1><div class=post-meta><time class=post-date>2023-02-19 (Sun.) ::</time></div><span class=post-tags>#<a href=/diary/tags/mongodb/>mongodb</a>&nbsp;
#<a href=/diary/tags/refactoring/>refactoring</a>&nbsp;</span><div class=post-content><p>4時半に寝て11時に起きた。午後から go のコードをリファクタリングしてた。平日はメンバーの issue を監視して困ってたらコメントしたり、マージリクエストをレビューしたり、管理画面の振る舞いを検証したりと、コードを書いていても途中で作業がちょくちょく中断する。休日にコードを書くとその中断がない分、いつもよりかなり捗った。リファクタリングに思いの外、時間を取られている気がしたのはそのせいもあるか。</p><h2 id=mongodb-の-view-作成>mongodb の view 作成</h2><p>実はこれまで mongodb を扱ったことがなくて今回初めて触っている。とくに難しくもないのだけど、ドキュメントを探してやりたいことを調べたり、デバッグや開発のためのツールとしてどういうものがあるかといった知見がない。ないものは仕方ないので1からドキュメントを読みながら開発というか、リファクタリングをしている。mongodb そのものの知見はなくても、様々なデータベースを操作する開発をしてきたのでやりたいことに対して実装方法はいくつか検討がつくし、その実装を支援するための機能もあるはずだと予測がつくので探すのも早い。</p><p>ある collection から複数のデータ構造のレスポンスを返すような処理がある。こういったものは view を使うとうまく整理できると知っているので調べると <a href=https://www.mongodb.com/docs/manual/core/views/>mongodb view</a> が提供されていることがわかる。3.4 から追加されたらしい。いまクエリの中で <a href=https://www.mongodb.com/docs/manual/core/aggregation-pipeline/#std-label-aggregation-pipeline>aggregation pipeline</a> を書いている処理のいくつかは、あらかじめ view を定義してクエリすることでインフラ層を堅牢にした上で実装もシンプルにできる。さらに 4.2 から <a href=https://www.mongodb.com/docs/manual/core/materialized-views/#std-label-manual-materialized-views>on-demand materialized view</a> が追加されていて、標準の view と比較して aggregation pipeline の計算結果をディスクに保持するのでパフォーマンス上のメリットがある。元データの更新が頻繁でなければ on-demand を使った方がよいのだろうと推測する。</p><p>またこれまで mongodb の管理画面に <a href=https://github.com/mongo-express/mongo-express>mongo-express</a> を使っている。view の振る舞いを確認しようとしたところ、どうも view には対応していないようにみえる。web ベースの管理画面を他にも探してみたが、どうも他に適当なものがない。mongodb が公式に <a href=https://www.mongodb.com/products/compass>compass</a> というデスクトップアプリケーションの gui クライアントを提供している。macos なら brew からインストールできた。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>&gt; brew install mongodb-compass
</span></span></code></pre></div><p>このツールは collection も view も両方扱えるし、クエリやパイプラインも実行できて機能も充実している。web ベースじゃないとインフラとして共有はできないところだけが残念なところ。それでも開発する上ではとても強力なツールにみえる。適当にデータをインポートしたり、テストで aggregation pipeline を作成してみて、それをエクスポートして view を生成するときのスキーマ定義も作ることができた。ui も洗練していて、こんな優れたデスクトップアプリケーションは久しぶりにみたと思うぐらい感心した。</p></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2023/0216/>mongodb を触ってみる</a></h1><div class=post-meta><time class=post-date>2023-02-16 (Thu.) ::</time></div><span class=post-tags>#<a href=/diary/tags/refactoring/>refactoring</a>&nbsp;
#<a href=/diary/tags/design/>design</a>&nbsp;</span><div class=post-content><p>0時に寝て7時半に起きた。今日は1日中リファクタリングしてコードを書いていた。</p><h2 id=リファクタリング>リファクタリング</h2><p><a href=https://www.mongodb.com/>mongodb</a> 周りのインフラ層のリファクタリングしている。過去に mongodb を触ったことがなかったので mongodb そのものの振る舞いや仕様なども理解しながらリファクタリングしている。その第一弾として差分が1500行以上のマージリクエストを作った。私の中ではまだ 1/3 ぐらいの進捗。動くレベルになったのでコードレビューを通じてメンバーと設計の考え方を共有していく。差分は多いけど、重要なところは一部だけ。やり過ぎだなと思えるのは、設計を見直すとテストコードを書き換える必要があって、その書き換えをやっていると時間が削られる。設計の部分だけ変更して、その後の作業をメンバーに引き継いでもらうといったやり方ならもっと早くできるかもしれないけど、テストコードを書き換える過程で私もユーザーの立場になって設計の良し悪しを検証するきっかけになるのでこの作業は自分でやることにも価値があると考えている。</p><p>設計がよくないところをどうやってメンバーに指導していくかはなかなか難しい。良し悪しは複数の設計を比較することで初めて気づくことも多い。私はその引き出しが多いので比較対象がたくさんあるだけでメンバーはその引き出しが少ないから悪い設計と認識できないでいる。その比較対象を私が提示してメンバーが考える機会にしてあげたい。理屈上はこれだけなんだけど、現実のコードと納期とのバランスを取るのが難しい。</p><p>いい加減マネージャーがリファクタリングに工数を使い過ぎだろうと私自身でも思うようになってきたので週末に残りのコードを書いて区切りのよいところでひと段落つけようと思う。</p></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2023/0214/>個人の人生と会社の経営</a></h1><div class=post-meta><time class=post-date>2023-02-14 (Tue.) ::</time></div><span class=post-tags>#<a href=/diary/tags/refactoring/>refactoring</a>&nbsp;
#<a href=/diary/tags/project-management/>project management</a>&nbsp;
#<a href=/diary/tags/management/>management</a>&nbsp;
#<a href=/diary/tags/life/>life</a>&nbsp;</span><div class=post-content><p>1時に寝て6時半に起きた。久しぶりに起きずに長時間眠れた気がする。1-2ヶ月に1回あるかどうかぐらいの感覚。</p><h2 id=リファクタリング>リファクタリング</h2><p>ここ最近、私がバックエンドのリファクタリングを集中的にやっている。私からみたらバックエンドの設計にはいくつか改善の余地がある。動いているという視点では及第点ではあるし、メンバーは限られた時間の中で十分にうまく開発していると考えている。それでも、遊撃として余裕があるときにリファクタリングをしている。これから運用レベルの QA テストに入っていく。その前にがーっとリファクタリングしておくとテストで振る舞いを検証できるし、テストで別の不具合をみつけたときも保守コストが下がるように設計を洗練させておくことには一考の価値がある。実際にコードを書き始めると時間をどんどん取られて、マネジメントの業務から離れていってしまう。マネージャーがコードに集中し過ぎるのも問題だというのも理解できるようになってきた。本来はあまり深入りしない程度にメンバーに要点を伝えて改善したもらうのが正しいとは思う。いろいろプロジェクトの都合があるので必ずしも思い描いたようにはいかない。バランスをとってうまくやりたい。</p><h2 id=余暇と経営と個人>余暇と経営と個人</h2><p>1月以降は実家の法事のために私の余暇の半分程度の時間を取られている。先週末に49日を終えたので次の法事は初盆まで余裕がある。とはいえ、弁護士さんと実家と相続のやり取りがあってまだ何割か時間を取られている。この余暇の時間に、これまでは自社の業務や事務手続きをしている。その余暇が少なくなると、最終的には他のところにも皺寄せがいく。余暇に余裕がないと自分の会社を経営するのはなかなかしんどいところもあるかもしれない。</p><p>来季は実家の一部を自社のオフィスにしようと考えている。よくよく考えれば、神戸のオフィスでフルリモートワークをするのも、淡路島のオフィスでフルリモートワークをするのも、お客さんからみたら全く違いがない。いままでそうしてこなかったのは、神戸のオフィスでは業務に集中できるよう、私にとって最適な環境を構築し続けているからと言える。最も大きな違いは椅子だと思う。よい椅子でデスクワークしていると、あまり粗末な椅子でデスクワークしたくないというネガティブなモチベーションになってしまう。</p><p>メインオフィスと同じとはいかなくても準ずる程度のオフィス環境を実家に構築できれば実家に帰って1-2週間程度のフルリモートワークをしてもよいと考えている。その延長上で実家との行き来を出張扱いにして経費を使えるようにし、経営的にはそうすることで節税にもつながる。私個人の視点からも、親の介護という、私の人生設計上避けられない問題に対する解決策となる。個人の人生の問題と会社の経営を両立させることは、自分の会社であれば、十分に両立できると自信をもって言える。この話しも田舎から上京してその後のキャリアを考える上でのモデルケースの1つとして、いつかブログの記事として書きたい。</p></div></article><div class=pagination><div class=pagination__buttons><a href=/diary/tags/refactoring/page/2/ class="button next"><span class=button__text>過去の日記</span>
<span class=button__icon>→</span></a></div></div></div></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>© 2021 Tetsuya Morimoto</span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script type=text/javascript src=/diary/bundle.min.js></script></div></body></html>