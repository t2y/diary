<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>testing on forest nook</title><link>/diary/tags/testing/</link><description>Recent content in testing on forest nook</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><copyright>© 2021 Tetsuya Morimoto</copyright><lastBuildDate>Thu, 23 Jun 2022 07:55:59 +0900</lastBuildDate><atom:icon>/diary/favicon.ico</atom:icon><icon>/diary/favicon.ico</icon><atom:link href="/diary/tags/testing/index.xml" rel="self" type="application/rss+xml"/><item><title>assertj を使ってみた</title><link>/diary/posts/2022/0623/</link><pubDate>Thu, 23 Jun 2022 07:55:59 +0900</pubDate><guid>/diary/posts/2022/0623/</guid><description>0時に寝て6時に起きた。
assertDeepEquals を作った AssertJ というアサーションライブラリを使って assertDeepEquals を実装した。
junit4 では hamcrest という matcher が使われていて、それが assertDeepEquals 相当の機能を提供していたが、それが junit5 では提供されなくなったので自分で実装するか、アサーションライブラリを別途使う必要がある。
現時点でJUnit5ではHamcrestのMatcherは提供せず、使用者が自由に選択する方針で進んでいます。そうなった場合、標準でサポートされるassertTrueやassertEquelsなどだけでは、ちょっと頼りなく車輪の再発明になりそうなので、候補になりそうなHamcrestとAssertJのよく使いそうなメソッド比較表を作りました。
JUnitのアサーションライブラリHamcrest,AssertJ比較
2.4.2. Third-party Assertion Libraries によると、junit は基本的なアサーション機能を提供し、より強力なアサーションはサードパーティ製の好きなライブラリを使ってくれみたいなことが書いてある。軽く github でソースコード検索しても、みんな自前で作っているんやなということも分かる。
https://github.com/search?l=Java&amp;amp;q=assertDeepEquals&amp;amp;type=Code hamcrest はもう保守されていないようにみえるので assertj を使うことにした。assertj の機能を使うと assertDeepEquals を次のように実装できる。直接 assertj を使ってもよいのだけど、assertXxx という名前で使えた方が junit ベースのテストのアサートの統合性があるし、いまお手伝い先では myapp-test のような、テスト向けの共通ライブラリを提供していて、すべてのプロジェクトで既に使っているので assertj の依存関係を追加しなくてもすぐに使えるというぐらいの利便性を提供するだけのユーティリティになる。
public class Assertions { public static final void assertDeepEquals(Object expected, Object actual) { assertThat(expected).usingRecursiveComparison().isEqualTo(actual); } public static final void assertDeepEquals(Object expected, Object actual, String.</description><content>&lt;p>0時に寝て6時に起きた。&lt;/p>
&lt;h2 id="assertdeepequals-を作った">assertDeepEquals を作った&lt;/h2>
&lt;p>&lt;a href="https://assertj.github.io/doc/">AssertJ&lt;/a> というアサーションライブラリを使って &lt;code>assertDeepEquals&lt;/code> を実装した。&lt;/p>
&lt;p>junit4 では hamcrest という matcher が使われていて、それが &lt;code>assertDeepEquals&lt;/code> 相当の機能を提供していたが、それが junit5 では提供されなくなったので自分で実装するか、アサーションライブラリを別途使う必要がある。&lt;/p>
&lt;blockquote>
&lt;p>現時点でJUnit5ではHamcrestのMatcherは提供せず、使用者が自由に選択する方針で進んでいます。そうなった場合、標準でサポートされるassertTrueやassertEquelsなどだけでは、ちょっと頼りなく車輪の再発明になりそうなので、候補になりそうなHamcrestとAssertJのよく使いそうなメソッド比較表を作りました。&lt;/p>
&lt;p>&lt;a href="https://qiita.com/disc99/items/31fa7abb724f63602dc9">JUnitのアサーションライブラリHamcrest,AssertJ比較&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;a href="https://junit.org/junit5/docs/snapshot/user-guide/#writing-tests-assertions-third-party">2.4.2. Third-party Assertion Libraries&lt;/a> によると、junit は基本的なアサーション機能を提供し、より強力なアサーションはサードパーティ製の好きなライブラリを使ってくれみたいなことが書いてある。軽く github でソースコード検索しても、みんな自前で作っているんやなということも分かる。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/search?l=Java&amp;amp;q=assertDeepEquals&amp;amp;type=Code">https://github.com/search?l=Java&amp;amp;q=assertDeepEquals&amp;amp;type=Code&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>hamcrest はもう保守されていないようにみえるので assertj を使うことにした。assertj の機能を使うと &lt;code>assertDeepEquals&lt;/code> を次のように実装できる。直接 assertj を使ってもよいのだけど、assertXxx という名前で使えた方が junit ベースのテストのアサートの統合性があるし、いまお手伝い先では myapp-test のような、テスト向けの共通ライブラリを提供していて、すべてのプロジェクトで既に使っているので assertj の依存関係を追加しなくてもすぐに使えるというぐらいの利便性を提供するだけのユーティリティになる。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Assertions&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">assertDeepEquals&lt;/span>&lt;span style="color:#f92672">(&lt;/span>Object expected&lt;span style="color:#f92672">,&lt;/span> Object actual&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
assertThat&lt;span style="color:#f92672">(&lt;/span>expected&lt;span style="color:#f92672">).&lt;/span>&lt;span style="color:#a6e22e">usingRecursiveComparison&lt;/span>&lt;span style="color:#f92672">().&lt;/span>&lt;span style="color:#a6e22e">isEqualTo&lt;/span>&lt;span style="color:#f92672">(&lt;/span>actual&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">assertDeepEquals&lt;/span>&lt;span style="color:#f92672">(&lt;/span>Object expected&lt;span style="color:#f92672">,&lt;/span> Object actual&lt;span style="color:#f92672">,&lt;/span> String&lt;span style="color:#f92672">...&lt;/span> fields&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
assertThat&lt;span style="color:#f92672">(&lt;/span>expected&lt;span style="color:#f92672">).&lt;/span>&lt;span style="color:#a6e22e">usingRecursiveComparison&lt;/span>&lt;span style="color:#f92672">().&lt;/span>&lt;span style="color:#a6e22e">comparingOnlyFields&lt;/span>&lt;span style="color:#f92672">(&lt;/span>fields&lt;span style="color:#f92672">).&lt;/span>&lt;span style="color:#a6e22e">isEqualTo&lt;/span>&lt;span style="color:#f92672">(&lt;/span>actual&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">assertDeepEqualsIgnoringFields&lt;/span>&lt;span style="color:#f92672">(&lt;/span>Object expected&lt;span style="color:#f92672">,&lt;/span> Object actual&lt;span style="color:#f92672">,&lt;/span> String&lt;span style="color:#f92672">...&lt;/span> fields&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
assertThat&lt;span style="color:#f92672">(&lt;/span>expected&lt;span style="color:#f92672">).&lt;/span>&lt;span style="color:#a6e22e">usingRecursiveComparison&lt;/span>&lt;span style="color:#f92672">().&lt;/span>&lt;span style="color:#a6e22e">ignoringFields&lt;/span>&lt;span style="color:#f92672">(&lt;/span>fields&lt;span style="color:#f92672">).&lt;/span>&lt;span style="color:#a6e22e">isEqualTo&lt;/span>&lt;span style="color:#f92672">(&lt;/span>actual&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div></content></item><item><title>データベースを介したテストではまった話し</title><link>/diary/posts/2022/0613/</link><pubDate>Mon, 13 Jun 2022 10:20:17 +0900</pubDate><guid>/diary/posts/2022/0613/</guid><description>1時に寝て7時に起きた。帰りにふらっと仲のよい焼き鳥屋さんに寄ったらちょっとしたハプニングがあって長居してしまった。他に来ていたお客さんのカップルが別れ話を始め、こじれてややこしい状況になって、この騒動が一段落しないと席を立てない空気になってしまって終わるのを待ってた。マスターの知り合いらしくて、そのお客さんが帰ってから当事者たちの背景を聞いたりしてた。人生いろいろあるよなぁ。
spring の Transactional アノテーション spring フレームワークには Transactional というアノテーションがある。SpringBootTest を使ったテストのときに使うと、テストメソッドの終了時に自動的にデータベースへの書き込みがロールバックされて便利なことを テストコードのリファクタリング をしていたときに気付いた。
スレッドプールを使ってマルチスレッドで並行実行する処理を書いてそのテストを書いてみたら意図した結果にならない。なんでだろう？と2時間ほどはまってデバッグしていた。テストデータの書き込みが、実際にはデータベースにコミットされていないので、テストを実行しているスレッド以外のワーカースレッドからデータベースにアクセスしてもテストデータを参照できないからだと気付いた。データベースのトランザクションに細工すると、こういうはまりどころがあるなぁと気付いて Transactional を使わずに普通にテストを書いた。その分、自分でテストメソッドが呼ばれてコミットされたテストデータを削除する必要がある。調べていたときに他にも副作用がいろいろあるよという記事もみつけた。
Don’t Use @Transactional in Tests</description><content>&lt;p>1時に寝て7時に起きた。帰りにふらっと仲のよい焼き鳥屋さんに寄ったらちょっとしたハプニングがあって長居してしまった。他に来ていたお客さんのカップルが別れ話を始め、こじれてややこしい状況になって、この騒動が一段落しないと席を立てない空気になってしまって終わるのを待ってた。マスターの知り合いらしくて、そのお客さんが帰ってから当事者たちの背景を聞いたりしてた。人生いろいろあるよなぁ。&lt;/p>
&lt;h2 id="spring-の-transactional-アノテーション">spring の Transactional アノテーション&lt;/h2>
&lt;p>spring フレームワークには &lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Transactional.html">Transactional&lt;/a> というアノテーションがある。&lt;a href="https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/test/context/SpringBootTest.html">SpringBootTest&lt;/a> を使ったテストのときに使うと、テストメソッドの終了時に自動的にデータベースへの書き込みがロールバックされて便利なことを &lt;a href="/diary/diary/posts/2022/0208/#テストコードのリファクタリング">テストコードのリファクタリング&lt;/a> をしていたときに気付いた。&lt;/p>
&lt;p>スレッドプールを使ってマルチスレッドで並行実行する処理を書いてそのテストを書いてみたら意図した結果にならない。なんでだろう？と2時間ほどはまってデバッグしていた。テストデータの書き込みが、実際にはデータベースにコミットされていないので、テストを実行しているスレッド以外のワーカースレッドからデータベースにアクセスしてもテストデータを参照できないからだと気付いた。データベースのトランザクションに細工すると、こういうはまりどころがあるなぁと気付いて Transactional を使わずに普通にテストを書いた。その分、自分でテストメソッドが呼ばれてコミットされたテストデータを削除する必要がある。調べていたときに他にも副作用がいろいろあるよという記事もみつけた。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://dev.to/henrykeys/don-t-use-transactional-in-tests-40eb">Don’t Use @Transactional in Tests&lt;/a>&lt;/li>
&lt;/ul></content></item><item><title>Mockito を触ってみた</title><link>/diary/posts/2022/0217/</link><pubDate>Thu, 17 Feb 2022 07:41:24 +0900</pubDate><guid>/diary/posts/2022/0217/</guid><description>0時に寝て4時に起きて6時に起きた。6時過ぎに slack でインフラ担当者から作業の報告があってその対応してた。
Mockito のモック作成 Spring 5 WebClient のテストコードを書いてみた。Mockito というモックライブラリを使っているのをみかけたのでそれを使うことにした。当初は WebClient そのもののモックを用意して、どんなメソッドを呼び出しても Null オブジェクトのように無視すればいいんじゃないかと思ってたんだけど、Mockito はそういう用途に使うものではなく、それぞれのメソッドごとにモックを返すような設定ができる。次のような WebClient のメソッドチェーンでリクエストするようなモックを考える。
var response = this.client .get() .uri(uriBuilder -&amp;gt; uriBuilder .path(path) .queryParam(&amp;#34;param&amp;#34;, param) .build()) .retrieve() .bodyToMono(MyResponse.class) .block(); 他にもっとよいやり方があるかもしれないけど、私がよくわかってなくてこんなやり方しかできなかった。最終的には block() を呼び出したときに任意のレスポンスを取得できればよいのだけど、メソッド単位にモックを呼び出していかないと型チェックやら実行時エラーやらで意図したようにテストできなかった。これだけをみたらメソッドチェーンのモック作りは面倒にみえる。Mockito がどうやってこれを実現しているのかわからないけど、すごい仕組みだなとは思った。
@MockBean WebClient client; @Mock WebClient.RequestHeadersUriSpec requestHeadersUriSpec; @Mock WebClient.RequestHeadersSpec requestHeadersSpec; @Mock WebClient.ResponseSpec responseSpec; @Mock Mono&amp;lt;MyResponse&amp;gt; mono; private void mockWebClientMethodChain(MyResponse response) { Mockito.when(client.get()).thenReturn(requestHeadersUriSpec); Mockito.when(requestHeadersUriSpec.uri((Function&amp;lt;UriBuilder, URI&amp;gt;) Mockito.any())).thenReturn(requestHeadersSpec); Mockito.when(requestHeadersSpec.retrieve()).thenReturn(responseSpec); Mockito.when(responseSpec.bodyToMono(MyResponse.class)).thenReturn(mono); Mockito.when(mono.block()).thenReturn(response); }</description><content>&lt;p>0時に寝て4時に起きて6時に起きた。6時過ぎに slack でインフラ担当者から作業の報告があってその対応してた。&lt;/p>
&lt;h2 id="mockito-のモック作成">Mockito のモック作成&lt;/h2>
&lt;p>&lt;a href="https://www.baeldung.com/spring-5-webclient">Spring 5 WebClient&lt;/a> のテストコードを書いてみた。&lt;a href="https://site.mockito.org/">Mockito&lt;/a> というモックライブラリを使っているのをみかけたのでそれを使うことにした。当初は WebClient そのもののモックを用意して、どんなメソッドを呼び出しても Null オブジェクトのように無視すればいいんじゃないかと思ってたんだけど、Mockito はそういう用途に使うものではなく、それぞれのメソッドごとにモックを返すような設定ができる。次のような WebClient のメソッドチェーンでリクエストするようなモックを考える。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">var response &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">client&lt;/span>
&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">get&lt;/span>&lt;span style="color:#f92672">()&lt;/span>
&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">uri&lt;/span>&lt;span style="color:#f92672">(&lt;/span>uriBuilder &lt;span style="color:#f92672">-&amp;gt;&lt;/span> uriBuilder
&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">path&lt;/span>&lt;span style="color:#f92672">(&lt;/span>path&lt;span style="color:#f92672">)&lt;/span>
&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">queryParam&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;param&amp;#34;&lt;/span>&lt;span style="color:#f92672">,&lt;/span> param&lt;span style="color:#f92672">)&lt;/span>
&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">build&lt;/span>&lt;span style="color:#f92672">())&lt;/span>
&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">retrieve&lt;/span>&lt;span style="color:#f92672">()&lt;/span>
&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">bodyToMono&lt;/span>&lt;span style="color:#f92672">(&lt;/span>MyResponse&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">class&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">block&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>他にもっとよいやり方があるかもしれないけど、私がよくわかってなくてこんなやり方しかできなかった。最終的には &lt;code>block()&lt;/code> を呼び出したときに任意のレスポンスを取得できればよいのだけど、メソッド単位にモックを呼び出していかないと型チェックやら実行時エラーやらで意図したようにテストできなかった。これだけをみたらメソッドチェーンのモック作りは面倒にみえる。Mockito がどうやってこれを実現しているのかわからないけど、すごい仕組みだなとは思った。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java"> &lt;span style="color:#a6e22e">@MockBean&lt;/span>
WebClient client&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#a6e22e">@Mock&lt;/span>
WebClient&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">RequestHeadersUriSpec&lt;/span> requestHeadersUriSpec&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#a6e22e">@Mock&lt;/span>
WebClient&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">RequestHeadersSpec&lt;/span> requestHeadersSpec&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#a6e22e">@Mock&lt;/span>
WebClient&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">ResponseSpec&lt;/span> responseSpec&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#a6e22e">@Mock&lt;/span>
Mono&lt;span style="color:#f92672">&amp;lt;&lt;/span>MyResponse&lt;span style="color:#f92672">&amp;gt;&lt;/span> mono&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">mockWebClientMethodChain&lt;/span>&lt;span style="color:#f92672">(&lt;/span>MyResponse response&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
Mockito&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">when&lt;/span>&lt;span style="color:#f92672">(&lt;/span>client&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">get&lt;/span>&lt;span style="color:#f92672">()).&lt;/span>&lt;span style="color:#a6e22e">thenReturn&lt;/span>&lt;span style="color:#f92672">(&lt;/span>requestHeadersUriSpec&lt;span style="color:#f92672">);&lt;/span>
Mockito&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">when&lt;/span>&lt;span style="color:#f92672">(&lt;/span>requestHeadersUriSpec&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">uri&lt;/span>&lt;span style="color:#f92672">((&lt;/span>Function&lt;span style="color:#f92672">&amp;lt;&lt;/span>UriBuilder&lt;span style="color:#f92672">,&lt;/span> URI&lt;span style="color:#f92672">&amp;gt;)&lt;/span> Mockito&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">any&lt;/span>&lt;span style="color:#f92672">())).&lt;/span>&lt;span style="color:#a6e22e">thenReturn&lt;/span>&lt;span style="color:#f92672">(&lt;/span>requestHeadersSpec&lt;span style="color:#f92672">);&lt;/span>
Mockito&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">when&lt;/span>&lt;span style="color:#f92672">(&lt;/span>requestHeadersSpec&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">retrieve&lt;/span>&lt;span style="color:#f92672">()).&lt;/span>&lt;span style="color:#a6e22e">thenReturn&lt;/span>&lt;span style="color:#f92672">(&lt;/span>responseSpec&lt;span style="color:#f92672">);&lt;/span>
Mockito&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">when&lt;/span>&lt;span style="color:#f92672">(&lt;/span>responseSpec&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">bodyToMono&lt;/span>&lt;span style="color:#f92672">(&lt;/span>MyResponse&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">class&lt;/span>&lt;span style="color:#f92672">)).&lt;/span>&lt;span style="color:#a6e22e">thenReturn&lt;/span>&lt;span style="color:#f92672">(&lt;/span>mono&lt;span style="color:#f92672">);&lt;/span>
Mockito&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">when&lt;/span>&lt;span style="color:#f92672">(&lt;/span>mono&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">block&lt;/span>&lt;span style="color:#f92672">()).&lt;/span>&lt;span style="color:#a6e22e">thenReturn&lt;/span>&lt;span style="color:#f92672">(&lt;/span>response&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div></content></item><item><title>テストコードのリファクタリング</title><link>/diary/posts/2022/0208/</link><pubDate>Tue, 08 Feb 2022 09:04:49 +0900</pubDate><guid>/diary/posts/2022/0208/</guid><description>0時に寝て6時に起きた。今日は7時半から23時過ぎまで集中してコードを書いてた。最近は19-20時には帰って、晩ご飯食べて、ドラクエタクトやったり漫画読んだりだらだらしている。そんな暇あったら積ん読の本読めって感じだ。
テストコードのリファクタリング 業務機能の開発をするにあたって、既存のテストコードをみていて、@BeforeEach というテストメソッド単位に呼ばれるメソッドでテストデータの削除と postgresql の sequence のリセット処理をしていた。こんなの共通処理ですべてのテーブルの truncate と sequence のリセット処理をすればいいやんとか思って、いろいろ調べて2つのリファクタリングの PR を作成した。先日 JUnit5 の拡張 を調べたばかりだから、テストの共通化のノウハウが溜まっている。Testcontainers Postgres Module と連携して、postgresql コンテナに接続して sequence のリセット処理を汎用のテスト拡張として実装した。テストを実装する開発者は、次のように @ExtendWith(DatabaseInitializer.class) をアノテーションに付与すれば、自分で sequence のリセット処理を @BeforeEach のメソッドに実装する必要がなくなる。
@SpringBootTest @Transactional @ExtendWith(SetupDatabaseContainer.class) @ExtendWith(DatabaseInitializer.class) class MyTest { ... } この作業の過程で spring boot の @Transactional はデフォルトでテストメソッドの実行後にロールバックする機能が提供されていて、いままで @BeforeEach のメソッドで明示的にテーブルのデータを削除する必要はなかったんやと気付いた。じゃあ、なぜ削除するコードを書いてたかと言うと、テストの外部で初期データを作成する仕組みがあるから、初期データを削除する目的でそうしていたことが判明した。そして、一部のコードはそこで作った外部の初期データに依存して実装されていた。テストコードの一部が外部のデータに依存しつつ、テストメソッドでは外部のデータに依存しないように削除のコードが書いてある。書いていて何を言っているのかわからないと思うけど、私も調べてて訳がわからんくて、PR に「いまの状況はかなりややこしい」と前置きしつつ、無駄なコードや仕組みを取り除くための修正を行った。本当は機能開発やらないといけないのにテストコードのリファクタリングするのに大きな時間をかけるわけにはいかないだろうという意図で、半日掛けてリファクタリングして23時過ぎまで作業して、既存のテストコードも含めて全部直した。このリファクタリングで数十のテストケースの約300行ぐらいの初期化コードをなくせた。</description><content>&lt;p>0時に寝て6時に起きた。今日は7時半から23時過ぎまで集中してコードを書いてた。最近は19-20時には帰って、晩ご飯食べて、ドラクエタクトやったり漫画読んだりだらだらしている。そんな暇あったら積ん読の本読めって感じだ。&lt;/p>
&lt;h2 id="テストコードのリファクタリング">テストコードのリファクタリング&lt;/h2>
&lt;p>業務機能の開発をするにあたって、既存のテストコードをみていて、&lt;code>@BeforeEach&lt;/code> というテストメソッド単位に呼ばれるメソッドでテストデータの削除と postgresql の sequence のリセット処理をしていた。こんなの共通処理ですべてのテーブルの truncate と sequence のリセット処理をすればいいやんとか思って、いろいろ調べて2つのリファクタリングの PR を作成した。先日 &lt;a href="/diary/diary/posts/2022/0116/">JUnit5 の拡張&lt;/a> を調べたばかりだから、テストの共通化のノウハウが溜まっている。&lt;a href="https://www.testcontainers.org/modules/databases/postgres/">Testcontainers Postgres Module&lt;/a> と連携して、postgresql コンテナに接続して sequence のリセット処理を汎用のテスト拡張として実装した。テストを実装する開発者は、次のように &lt;code>@ExtendWith(DatabaseInitializer.class)&lt;/code> をアノテーションに付与すれば、自分で sequence のリセット処理を &lt;code>@BeforeEach&lt;/code> のメソッドに実装する必要がなくなる。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#a6e22e">@SpringBootTest&lt;/span>
&lt;span style="color:#a6e22e">@Transactional&lt;/span>
&lt;span style="color:#a6e22e">@ExtendWith&lt;/span>&lt;span style="color:#f92672">(&lt;/span>SetupDatabaseContainer&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">class&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;span style="color:#a6e22e">@ExtendWith&lt;/span>&lt;span style="color:#f92672">(&lt;/span>DatabaseInitializer&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">class&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MyTest&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#f92672">...&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>この作業の過程で spring boot の &lt;a href="https://spring.pleiades.io/spring-framework/docs/current/reference/html/testing.html#testcontext-tx-enabling-transactions">@Transactional&lt;/a> はデフォルトでテストメソッドの実行後にロールバックする機能が提供されていて、いままで &lt;code>@BeforeEach&lt;/code> のメソッドで明示的にテーブルのデータを削除する必要はなかったんやと気付いた。じゃあ、なぜ削除するコードを書いてたかと言うと、テストの外部で初期データを作成する仕組みがあるから、初期データを削除する目的でそうしていたことが判明した。そして、一部のコードはそこで作った外部の初期データに依存して実装されていた。テストコードの一部が外部のデータに依存しつつ、テストメソッドでは外部のデータに依存しないように削除のコードが書いてある。書いていて何を言っているのかわからないと思うけど、私も調べてて訳がわからんくて、PR に「いまの状況はかなりややこしい」と前置きしつつ、無駄なコードや仕組みを取り除くための修正を行った。本当は機能開発やらないといけないのにテストコードのリファクタリングするのに大きな時間をかけるわけにはいかないだろうという意図で、半日掛けてリファクタリングして23時過ぎまで作業して、既存のテストコードも含めて全部直した。このリファクタリングで数十のテストケースの約300行ぐらいの初期化コードをなくせた。&lt;/p></content></item><item><title>JUnit5 のテスト拡張</title><link>/diary/posts/2022/0116/</link><pubDate>Sun, 16 Jan 2022 10:08:01 +0900</pubDate><guid>/diary/posts/2022/0116/</guid><description>1時に寝て5時に起きて2度寝して9時に起きた。前日呑んでたのであまり眠れなくて体調よくない。
JUnit5 的なロガーのテスト お仕事でログ管理の機能開発をしている。カスタムロガーを使って出力するメッセージを加工している。設計が固まってきて機能も作り込むようになってきたので出力内容が意図した構造化ログになっているかをテストしたい。JUnit5 の機能と log4j の機能を組み合わせてカスタムロガーのテストの仕組みを作ってみた。
まずログ出力した内容を取得するオブジェクトを特定するためのアノテーションを定義する。
@Documented @Target(ElementType.FIELD) @Retention(RetentionPolicy.RUNTIME) public @interface LoggerTestWriter { } JUnit5 の Declarative Extension Registration の仕組みを使って、テストケース非依存な setup/teadown のメソッドを定義する。ExtensionContext から拡張するテストケースのインスタンスを取得できる。テストケースインスタンスに定義されている @LoggerTestWriter アノテーションがついたオブジェクトを lgo4j の Appender としてインジェクションするようなコードを setup/teardown (beforeEach/afterEach メソッド) で定義する。Appender のインジェクション周りは Log4j 2でログ出力をテストするサンプルソース の記事を参考にした。
public class SetupLogAppender implements BeforeEachCallback, AfterEachCallback { private static String APPENDER_NAME = &amp;#34;logger-test-appender&amp;#34;; private Optional&amp;lt;Writer&amp;gt; getWriter(ExtensionContext context) throws IllegalAccessException { var testInstance = context.getRequiredTestInstance(); for (var field : testInstance.getClass().getDeclaredFields()) { if (field.</description><content>&lt;p>1時に寝て5時に起きて2度寝して9時に起きた。前日呑んでたのであまり眠れなくて体調よくない。&lt;/p>
&lt;h2 id="junit5-的なロガーのテスト">JUnit5 的なロガーのテスト&lt;/h2>
&lt;p>お仕事でログ管理の機能開発をしている。カスタムロガーを使って出力するメッセージを加工している。設計が固まってきて機能も作り込むようになってきたので出力内容が意図した構造化ログになっているかをテストしたい。JUnit5 の機能と log4j の機能を組み合わせてカスタムロガーのテストの仕組みを作ってみた。&lt;/p>
&lt;p>まずログ出力した内容を取得するオブジェクトを特定するためのアノテーションを定義する。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#a6e22e">@Documented&lt;/span>
&lt;span style="color:#a6e22e">@Target&lt;/span>&lt;span style="color:#f92672">(&lt;/span>ElementType&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">FIELD&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;span style="color:#a6e22e">@Retention&lt;/span>&lt;span style="color:#f92672">(&lt;/span>RetentionPolicy&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">RUNTIME&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">@interface&lt;/span> LoggerTestWriter &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>JUnit5 の &lt;a href="https://junit.org/junit5/docs/current/user-guide/#extensions-registration-declarative">Declarative Extension Registration&lt;/a> の仕組みを使って、テストケース非依存な setup/teadown のメソッドを定義する。&lt;a href="https://junit.org/junit5/docs/current/api/org.junit.jupiter.api/org/junit/jupiter/api/extension/ExtensionContext.html">ExtensionContext&lt;/a> から拡張するテストケースのインスタンスを取得できる。テストケースインスタンスに定義されている &lt;code>@LoggerTestWriter&lt;/code> アノテーションがついたオブジェクトを lgo4j の Appender としてインジェクションするようなコードを setup/teardown (beforeEach/afterEach メソッド) で定義する。Appender のインジェクション周りは &lt;a href="https://qiita.com/kazurof/items/abbd42f11bfc125f3190">Log4j 2でログ出力をテストするサンプルソース&lt;/a> の記事を参考にした。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">SetupLogAppender&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> BeforeEachCallback&lt;span style="color:#f92672">,&lt;/span> AfterEachCallback &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> String APPENDER_NAME &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;logger-test-appender&amp;#34;&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> Optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>Writer&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">getWriter&lt;/span>&lt;span style="color:#f92672">(&lt;/span>ExtensionContext context&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#66d9ef">throws&lt;/span> IllegalAccessException &lt;span style="color:#f92672">{&lt;/span>
var testInstance &lt;span style="color:#f92672">=&lt;/span> context&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getRequiredTestInstance&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>var field &lt;span style="color:#f92672">:&lt;/span> testInstance&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getClass&lt;/span>&lt;span style="color:#f92672">().&lt;/span>&lt;span style="color:#a6e22e">getDeclaredFields&lt;/span>&lt;span style="color:#f92672">())&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>field&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">isAnnotationPresent&lt;/span>&lt;span style="color:#f92672">(&lt;/span>LoggerTestWriter&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">class&lt;/span>&lt;span style="color:#f92672">))&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> Optional&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">of&lt;/span>&lt;span style="color:#f92672">((&lt;/span>Writer&lt;span style="color:#f92672">)&lt;/span> field&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">get&lt;/span>&lt;span style="color:#f92672">(&lt;/span>testInstance&lt;span style="color:#f92672">));&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> Optional&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">empty&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">beforeEach&lt;/span>&lt;span style="color:#f92672">(&lt;/span>ExtensionContext context&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#66d9ef">throws&lt;/span> Exception &lt;span style="color:#f92672">{&lt;/span>
var writer &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getWriter&lt;/span>&lt;span style="color:#f92672">(&lt;/span>context&lt;span style="color:#f92672">).&lt;/span>&lt;span style="color:#a6e22e">orElseThrow&lt;/span>&lt;span style="color:#f92672">(()&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;span style="color:#66d9ef">new&lt;/span> IllegalStateException&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;@LoggerTestWriter のアノテーションをもつ Writer を定義してください&amp;#34;&lt;/span>&lt;span style="color:#f92672">));&lt;/span>
addAppender&lt;span style="color:#f92672">(&lt;/span>writer&lt;span style="color:#f92672">,&lt;/span> APPENDER_NAME&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">afterEach&lt;/span>&lt;span style="color:#f92672">(&lt;/span>ExtensionContext context&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#66d9ef">throws&lt;/span> Exception &lt;span style="color:#f92672">{&lt;/span>
var writer &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getWriter&lt;/span>&lt;span style="color:#f92672">(&lt;/span>context&lt;span style="color:#f92672">).&lt;/span>&lt;span style="color:#a6e22e">orElseThrow&lt;/span>&lt;span style="color:#f92672">(&lt;/span>IllegalStateException&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">new&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
removeAppender&lt;span style="color:#f92672">(&lt;/span>APPENDER_NAME&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>writer &lt;span style="color:#66d9ef">instanceof&lt;/span> StringWriter&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
var stringWriter &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">(&lt;/span>StringWriter&lt;span style="color:#f92672">)&lt;/span> writer&lt;span style="color:#f92672">;&lt;/span>
stringWriter&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getBuffer&lt;/span>&lt;span style="color:#f92672">().&lt;/span>&lt;span style="color:#a6e22e">delete&lt;/span>&lt;span style="color:#f92672">(&lt;/span>0&lt;span style="color:#f92672">,&lt;/span> stringWriter&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getBuffer&lt;/span>&lt;span style="color:#f92672">().&lt;/span>&lt;span style="color:#a6e22e">length&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>実際にテストを書くテストクラスは次のようになる。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#a6e22e">@ExtendWith&lt;/span>&lt;span style="color:#f92672">(&lt;/span>SetupLogAppender&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">class&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MyLoggerTest&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> MyLogger logger &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> MyLogger&lt;span style="color:#f92672">(&lt;/span>MyLoggerTest&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">class&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getName&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;span style="color:#a6e22e">@LoggerTestWriter&lt;/span>
StringWriter writer &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> StringWriter&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#a6e22e">@Test&lt;/span>
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">testDebugMap&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
logger&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">debug&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;my-message&amp;#34;&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
assertEquals&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;my-message&amp;#34;&lt;/span> writer&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">toString&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>@ExtendWith&lt;/code> で指定した &lt;code>SetupLogAppender&lt;/code> クラスの beforeEach や afterEach がそれぞれのテストメソッドごとに呼ばれて、Appender のインジェクションが &lt;code>@LoggerTestWriter&lt;/code> のアノテーションをもつ writer を使って行われる。この writer にはログ出力した文字列が記録されるようになる。これで、テストメソッドで logger に対して出力したメッセージを writer から取得できるので意図したメッセージが出力されていることをテストできる。カスタムロガーのテストケースごとに再利用可能な拡張をきれいに実装できた。&lt;/p></content></item></channel></rss>