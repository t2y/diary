<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Mongodb on</title><link>/diary/tags/mongodb/</link><description>Recent content in Mongodb on</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Fri, 15 Nov 2024 16:24:57 +0900</lastBuildDate><atom:icon>/diary/favicon.ico</atom:icon><icon>/diary/favicon.ico</icon><atom:link href="/diary/tags/mongodb/index.xml" rel="self" type="application/rss+xml"/><item><title>モジュールは複数データソースに依存させない</title><link>/diary/posts/2024/1115/</link><pubDate>Fri, 15 Nov 2024 16:24:57 +0900</pubDate><guid>/diary/posts/2024/1115/</guid><description>デバッグしていて遅くなり、帰ってから慌ててスーパーに買いものへ行ったりしていて時間がなくなったので今日はバドミントン練習をお休み。
データベースとメッセージキューの整合性を考える 昨日の続き。トランザクションを導入したことで mongodb と mq でのデータフローが意図せず変わってしまっていることが調査してわかった。
従来は次のように動いていた。
api サーバーがエントリー情報を受け取る api ハンドラーがエントリー情報を mongodb に保存する api ハンドラーがメッセージを管理するジョブ情報を mongodb に保存する api ハンドラー内の producer が rabbitmq にメッセージを送信する consumer がメッセージを受信する consumer が mongodb からジョブ情報を参照する api ハンドラーがレスポンスを返す consumer がメッセージを処理する トランザクションを導入したことで mongodb にデータが保存されるタイミングが変わってしまった。
api サーバーがエントリー情報を受け取る api ハンドラーがトランザクションを開始する api ハンドラーがエントリー情報を mongodb に保存する (この時点では未コミット) api ハンドラーがメッセージを管理するジョブ情報を mongodb に保存する (この時点では未コミット) api ハンドラー内の producer が rabbitmq にメッセージを送信する consumer がメッセージを受信する consumer が mongodb からジョブ情報を参照するが、トランザクションがコミットされていない可能性がある api ハンドラーがトランザクションをコミットする api ハンドラーがレスポンスを返す consumer でエラーが発生する 処理の流れを見直して次のように改修した。内部実装の都合があってやや煩雑な変更となった。</description><content>&lt;p>デバッグしていて遅くなり、帰ってから慌ててスーパーに買いものへ行ったりしていて時間がなくなったので今日はバドミントン練習をお休み。&lt;/p>
&lt;h2 id="データベースとメッセージキューの整合性を考える">データベースとメッセージキューの整合性を考える&lt;/h2>
&lt;p>昨日の続き。トランザクションを導入したことで mongodb と mq でのデータフローが意図せず変わってしまっていることが調査してわかった。&lt;/p>
&lt;p>従来は次のように動いていた。&lt;/p>
&lt;ol>
&lt;li>api サーバーがエントリー情報を受け取る&lt;/li>
&lt;li>api ハンドラーがエントリー情報を mongodb に保存する&lt;/li>
&lt;li>api ハンドラーがメッセージを管理するジョブ情報を mongodb に保存する&lt;/li>
&lt;li>api ハンドラー内の producer が rabbitmq にメッセージを送信する&lt;/li>
&lt;li>consumer がメッセージを受信する&lt;/li>
&lt;li>consumer が mongodb からジョブ情報を参照する&lt;/li>
&lt;li>api ハンドラーがレスポンスを返す&lt;/li>
&lt;li>consumer がメッセージを処理する&lt;/li>
&lt;/ol>
&lt;p>トランザクションを導入したことで mongodb にデータが保存されるタイミングが変わってしまった。&lt;/p>
&lt;ol>
&lt;li>api サーバーがエントリー情報を受け取る&lt;/li>
&lt;li>api ハンドラーがトランザクションを開始する&lt;/li>
&lt;li>api ハンドラーがエントリー情報を mongodb に保存する (この時点では未コミット)&lt;/li>
&lt;li>api ハンドラーがメッセージを管理するジョブ情報を mongodb に保存する (この時点では未コミット)&lt;/li>
&lt;li>api ハンドラー内の producer が rabbitmq にメッセージを送信する&lt;/li>
&lt;li>consumer がメッセージを受信する&lt;/li>
&lt;li>consumer が mongodb からジョブ情報を参照するが、トランザクションがコミットされていない可能性がある&lt;/li>
&lt;li>api ハンドラーがトランザクションをコミットする&lt;/li>
&lt;li>api ハンドラーがレスポンスを返す&lt;/li>
&lt;li>consumer でエラーが発生する&lt;/li>
&lt;/ol>
&lt;p>処理の流れを見直して次のように改修した。内部実装の都合があってやや煩雑な変更となった。&lt;/p>
&lt;ol>
&lt;li>api サーバーがエントリー情報を受け取る&lt;/li>
&lt;li>api ハンドラーがトランザクションを開始する&lt;/li>
&lt;li>api ハンドラーがエントリー情報を mongodb に保存する (この時点では未コミット)&lt;/li>
&lt;li>api ハンドラーがメッセージを管理するジョブ情報を mongodb に保存する (この時点では未コミット)&lt;/li>
&lt;li>api ハンドラーがトランザクションをコミットする&lt;/li>
&lt;li>api ハンドラー内の producer が rabbitmq にメッセージを送信する&lt;/li>
&lt;li>consumer がメッセージを受信する&lt;/li>
&lt;li>consumer が mongodb からジョブ情報を参照する&lt;/li>
&lt;li>api ハンドラーがレスポンスを返す&lt;/li>
&lt;li>consumer がメッセージを処理する&lt;/li>
&lt;/ol>
&lt;p>これは単純にトランザクションのコミットタイミングと mq へのメッセージ送受信のタイミングを見直せばよいという話しではない。本質的に mongodb で管理しているジョブ情報と rabbitmq へ送信しているメッセージの整合性を保証することはできないということを表している。producer はメッセージ送信に失敗する可能性があるから、そのときにジョブ情報を書き換える必要はあるが、その前にトランザクションをコミットしてしまっているため、api ハンドラー内でデータのコミットタイミングが複数になってしまう。トランザクションを導入したメリットが失われてしまい、&lt;a href="https://en.wikipedia.org/wiki/Unit_of_work">Unit of work&lt;/a> のパターンも実現できない。consumer の処理に必要な情報を mongodb にあるデータとメッセージの2つに分割しているところが整合性の問題を引き起こしている。アーキテクチャ上の設計ミスと言える。consumer の処理に必要な情報はすべてメッセージに含めてしまい、メッセージを処理した後に mongodb に結果を書き込むといった設計にすべきだった。&lt;/p>
&lt;p>初期実装のときからジョブ情報を mongodb で管理する必要はあるのか？という懸念を私はもっていた。要件や機能が曖昧な状況でもあり、メンバーもなんとなく db に管理情報を残しておいた方が将来的な変更に対応できて安心といった理由だったと思う。当時は整合性の問題が起きることに、私が気付いていなかったためにこの設計を見直すように強く指摘できなかった。トランザクションを導入したことで consumer が必要な情報を db に保持すると、db とメッセージ処理のタイミングにおける整合性の問題が生じるという学びになった。&lt;/p>
&lt;p>いまとなってはこのジョブ情報を使う他の機能もあるため、この設計を見直すことはできない。今後の開発プロジェクトで db とメッセージを扱うときはこの経験を活かすためにふりかえりとして書いておく。&lt;/p></content></item><item><title>mongodb のトランザクション調査</title><link>/diary/posts/2024/1112/</link><pubDate>Tue, 12 Nov 2024 08:50:36 +0900</pubDate><guid>/diary/posts/2024/1112/</guid><description>今日のバドミントン練習はエアシャトルでリフティングを10分、連続最大回数は120回ほど、ショートサーブ30回した。フットワーク練習はお休み。筋肉痛もあったから、みなとのもり公園をジョギングで3周 1.4km、縄跳び15分で1712回だった。縄跳びも2ヶ月ぶり。8月に過去最高が1838回に対して、2ヶ月ぶりにやって2分弱の休憩、十数回のミスがあっても1700回を超えるんやと思って少し驚いた。8月に比べたらいまは涼しいから記録が伸びるのもある。ジョギングで足が筋肉痛になると走るよりも縄跳びの方が負担が小さい。昨日と同じように運動してストレッチして十分にカラダを動かした。
トランザクションとコールバック お仕事は昨日の続きでリクエスト途中のサービス終了したときに web api ハンドラーの処理が途中でキャンセルされ、そのために内部のデータが不整合になることがわかった。データを不整合にしないため mongodb のトランザクション の仕組みを調べてデバッグしたりしていた。echo のミドルウェアで Unit of work を実装できないかをプロトタイプ実装していた。
基本は次のように callback 関数を渡せばトランザクションに失敗したときにリトライもしてくれて便利なのだけど、いろいろ api サーバーの既存アーキテクチャの都合もあってこれは使えないことがわかった。
session, err := client.StartSession() if err != nil { return err } defer session.EndSession(ctx) result, err := session.WithTransaction(ctx, callback)</description><content>&lt;p>今日のバドミントン練習はエアシャトルでリフティングを10分、連続最大回数は120回ほど、ショートサーブ30回した。フットワーク練習はお休み。筋肉痛もあったから、みなとのもり公園をジョギングで3周 1.4km、縄跳び15分で1712回だった。縄跳びも2ヶ月ぶり。8月に過去最高が1838回に対して、2ヶ月ぶりにやって2分弱の休憩、十数回のミスがあっても1700回を超えるんやと思って少し驚いた。8月に比べたらいまは涼しいから記録が伸びるのもある。ジョギングで足が筋肉痛になると走るよりも縄跳びの方が負担が小さい。昨日と同じように運動してストレッチして十分にカラダを動かした。&lt;/p>
&lt;h2 id="トランザクションとコールバック">トランザクションとコールバック&lt;/h2>
&lt;p>お仕事は昨日の続きでリクエスト途中のサービス終了したときに web api ハンドラーの処理が途中でキャンセルされ、そのために内部のデータが不整合になることがわかった。データを不整合にしないため &lt;a href="https://www.mongodb.com/docs/manual/core/transactions/">mongodb のトランザクション&lt;/a> の仕組みを調べてデバッグしたりしていた。echo のミドルウェアで &lt;a href="https://en.wikipedia.org/wiki/Unit_of_work">Unit of work&lt;/a> を実装できないかをプロトタイプ実装していた。&lt;/p>
&lt;p>基本は次のように callback 関数を渡せばトランザクションに失敗したときにリトライもしてくれて便利なのだけど、いろいろ api サーバーの既存アーキテクチャの都合もあってこれは使えないことがわかった。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">session&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">client&lt;/span>.&lt;span style="color:#a6e22e">StartSession&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">defer&lt;/span> &lt;span style="color:#a6e22e">session&lt;/span>.&lt;span style="color:#a6e22e">EndSession&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">result&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">session&lt;/span>.&lt;span style="color:#a6e22e">WithTransaction&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span>, &lt;span style="color:#a6e22e">callback&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></content></item><item><title>ミドルウェアのコンテナの振る舞い検証</title><link>/diary/posts/2024/1107/</link><pubDate>Thu, 07 Nov 2024 12:28:46 +0900</pubDate><guid>/diary/posts/2024/1107/</guid><description>今日もバドミントン練習はお休み。
mongodb の healthcheck bitnami/mongodb というサードパーティのコンテナ を使って mongodb サービスを設定している。docker compose でコンテナサービスの依存関係を記述できるが、特別な設定をしないとコンテナサービスの起動をトリガーに依存関係を制御する。実際はコンテナが起動して内部のサーバー／デーモンが正常に起動するまで少し時間がかかる。たとえば mongodb のコンテナであれば mongod デーモンに初期設定をして再起動したりといった処理を内部的に行っている。そんなときに healthcheck を使うことで実際に mongod デーモンに接続できるかどうかでコンテナのサービス間の依存関係を制御できる。
これまで mongodb には healthcheck の設定をしていなかったので調査して次の設定を追加した。
healthcheck: test: mongosh &amp;#34;mongodb://localhost:37017/test?directConnection=false&amp;amp;replicaSet=${MONGO_REPLICA_SET}&amp;#34; --eval &amp;#39;db.runCommand(&amp;#34;ping&amp;#34;).ok&amp;#39; --quiet interval: 60s timeout: 5s retries: 3 start_period: 30s start_interval: 3s mongosh で db に接続して ping を実行するだけなら認証は必要ない。mongosh でなにもパラメーターを指定せずに接続すると direct 接続になってしまう。replica set の設定が完了していることを検証するために replica set 接続にしている。また interval は起動中もずっと死活監視に test コマンドを実行している。それとは別に start_interval を指定することでサービス開始時と通常の運用時の test コマンドによる制御をわけて管理できる。
rabbitmq のアップグレード 19時過ぎに業務終了報告をして、帰ろうと思ったときにふと rabbitmq のバージョンを最近あまり確認していないことに気付いた。いま 3.12.14 を使っているが、Release Information をみるとコミュニティサポートは切れていて、現行バージョンは 4.</description><content>&lt;p>今日もバドミントン練習はお休み。&lt;/p>
&lt;h2 id="mongodb-の-healthcheck">mongodb の healthcheck&lt;/h2>
&lt;p>&lt;a href="/diary/diary/posts/2023/1214/#コンテナを使ったレプリカセットの初期設定">bitnami/mongodb というサードパーティのコンテナ&lt;/a> を使って mongodb サービスを設定している。docker compose でコンテナサービスの依存関係を記述できるが、特別な設定をしないとコンテナサービスの起動をトリガーに依存関係を制御する。実際はコンテナが起動して内部のサーバー／デーモンが正常に起動するまで少し時間がかかる。たとえば mongodb のコンテナであれば mongod デーモンに初期設定をして再起動したりといった処理を内部的に行っている。そんなときに &lt;a href="https://docs.docker.com/reference/dockerfile/#healthcheck">healthcheck&lt;/a> を使うことで実際に mongod デーモンに接続できるかどうかでコンテナのサービス間の依存関係を制御できる。&lt;/p>
&lt;p>これまで mongodb には healthcheck の設定をしていなかったので調査して次の設定を追加した。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yml" data-lang="yml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">healthcheck&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">test&lt;/span>: &lt;span style="color:#ae81ff">mongosh &amp;#34;mongodb://localhost:37017/test?directConnection=false&amp;amp;replicaSet=${MONGO_REPLICA_SET}&amp;#34; --eval &amp;#39;db.runCommand(&amp;#34;ping&amp;#34;).ok&amp;#39; --quiet&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">interval&lt;/span>: &lt;span style="color:#ae81ff">60s&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">timeout&lt;/span>: &lt;span style="color:#ae81ff">5s&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">retries&lt;/span>: &lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">start_period&lt;/span>: &lt;span style="color:#ae81ff">30s&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">start_interval&lt;/span>: &lt;span style="color:#ae81ff">3s&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>mongosh で db に接続して ping を実行するだけなら認証は必要ない。mongosh でなにもパラメーターを指定せずに接続すると direct 接続になってしまう。replica set の設定が完了していることを検証するために replica set 接続にしている。また interval は起動中もずっと死活監視に test コマンドを実行している。それとは別に start_interval を指定することでサービス開始時と通常の運用時の test コマンドによる制御をわけて管理できる。&lt;/p>
&lt;h2 id="rabbitmq-のアップグレード">rabbitmq のアップグレード&lt;/h2>
&lt;p>19時過ぎに業務終了報告をして、帰ろうと思ったときにふと rabbitmq のバージョンを最近あまり確認していないことに気付いた。いま 3.12.14 を使っているが、&lt;a href="https://www.rabbitmq.com/release-information">Release Information&lt;/a> をみるとコミュニティサポートは切れていて、現行バージョンは 4.0 になっていることに気付いた。試しに結合テストの rabbitmq のバージョンを 4.0.3 に上げてみたところ、問題なく動作している。テスト環境の移行は他のメンバーが使っていない夜にやった方がいいかと帰ることをやめて普通に移行作業をやり始めてしまった。メッセージキューは永続化したデータを基本的には保持しないため、メジャーバージョンアップで互換性がなかったとしても volume 配下のデータを削除して exchange/queue を移行すればよい。&lt;/p>
&lt;p>rabbitmq の http api client として rabbit-hole というツールを使っている。それも v2 から v3 へアップグレードしていて &lt;a href="https://github.com/michaelklishin/rabbit-hole/releases/tag/v3.1.0">Changes Between 2.16.0 and 3.1.0 (Oct 31, 2024)&lt;/a> に書いてあるが、機能的な変更も非互換の変更もいまのところはないが、4.0 にあわせて将来的に非互換な変更をやりやすいよう、メジャーバージョンを上げると書いてある。go.mod の依存関係も更新したりした。&lt;/p>
&lt;p>19時過ぎに帰ろうと思ってから、なんやらかんやらしているうちに最終的には21時半まで作業していた。&lt;/p></content></item><item><title>飛行機での出張帰り</title><link>/diary/posts/2024/1024/</link><pubDate>Thu, 24 Oct 2024 13:02:46 +0900</pubDate><guid>/diary/posts/2024/1024/</guid><description>夜に神戸に戻ってきてからオフィスに来て、機内でやっていた作業を区切りのよいところまで進めてコミットしたりしていた。その後スーパーへ買いものへ行ったりしていた。今日もバドミントン練習はおやすみ。
ローカルは standalone mongodb mongodb の レプリケーション 機能を使っていて、replica set の設定が容易なことから bitnami/mongodb というコンテナを使っている。これまで結合テストもレプリケーション機能を設定して実行するようにしていた。結合テストの量が増えてきたのもあって実行時間が徐々に遅くなってきた。いまテストのリファクタリングをしているため、ローカルで検証のために何度も実行する必要がある。コードの品質を上げるためにテストを書きやすくする必要がある。実行時間は短いほどよい。そこでローカルでの実行はレプリケーションを設定しないようにしてみた。さらに go のデータ競合を検知する -race オプションも外してテストを実行してみたところ、この2つの改善で macbook の環境で改善前より45%ほど速くなった。十分な高速化を図れた。
飛行機ルートのふりかえり 8月に大雨で新幹線が止まってしまい 神戸に帰れない状況 に直面した。私はほとんど飛行機に乗ったことがなかったため、新幹線が動かないときの迂回手段として飛行機のルートに慣れておく。普段リュックサックに小さいカッターとマイナスドライバーを携帯している。これらは飛行機の手荷物検査でとめられてしまう。荷物を預けるか、検査場で処分してもらうしかない。前回は ANA で帰ってきたが、今回は スカイマーク の飛行機に乗った。値段が安いから LCC だと思っていたら スカイマークは安くて快適なMCC らしい。ANA に比べたらずっと小さい飛行機だった。
タイムスケジュールは次のようになった。
18:15 (都営浅草線) 五反田 発 18:56 (京急本線) 羽田空港 着 19:45 搭乗開始 19:55 飛行機の座席に着く 20:08 羽田空港の滑走路を発進 20:20 離陸 (機内は暗かった、ラップトップで作業) 21:16 神戸空港の滑走路に着陸 21:22 降機 21:25 空港内の荷物受け取り場に着く 21:30 荷物を受け取り 21:35 (ポートライナー) 神戸空港 発 21:51 (ポートライナー) 貿易センター 着 新幹線だと次のようなタイムスケジュールになる。トータルの時間でみれば新幹線の方が20-30分早いかなといったところ。一方で新幹線だと2時間半、同じ姿勢で座っている必要がある。飛行機だと座っている時間は1時間強。飛行機は搭乗手続きのチェックポイントがいくつかあってそれぞれに細かい待ち時間ができてしまうのが気になる。そのときの体調によってもどちらがよいかは変わってくるかもしれない。来月は行きは飛行機、帰りは新幹線にしてみる。
17:57 (JR) 五反田 発 18:03 (JR) 品川 着 18:19 (新幹線) 品川 発 20:53 (新幹線) 新神戸 着 21:10 (市営地下鉄) 新神戸 21:12 (市営地下鉄) 三宮</description><content>&lt;p>夜に神戸に戻ってきてからオフィスに来て、機内でやっていた作業を区切りのよいところまで進めてコミットしたりしていた。その後スーパーへ買いものへ行ったりしていた。今日もバドミントン練習はおやすみ。&lt;/p>
&lt;h2 id="ローカルは-standalone-mongodb">ローカルは standalone mongodb&lt;/h2>
&lt;p>mongodb の &lt;a href="https://www.mongodb.com/docs/manual/replication/">レプリケーション&lt;/a> 機能を使っていて、replica set の設定が容易なことから &lt;a href="https://hub.docker.com/r/bitnami/mongodb">bitnami/mongodb&lt;/a> というコンテナを使っている。これまで結合テストもレプリケーション機能を設定して実行するようにしていた。結合テストの量が増えてきたのもあって実行時間が徐々に遅くなってきた。いまテストのリファクタリングをしているため、ローカルで検証のために何度も実行する必要がある。コードの品質を上げるためにテストを書きやすくする必要がある。実行時間は短いほどよい。そこでローカルでの実行はレプリケーションを設定しないようにしてみた。さらに go のデータ競合を検知する &lt;code>-race&lt;/code> オプションも外してテストを実行してみたところ、この2つの改善で macbook の環境で改善前より45%ほど速くなった。十分な高速化を図れた。&lt;/p>
&lt;h2 id="飛行機ルートのふりかえり">飛行機ルートのふりかえり&lt;/h2>
&lt;p>8月に大雨で新幹線が止まってしまい &lt;a href="/diary/diary/posts/2024/0829/">神戸に帰れない状況&lt;/a> に直面した。私はほとんど飛行機に乗ったことがなかったため、新幹線が動かないときの迂回手段として飛行機のルートに慣れておく。普段リュックサックに小さいカッターとマイナスドライバーを携帯している。これらは飛行機の手荷物検査でとめられてしまう。荷物を預けるか、検査場で処分してもらうしかない。前回は ANA で帰ってきたが、今回は &lt;a href="https://www.skymark.co.jp/ja/">スカイマーク&lt;/a> の飛行機に乗った。値段が安いから LCC だと思っていたら &lt;a href="https://japantour.airtrip.jp/column/magazine/skymark-why-popularity-goodvalue/">スカイマークは安くて快適なMCC&lt;/a> らしい。ANA に比べたらずっと小さい飛行機だった。&lt;/p>
&lt;p>タイムスケジュールは次のようになった。&lt;/p>
&lt;pre tabindex="0">&lt;code>18:15 (都営浅草線) 五反田 発
18:56 (京急本線) 羽田空港 着
19:45 搭乗開始
19:55 飛行機の座席に着く
20:08 羽田空港の滑走路を発進
20:20 離陸
(機内は暗かった、ラップトップで作業)
21:16 神戸空港の滑走路に着陸
21:22 降機
21:25 空港内の荷物受け取り場に着く
21:30 荷物を受け取り
21:35 (ポートライナー) 神戸空港 発
21:51 (ポートライナー) 貿易センター 着
&lt;/code>&lt;/pre>&lt;p>新幹線だと次のようなタイムスケジュールになる。トータルの時間でみれば新幹線の方が20-30分早いかなといったところ。一方で新幹線だと2時間半、同じ姿勢で座っている必要がある。飛行機だと座っている時間は1時間強。飛行機は搭乗手続きのチェックポイントがいくつかあってそれぞれに細かい待ち時間ができてしまうのが気になる。そのときの体調によってもどちらがよいかは変わってくるかもしれない。来月は行きは飛行機、帰りは新幹線にしてみる。&lt;/p>
&lt;pre tabindex="0">&lt;code>17:57 (JR) 五反田 発
18:03 (JR) 品川 着
18:19 (新幹線) 品川 発
20:53 (新幹線) 新神戸 着
21:10 (市営地下鉄) 新神戸
21:12 (市営地下鉄) 三宮
&lt;/code>&lt;/pre></content></item><item><title>mongodb のテストデータ管理</title><link>/diary/posts/2024/1015/</link><pubDate>Tue, 15 Oct 2024 08:52:01 +0900</pubDate><guid>/diary/posts/2024/1015/</guid><description>今日のバドミントン練習はエアシャトルでリフティングを45分した。連続最大回数は146回できた。調子は悪くなく安定的に30回前後は続くものの、50回を超えたぐらいで失敗してしまう。打ち上げる高さの違いかな？と気付いて少し高めに打ち上げるようにしたら100回を超えた。エアシャトルはラケット面に対して適切な角度でコルクを打たないとあらぬ方向に飛んでいってしまう。高く打ち上げるほど、重力で落ちてくるときにコルクが下を向きやすくなるため、うまくシャトルを打ち上げやすくなる。ラケットコントロールをうまくできれば、エアシャトルをより低い高さでリフティングできるようになるかもしれない。まだ私はそのレベルには満たない。
json からの mongodb にテストデータを追加する 結合テストの改善をしていてテストデータを json で管理したい。これまで go の構造体でテストデータを定義して mongodb の client で insert するといったことをしていた。それも役に立つのだけど、共有のテストデータがどこにあるのか、ソースコードに書いてしまうと時間とともに散らばっていって把握できなくなっていく。テストデータを管理するためのディレクトリを設け、そこに json で記述してどのテスト関数で使うかといったメタ情報も定義できるようにした。次のコードは mongodb に json からデータをインポートするための原理を説明するための疑似コードのようなもの。
go の構造体で定義したテストデータと json で管理するのとどちらがよいかというのは議論の余地はあるし、一概に言えないとは思う。
type testData struct { Documents []bson.Raw `bson:&amp;#34;documents&amp;#34;` } func InsertData( t *testing.T, client *mongo.Client, b []byte, ) (func()) { var data testData err := bson.UnmarshalExtJSON(b, false, &amp;amp;data) require.NoError(t, err, &amp;#34;failed to get json files: %v&amp;#34;, err) ctx := context.Background() col := client.Database(dbName).Collection(&amp;#34;mycollection&amp;#34;) r, err := col.</description><content>&lt;p>今日のバドミントン練習はエアシャトルでリフティングを45分した。連続最大回数は146回できた。調子は悪くなく安定的に30回前後は続くものの、50回を超えたぐらいで失敗してしまう。打ち上げる高さの違いかな？と気付いて少し高めに打ち上げるようにしたら100回を超えた。エアシャトルはラケット面に対して適切な角度でコルクを打たないとあらぬ方向に飛んでいってしまう。高く打ち上げるほど、重力で落ちてくるときにコルクが下を向きやすくなるため、うまくシャトルを打ち上げやすくなる。ラケットコントロールをうまくできれば、エアシャトルをより低い高さでリフティングできるようになるかもしれない。まだ私はそのレベルには満たない。&lt;/p>
&lt;h2 id="json-からの-mongodb-にテストデータを追加する">json からの mongodb にテストデータを追加する&lt;/h2>
&lt;p>結合テストの改善をしていてテストデータを json で管理したい。これまで go の構造体でテストデータを定義して mongodb の client で insert するといったことをしていた。それも役に立つのだけど、共有のテストデータがどこにあるのか、ソースコードに書いてしまうと時間とともに散らばっていって把握できなくなっていく。テストデータを管理するためのディレクトリを設け、そこに json で記述してどのテスト関数で使うかといったメタ情報も定義できるようにした。次のコードは mongodb に json からデータをインポートするための原理を説明するための疑似コードのようなもの。&lt;/p>
&lt;p>go の構造体で定義したテストデータと json で管理するのとどちらがよいかというのは議論の余地はあるし、一概に言えないとは思う。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">testData&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Documents&lt;/span> []&lt;span style="color:#a6e22e">bson&lt;/span>.&lt;span style="color:#a6e22e">Raw&lt;/span> &lt;span style="color:#e6db74">`bson:&amp;#34;documents&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">InsertData&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">testing&lt;/span>.&lt;span style="color:#a6e22e">T&lt;/span>, &lt;span style="color:#a6e22e">client&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">mongo&lt;/span>.&lt;span style="color:#a6e22e">Client&lt;/span>, &lt;span style="color:#a6e22e">b&lt;/span> []&lt;span style="color:#66d9ef">byte&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) (&lt;span style="color:#66d9ef">func&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">data&lt;/span> &lt;span style="color:#a6e22e">testData&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">bson&lt;/span>.&lt;span style="color:#a6e22e">UnmarshalExtJSON&lt;/span>(&lt;span style="color:#a6e22e">b&lt;/span>, &lt;span style="color:#66d9ef">false&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">data&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">require&lt;/span>.&lt;span style="color:#a6e22e">NoError&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;failed to get json files: %v&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ctx&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Background&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">col&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">client&lt;/span>.&lt;span style="color:#a6e22e">Database&lt;/span>(&lt;span style="color:#a6e22e">dbName&lt;/span>).&lt;span style="color:#a6e22e">Collection&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;mycollection&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">r&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">col&lt;/span>.&lt;span style="color:#a6e22e">InsertMany&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span>, &lt;span style="color:#a6e22e">docsToInterfaces&lt;/span>(&lt;span style="color:#a6e22e">data&lt;/span>.&lt;span style="color:#a6e22e">Documents&lt;/span>&lt;span style="color:#f92672">...&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">require&lt;/span>.&lt;span style="color:#a6e22e">NoError&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;failed to insert: %v&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">insertResult&lt;/span>, &lt;span style="color:#66d9ef">func&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">Helper&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">col&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">client&lt;/span>.&lt;span style="color:#a6e22e">Database&lt;/span>(&lt;span style="color:#a6e22e">dbName&lt;/span>).&lt;span style="color:#a6e22e">Collection&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;mycollection&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">id&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">InsertedIDs&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">filter&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">bson&lt;/span>.&lt;span style="color:#a6e22e">D&lt;/span>{{&lt;span style="color:#a6e22e">Key&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;_id&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">Value&lt;/span>: &lt;span style="color:#a6e22e">id&lt;/span>}}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">col&lt;/span>.&lt;span style="color:#a6e22e">DeleteOne&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span>, &lt;span style="color:#a6e22e">filter&lt;/span>); &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">t&lt;/span>.&lt;span style="color:#a6e22e">Errorf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;failed to delete %s: %v&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">id&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>呼び出し側のイメージ。defer で teardown を呼ぶことでテスト完了時に追加したテストデータを削除してくれる。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">teardown&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">mongotest&lt;/span>.&lt;span style="color:#a6e22e">InsertData&lt;/span>(&lt;span style="color:#a6e22e">t&lt;/span>, &lt;span style="color:#a6e22e">mongoClient&lt;/span>, &lt;span style="color:#a6e22e">b&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">defer&lt;/span> &lt;span style="color:#a6e22e">teardown&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">...&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>bson.Raw として読み込める json データは bson パッケージのユーティリティを使って dump できる。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">dumpAsJSON&lt;/span>(&lt;span style="color:#a6e22e">value&lt;/span> &lt;span style="color:#a6e22e">any&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">b&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">bson&lt;/span>.&lt;span style="color:#a6e22e">MarshalExtJSON&lt;/span>(&lt;span style="color:#a6e22e">value&lt;/span>, &lt;span style="color:#66d9ef">false&lt;/span>, &lt;span style="color:#66d9ef">false&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">slog&lt;/span>.&lt;span style="color:#a6e22e">Error&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;failed to marshal as extended JSON&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;err&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(string(&lt;span style="color:#a6e22e">b&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></content></item><item><title>go の iterator 実装へのリファクタリング</title><link>/diary/posts/2024/0816/</link><pubDate>Fri, 16 Aug 2024 13:40:48 +0900</pubDate><guid>/diary/posts/2024/0816/</guid><description>mongo-go-driver を使った go の iterator 実装 先日 go 1.23 がリリースされた。このバージョンの目玉機能の1つに range-over function iterators がある。簡潔に言えば、ユーザー定義のイテレーターを言語機能の仕組みを使って簡単に実装できる。ある制約を満たして関数を実装すれば、for 文の range 構文を使ってイテレーターとして扱える。ユーザー定義のイテレーターを実装するのが、ほとんど関数を実装するだけで出来てしまうので実装の難易度が減ったと言える。どんなコードかをみるには次のチュートリアルがわかりやすいと思う。
Go 1.23リリース連載 range over funcとiterパッケージ 昨日で私が抱えていたプロジェクトのボトルネックを解消できた。ここからはボーナスステージで相対的に自由に開発できる。手始めにプロダクトの依存バージョンを go 1.23 へアップグレードして mongodb からの fetch 処理をイテレーターに置き換えるリファクタリングをした。アプリケーションからみたら mongodb は Store という generic なインターフェースを定義していて、そこに Iter() メソッドを追加した。mongodb のコレクションは必ず Iter() メソッドを実装しなければいけないという制約を課す。
type Store[T any] interface { ... Iter(ctx context.Context, query query.Query, opt *sort.Option) iter.Seq2[*T, error] } mongo-go-driver はもともと cursor でイテレーター機能を提供しているため、これを range-over function iterators を使ってアプリケーションから使えるように間をつなげてあげればよい。具体的には generics を使って次のような汎用の iter() メソッドを mongodb client に実装する。</description><content>&lt;h2 id="mongo-go-driver-を使った-go-の-iterator-実装">mongo-go-driver を使った go の iterator 実装&lt;/h2>
&lt;p>先日 &lt;a href="https://go.dev/blog/go1.23">go 1.23&lt;/a> がリリースされた。このバージョンの目玉機能の1つに &lt;a href="https://go.dev/wiki/RangefuncExperiment">range-over function iterators&lt;/a> がある。簡潔に言えば、ユーザー定義のイテレーターを言語機能の仕組みを使って簡単に実装できる。ある制約を満たして関数を実装すれば、for 文の range 構文を使ってイテレーターとして扱える。ユーザー定義のイテレーターを実装するのが、ほとんど関数を実装するだけで出来てしまうので実装の難易度が減ったと言える。どんなコードかをみるには次のチュートリアルがわかりやすいと思う。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://future-architect.github.io/articles/20240718a/">Go 1.23リリース連載 range over funcとiterパッケージ&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>昨日で私が抱えていたプロジェクトのボトルネックを解消できた。ここからはボーナスステージで相対的に自由に開発できる。手始めにプロダクトの依存バージョンを go 1.23 へアップグレードして mongodb からの fetch 処理をイテレーターに置き換えるリファクタリングをした。アプリケーションからみたら mongodb は Store という generic なインターフェースを定義していて、そこに Iter() メソッドを追加した。mongodb のコレクションは必ず Iter() メソッドを実装しなければいけないという制約を課す。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Store&lt;/span>[&lt;span style="color:#a6e22e">T&lt;/span> &lt;span style="color:#a6e22e">any&lt;/span>] &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Iter&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span> &lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#a6e22e">query&lt;/span> &lt;span style="color:#a6e22e">query&lt;/span>.&lt;span style="color:#a6e22e">Query&lt;/span>, &lt;span style="color:#a6e22e">opt&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">sort&lt;/span>.&lt;span style="color:#a6e22e">Option&lt;/span>) &lt;span style="color:#a6e22e">iter&lt;/span>.&lt;span style="color:#a6e22e">Seq2&lt;/span>[&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">T&lt;/span>, &lt;span style="color:#66d9ef">error&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://github.com/mongodb/mongo-go-driver">mongo-go-driver&lt;/a> はもともと cursor でイテレーター機能を提供しているため、これを range-over function iterators を使ってアプリケーションから使えるように間をつなげてあげればよい。具体的には generics を使って次のような汎用の iter() メソッドを mongodb client に実装する。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">c&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">client&lt;/span>[&lt;span style="color:#a6e22e">R&lt;/span>, &lt;span style="color:#a6e22e">E&lt;/span>]) &lt;span style="color:#a6e22e">iter&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ctx&lt;/span> &lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#a6e22e">name&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">filters&lt;/span> &lt;span style="color:#a6e22e">queryFilters&lt;/span>, &lt;span style="color:#a6e22e">sortOpt&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">sort&lt;/span>.&lt;span style="color:#a6e22e">Option&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) &lt;span style="color:#a6e22e">iter&lt;/span>.&lt;span style="color:#a6e22e">Seq2&lt;/span>[&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">E&lt;/span>, &lt;span style="color:#66d9ef">error&lt;/span>] {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">toEntity&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> panic(&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Errorf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;require toEntity() function&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">func&lt;/span>(&lt;span style="color:#a6e22e">yield&lt;/span> &lt;span style="color:#66d9ef">func&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">E&lt;/span>, &lt;span style="color:#66d9ef">error&lt;/span>) &lt;span style="color:#66d9ef">bool&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">collection&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">raw&lt;/span>.&lt;span style="color:#a6e22e">Database&lt;/span>(&lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">db&lt;/span>).&lt;span style="color:#a6e22e">Collection&lt;/span>(&lt;span style="color:#a6e22e">name&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">opts&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> []&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">options&lt;/span>.&lt;span style="color:#a6e22e">FindOptions&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">sortOpt&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">opt&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">options&lt;/span>.&lt;span style="color:#a6e22e">Find&lt;/span>().&lt;span style="color:#a6e22e">SetSort&lt;/span>(&lt;span style="color:#a6e22e">makeSortSet&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">sortOpt&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">opts&lt;/span> = append(&lt;span style="color:#a6e22e">opts&lt;/span>, &lt;span style="color:#a6e22e">opt&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">cursor&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">collection&lt;/span>.&lt;span style="color:#a6e22e">Find&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span>, &lt;span style="color:#a6e22e">filters&lt;/span>, &lt;span style="color:#a6e22e">opts&lt;/span>&lt;span style="color:#f92672">...&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> !&lt;span style="color:#a6e22e">yield&lt;/span>(&lt;span style="color:#66d9ef">nil&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">defer&lt;/span> &lt;span style="color:#a6e22e">cursor&lt;/span>.&lt;span style="color:#a6e22e">Close&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">cursor&lt;/span>.&lt;span style="color:#a6e22e">Next&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">result&lt;/span> &lt;span style="color:#a6e22e">R&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">cursor&lt;/span>.&lt;span style="color:#a6e22e">Decode&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">result&lt;/span>); &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> !&lt;span style="color:#a6e22e">yield&lt;/span>(&lt;span style="color:#66d9ef">nil&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> !&lt;span style="color:#a6e22e">yield&lt;/span>(&lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">toEntity&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">result&lt;/span>), &lt;span style="color:#66d9ef">nil&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">cursor&lt;/span>.&lt;span style="color:#a6e22e">Err&lt;/span>(); &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> !&lt;span style="color:#a6e22e">yield&lt;/span>(&lt;span style="color:#66d9ef">nil&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Store インターフェースを満たすコレクションの実装は次のように型チェックのためのメソッド実装をもてばよい。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">c&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">MyCollection&lt;/span>) &lt;span style="color:#a6e22e">Iter&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ctx&lt;/span> &lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#a6e22e">query&lt;/span> &lt;span style="color:#a6e22e">query&lt;/span>.&lt;span style="color:#a6e22e">Query&lt;/span>, &lt;span style="color:#a6e22e">opts&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">sort&lt;/span>.&lt;span style="color:#a6e22e">Option&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) &lt;span style="color:#a6e22e">iter&lt;/span>.&lt;span style="color:#a6e22e">Seq2&lt;/span>[&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">entry&lt;/span>.&lt;span style="color:#a6e22e">MyEntity&lt;/span>, &lt;span style="color:#66d9ef">error&lt;/span>] {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">iter&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span>, &lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">name&lt;/span>, &lt;span style="color:#a6e22e">makeFilters&lt;/span>(&lt;span style="color:#a6e22e">query&lt;/span>), &lt;span style="color:#a6e22e">opts&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>朝から iterator 実装の試行錯誤や使い方の勘どころを確かめながら、これも1日でほとんどリファクタリングして移行できた。python のジェネレーターもそうだけど、関数をイテレーターにできると直感的にわかりやすく簡潔に実装できる。すごくよい機能だと思う。1.23 以降の go のコードはイテレーターを使うよう、大きく変わっていくと思われる。&lt;/p></content></item><item><title>mongodb も一応は外部結合できる</title><link>/diary/posts/2024/0803/</link><pubDate>Sat, 03 Aug 2024 13:31:13 +0900</pubDate><guid>/diary/posts/2024/0803/</guid><description>今日は出張中にたまっていた日記をまとめて書いていた。昨日筋トレしたから運動はおやすみ。
mongodb における外部結合 出張中のふりかえりやプロジェクトマネジメントの合間に mongodb の $lookup (aggregation) 機能を調査していた。一言で言えば、rdbms で言うところの外部結合 (join) を mongodb で実現する機能と言える。しかし、aggregation の機能として実装されていることから rdbms の外部結合とはパフォーマンスの側面で大きく違うのでは？と推測する。mongodb のような kvs では基本的に外部結合のようなことは行わず、結合済みのコレクションを定義するやり方がプラクティスとされる。一方で整合性を保証するには外部結合は有効なデザインパターンの1つなので使いたい場面があってもおかしくない。実際に mongodb に $lookup が実装されているのだから、そのニーズは大きいのだと思われる。
ちょうどいまやっている開発でその要件があったので mongo-go-driver の次のチュートリアルをみながら実装してみた。
Quick Start: Golang &amp;amp; MongoDB - Data Aggregation Pipeline 例えば、次のような2つのコレクションがある。
type Group struct { ID string `bson:&amp;#34;_id&amp;#34;` Name string `bson:&amp;#34;name&amp;#34;` UpdatedAt time.Time `bson:&amp;#34;updatedAt&amp;#34;` } type MyData struct { ID string `bson:&amp;#34;_id&amp;#34;` GroupID string `bson:&amp;#34;groupID&amp;#34;` RegisteredAt time.Time `bson:&amp;#34;registeredAt&amp;#34;` } MyData の GroupID フィールドが Group コレクションの ID を保持して外部参照している。MyData コレクションに対する aggregate に渡すパラメーターとして pipeline を渡す。</description><content>&lt;p>今日は出張中にたまっていた日記をまとめて書いていた。昨日筋トレしたから運動はおやすみ。&lt;/p>
&lt;h2 id="mongodb-における外部結合">mongodb における外部結合&lt;/h2>
&lt;p>出張中のふりかえりやプロジェクトマネジメントの合間に mongodb の &lt;a href="https://www.mongodb.com/docs/manual/reference/operator/aggregation/lookup/">$lookup (aggregation)&lt;/a> 機能を調査していた。一言で言えば、rdbms で言うところの外部結合 (join) を mongodb で実現する機能と言える。しかし、aggregation の機能として実装されていることから rdbms の外部結合とはパフォーマンスの側面で大きく違うのでは？と推測する。mongodb のような kvs では基本的に外部結合のようなことは行わず、結合済みのコレクションを定義するやり方がプラクティスとされる。一方で整合性を保証するには外部結合は有効なデザインパターンの1つなので使いたい場面があってもおかしくない。実際に mongodb に $lookup が実装されているのだから、そのニーズは大きいのだと思われる。&lt;/p>
&lt;p>ちょうどいまやっている開発でその要件があったので &lt;a href="https://github.com/mongodb/mongo-go-driver">mongo-go-driver&lt;/a> の次のチュートリアルをみながら実装してみた。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.mongodb.com/blog/post/quick-start-golang--mongodb--data-aggregation-pipeline">Quick Start: Golang &amp;amp; MongoDB - Data Aggregation Pipeline&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>例えば、次のような2つのコレクションがある。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Group&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ID&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#e6db74">`bson:&amp;#34;_id&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Name&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#e6db74">`bson:&amp;#34;name&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">UpdatedAt&lt;/span> &lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Time&lt;/span> &lt;span style="color:#e6db74">`bson:&amp;#34;updatedAt&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">MyData&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ID&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#e6db74">`bson:&amp;#34;_id&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">GroupID&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#e6db74">`bson:&amp;#34;groupID&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">RegisteredAt&lt;/span> &lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Time&lt;/span> &lt;span style="color:#e6db74">`bson:&amp;#34;registeredAt&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>MyData の GroupID フィールドが Group コレクションの ID を保持して外部参照している。MyData コレクションに対する aggregate に渡すパラメーターとして pipeline を渡す。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">myPipeline&lt;/span> = &lt;span style="color:#a6e22e">mongo&lt;/span>.&lt;span style="color:#a6e22e">Pipeline&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Key&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;$lookup&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">Value&lt;/span>: &lt;span style="color:#a6e22e">bson&lt;/span>.&lt;span style="color:#a6e22e">D&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#a6e22e">Key&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;from&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">Value&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;group&amp;#34;&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#a6e22e">Key&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;localField&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">Value&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;groupID&amp;#34;&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#a6e22e">Key&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;foreignField&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">Value&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;_id&amp;#34;&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#a6e22e">Key&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;as&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">Value&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;foreignGroup&amp;#34;&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Key&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;$unwind&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">Value&lt;/span>: &lt;span style="color:#a6e22e">bson&lt;/span>.&lt;span style="color:#a6e22e">D&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#a6e22e">Key&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;path&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">Value&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;$foreignGroup&amp;#34;&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#a6e22e">Key&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;preserveNullAndEmptyArrays&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">Value&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>$lookup の操作の後に $unwind で配列を flatten する処理がセットになる。result set にマッピングするためには flatten が必要になるのだと推測する。aggregate() を呼び出すと cursor が返ってきて、その cursor に外部結合される値の配列を渡すことで result set を取得できる。デバッグはややこしいし、コード上もちょっとわかりにくいけど、これは mongodb のお作法だと割り切ってユーティリティ化してしまえばよいものだと思う。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">joinedMyData&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ID&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#e6db74">`bson:&amp;#34;_id&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Group&lt;/span> &lt;span style="color:#a6e22e">Group&lt;/span> &lt;span style="color:#e6db74">`bson:&amp;#34;foreignGroup&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">RegisteredAt&lt;/span> &lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Time&lt;/span> &lt;span style="color:#e6db74">`bson:&amp;#34;registeredAt&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">cursor&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">collection&lt;/span>.&lt;span style="color:#a6e22e">Aggregate&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span>, &lt;span style="color:#a6e22e">myPipeline&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">joined&lt;/span> []&lt;span style="color:#a6e22e">joinedMember&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> = &lt;span style="color:#a6e22e">cursor&lt;/span>.&lt;span style="color:#a6e22e">All&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">joined&lt;/span>); &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>また時間があるときにある程度のデータ量でどのぐらいの負荷に対してパフォーマンスが出るのかを測ってみたい。&lt;/p>
&lt;h2 id="ストレッチ">ストレッチ&lt;/h2>
&lt;p>昨日1週間ぶりに筋トレをしたせいか、今朝から筋肉痛になっていてカラダが痛い。その影響もあって今日の開脚幅は開始前146cmで、ストレッチ後152cmとカラダが硬かった。足も腰も肩周りも全身にわたって軽い筋肉痛だった。それだけよい感じの負荷をかけて筋トレができていたと言えるのかもしれない。あちこち筋肉痛はあったものの、ストレッチを受けていての辛さのようなものは感じなかった。ちょうどよい感じにほぐされているような印象を受けた。もしかしたらトレーナーさんが気を遣っていつもよりは弱めにストレッチしてくれたのかもしれない。トレーナーさんが立候補していた店長選挙は落選してしまったらしい。もし店長になったらよそのお店へ転勤になって担当者が変わってしまうのかなとも思っていた。トレーナーさんは私が通っているお店の副店長を務める方向で調整しているらしい。待遇をあげていくにはキャリアアップをしていかないといけないといった背景もあるようにみえる。&lt;/p></content></item><item><title>mongodb のデータ移行のあれこれ</title><link>/diary/posts/2024/0423/</link><pubDate>Tue, 23 Apr 2024 08:29:51 +0900</pubDate><guid>/diary/posts/2024/0423/</guid><description>昨日の夜に縄跳びに出掛けようと思ったところ、雨がパラパラしてきて諦めた。今週は天気が悪いからあまり外で運動できないかもしれない。
今日の運動は腕立て,スクワットをした。統計を 運動の記録 にまとめる。
mongosh でデータ移行 あるコレクションのデータ構造を変更したので既存データを移行しないといけない。mongosh を使うと javascript っぽい文法で repl から mongodb のデータを操作できる。私は sql を書く方が好みだけど、慣れの問題で mongosh はプログラミングに近い形でオブジェクトを操作してデータを更新できる。例えば、history というコレクションを3件だけ取得して1件ずつ dump するコードは次のようになる。
&amp;gt; db.history.find().limit(3).forEach(function(i) {console.log(i)}) なにかしら関数内で処理した結果を用いて更新しないといけないようなときに forEach を使うと簡単にデータ移行できる。しかし、これは1件ずつ更新を実行するので時間はかかる。余談だけど、mongosh をリモートから接続すると forEach で取得するデータをローカルに fetch してくるので document のサイズに比例してデータの取得分の時間だけ遅くなる。forEach を使うときは ssh で mongodb のサーバーにログインして、そこで mongosh を起動した方が効率よくデータ移行できる。
compose 環境の mongodb に direct 接続するときはこんな感じ。
$ docker compose exec -it mongo mongosh &amp;#34;mongodb://${USER}:${PASSWORD}@localhost:27017/?authMechanism=DEFAULT&amp;amp;directConnection=true&amp;#34; シンプルな条件で更新できるようなときは updateMany を使ってバッチ更新すると1件ずつ更新するよりめちゃくちゃ速い。私の環境では270万件ほど更新するのが数分で完了した。仮想マシン上のコンテナ環境なので実機だったらもっと速いはず。
&amp;gt; db.history.updateMany({type:null}, {$set:{type:&amp;#34;myType&amp;#34;}}, {})</description><content>&lt;p>昨日の夜に縄跳びに出掛けようと思ったところ、雨がパラパラしてきて諦めた。今週は天気が悪いからあまり外で運動できないかもしれない。&lt;/p>
&lt;p>今日の運動は腕立て,スクワットをした。統計を &lt;a href="https://docs.google.com/spreadsheets/d/1bg85QtM-LciUgey8I79uI7vW2PEwsP6TVdeIRVkACBg/edit?usp=sharing">運動の記録&lt;/a> にまとめる。&lt;/p>
&lt;h2 id="mongosh-でデータ移行">mongosh でデータ移行&lt;/h2>
&lt;p>あるコレクションのデータ構造を変更したので既存データを移行しないといけない。&lt;a href="https://www.mongodb.com/docs/mongodb-shell/">mongosh&lt;/a> を使うと javascript っぽい文法で repl から mongodb のデータを操作できる。私は sql を書く方が好みだけど、慣れの問題で mongosh はプログラミングに近い形でオブジェクトを操作してデータを更新できる。例えば、history というコレクションを3件だけ取得して1件ずつ dump するコードは次のようになる。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">db&lt;/span>.&lt;span style="color:#a6e22e">history&lt;/span>.&lt;span style="color:#a6e22e">find&lt;/span>().&lt;span style="color:#a6e22e">limit&lt;/span>(&lt;span style="color:#ae81ff">3&lt;/span>).&lt;span style="color:#a6e22e">forEach&lt;/span>(&lt;span style="color:#66d9ef">function&lt;/span>(&lt;span style="color:#a6e22e">i&lt;/span>) {&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">i&lt;/span>)})
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>なにかしら関数内で処理した結果を用いて更新しないといけないようなときに forEach を使うと簡単にデータ移行できる。しかし、これは1件ずつ更新を実行するので時間はかかる。余談だけど、mongosh をリモートから接続すると forEach で取得するデータをローカルに fetch してくるので document のサイズに比例してデータの取得分の時間だけ遅くなる。forEach を使うときは ssh で mongodb のサーバーにログインして、そこで mongosh を起動した方が効率よくデータ移行できる。&lt;/p>
&lt;p>compose 環境の mongodb に direct 接続するときはこんな感じ。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ docker compose exec -it mongo mongosh &lt;span style="color:#e6db74">&amp;#34;mongodb://&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>USER&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">:&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>PASSWORD&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">@localhost:27017/?authMechanism=DEFAULT&amp;amp;directConnection=true&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>シンプルな条件で更新できるようなときは updateMany を使ってバッチ更新すると1件ずつ更新するよりめちゃくちゃ速い。私の環境では270万件ほど更新するのが数分で完了した。仮想マシン上のコンテナ環境なので実機だったらもっと速いはず。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">db&lt;/span>.&lt;span style="color:#a6e22e">history&lt;/span>.&lt;span style="color:#a6e22e">updateMany&lt;/span>({&lt;span style="color:#a6e22e">type&lt;/span>&lt;span style="color:#f92672">:&lt;/span>&lt;span style="color:#66d9ef">null&lt;/span>}, {&lt;span style="color:#a6e22e">$set&lt;/span>&lt;span style="color:#f92672">:&lt;/span>{&lt;span style="color:#a6e22e">type&lt;/span>&lt;span style="color:#f92672">:&lt;/span>&lt;span style="color:#e6db74">&amp;#34;myType&amp;#34;&lt;/span>}}, {})
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></content></item><item><title>主キーの特性</title><link>/diary/posts/2024/0418/</link><pubDate>Thu, 18 Apr 2024 08:47:52 +0900</pubDate><guid>/diary/posts/2024/0418/</guid><description>今日の運動は腹筋ローラー,腕立て,スクワット,縄跳び(両足跳)をした。統計を 運動の記録 にまとめる。
コレクションデータの再定義 ある mongodb のコレクションのデータ定義で _id に ldap の dn の値を使っていた。dn は一意な値なので主キーとして使ってもよさそうに思えたが、ここで運用上 dn の値が変更されるケースがいくつかあることがわかってきた。例えば、dn に姓名が含まれる場合、結婚して姓名が変わると dn の値が変わることはありえる。他にも dn に含まれる ou の値が現実の組織名を表している場合、組織変更によって ou の値が変わったときに dn の値も連動して変わってしまう。一意な値というだけでデータベースの主キーにするのはよくないということがわかってきた。主キーは一意な値、且つ immutable が望ましい。
たとえば mongodb では _id を主キーとして使う。mongodb は主キーの値を変更することはできなくて実装上は delete &amp;amp; insert になる。
How to update the _id of one MongoDB Document? delete &amp;amp; insert の運用上の問題は更新時にトランザクションを使わないといけないため、パフォーマンスが悪い。さらに id 連携という業務に特化して言うと、たとえば、姓名の変更は名前が変わったというだけでその人が退職したわけではない。これをシステム上 delete &amp;amp; insert で扱うと、古いユーザーデータを削除して、新規にユーザーデータを作成するといった振る舞いになってしまう。そうすると、古いユーザーがもっていた権限やデータなどを移行しないといけないわけだが、それらをすべて自動化できるか？という難しい課題も積み重なってしまう。本質的に rename を delete &amp;amp; insert で扱うことそのものが誤っているのだ。
メンバーと相談して _id に uuid を発行して dn はフィールドに unique 制約を課して保持するよう設計を変更することに決めた。コレクションのデータ定義の主キー変更なのであちこち修正してテストコードも修正しないといけない。一意な値、且つ immutable な値のみを主キーとして使うのが今回の学びとなった。私自身、初期の設計に関わったときにこのことに気付かなかったから、これは私のレビューの失敗・見逃しでもある。</description><content>&lt;p>今日の運動は腹筋ローラー,腕立て,スクワット,縄跳び(両足跳)をした。統計を &lt;a href="https://docs.google.com/spreadsheets/d/1bg85QtM-LciUgey8I79uI7vW2PEwsP6TVdeIRVkACBg/edit?usp=sharing">運動の記録&lt;/a> にまとめる。&lt;/p>
&lt;h2 id="コレクションデータの再定義">コレクションデータの再定義&lt;/h2>
&lt;p>ある mongodb のコレクションのデータ定義で &lt;code>_id&lt;/code> に ldap の dn の値を使っていた。dn は一意な値なので主キーとして使ってもよさそうに思えたが、ここで運用上 dn の値が変更されるケースがいくつかあることがわかってきた。例えば、dn に姓名が含まれる場合、結婚して姓名が変わると dn の値が変わることはありえる。他にも dn に含まれる ou の値が現実の組織名を表している場合、組織変更によって ou の値が変わったときに dn の値も連動して変わってしまう。一意な値というだけでデータベースの主キーにするのはよくないということがわかってきた。主キーは一意な値、且つ immutable が望ましい。&lt;/p>
&lt;p>たとえば mongodb では &lt;code>_id&lt;/code> を主キーとして使う。mongodb は主キーの値を変更することはできなくて実装上は delete &amp;amp; insert になる。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://stackoverflow.com/questions/4012855/how-to-update-the-id-of-one-mongodb-document">How to update the _id of one MongoDB Document?&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>delete &amp;amp; insert の運用上の問題は更新時にトランザクションを使わないといけないため、パフォーマンスが悪い。さらに id 連携という業務に特化して言うと、たとえば、姓名の変更は名前が変わったというだけでその人が退職したわけではない。これをシステム上 delete &amp;amp; insert で扱うと、古いユーザーデータを削除して、新規にユーザーデータを作成するといった振る舞いになってしまう。そうすると、古いユーザーがもっていた権限やデータなどを移行しないといけないわけだが、それらをすべて自動化できるか？という難しい課題も積み重なってしまう。本質的に rename を delete &amp;amp; insert で扱うことそのものが誤っているのだ。&lt;/p>
&lt;p>メンバーと相談して &lt;code>_id&lt;/code> に uuid を発行して &lt;code>dn&lt;/code> はフィールドに unique 制約を課して保持するよう設計を変更することに決めた。コレクションのデータ定義の主キー変更なのであちこち修正してテストコードも修正しないといけない。一意な値、且つ immutable な値のみを主キーとして使うのが今回の学びとなった。私自身、初期の設計に関わったときにこのことに気付かなかったから、これは私のレビューの失敗・見逃しでもある。&lt;/p></content></item><item><title>事務手続きに追われまくり</title><link>/diary/posts/2024/0409/</link><pubDate>Tue, 09 Apr 2024 09:40:38 +0900</pubDate><guid>/diary/posts/2024/0409/</guid><description>深夜に山本由伸投手のフォームのなにがすごいかを調べたりして遅くなった。
今日は別に体調は悪くなかったのだけど、単純にお仕事が忙しくて運動している余裕がなくてお休みした。たまにはそういうこともあるか。
mongodb の OR 検索 mongodb で OR 検索するには $or operator を使う。mongo-go-driver では次のように実装すればよい。
filters := make(bson.D, 0, len(query)) ... conds := make(bson.A, 0, len(v.Values)) for _, vv := range v.Values { conds = append(conds, makeFilters(vv)) } filters = append(filters, bson.E{Key: &amp;#34;$or&amp;#34;, Value: conds}) 本業以外の雑多なお仕事 本業の開発も課題が山盛りで忙しいのだけど、それ以外にも雑多な事務手続きが増えてきてなかなか大変。人を相手にするとやり取りが発生して時間がかかる。お昼ご飯を食べる余裕がない。ダイエットにはよいかもしれない。
社宅契約の手続き 新たに顧問弁護士さんとの契約手続き 信託銀行の投資信託運用のための手続き</description><content>&lt;p>深夜に山本由伸投手のフォームのなにがすごいかを調べたりして遅くなった。&lt;/p>
&lt;p>今日は別に体調は悪くなかったのだけど、単純にお仕事が忙しくて運動している余裕がなくてお休みした。たまにはそういうこともあるか。&lt;/p>
&lt;h2 id="mongodb-の-or-検索">mongodb の OR 検索&lt;/h2>
&lt;p>mongodb で OR 検索するには &lt;a href="https://www.mongodb.com/docs/manual/reference/operator/query/or/">$or operator&lt;/a> を使う。&lt;a href="https://github.com/mongodb/mongo-go-driver">mongo-go-driver&lt;/a> では次のように実装すればよい。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">filters&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> make(&lt;span style="color:#a6e22e">bson&lt;/span>.&lt;span style="color:#a6e22e">D&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, len(&lt;span style="color:#a6e22e">query&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">conds&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> make(&lt;span style="color:#a6e22e">bson&lt;/span>.&lt;span style="color:#a6e22e">A&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, len(&lt;span style="color:#a6e22e">v&lt;/span>.&lt;span style="color:#a6e22e">Values&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">vv&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">v&lt;/span>.&lt;span style="color:#a6e22e">Values&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">conds&lt;/span> = append(&lt;span style="color:#a6e22e">conds&lt;/span>, &lt;span style="color:#a6e22e">makeFilters&lt;/span>(&lt;span style="color:#a6e22e">vv&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">filters&lt;/span> = append(&lt;span style="color:#a6e22e">filters&lt;/span>, &lt;span style="color:#a6e22e">bson&lt;/span>.&lt;span style="color:#a6e22e">E&lt;/span>{&lt;span style="color:#a6e22e">Key&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;$or&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">Value&lt;/span>: &lt;span style="color:#a6e22e">conds&lt;/span>})
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="本業以外の雑多なお仕事">本業以外の雑多なお仕事&lt;/h2>
&lt;p>本業の開発も課題が山盛りで忙しいのだけど、それ以外にも雑多な事務手続きが増えてきてなかなか大変。人を相手にするとやり取りが発生して時間がかかる。お昼ご飯を食べる余裕がない。ダイエットにはよいかもしれない。&lt;/p>
&lt;ul>
&lt;li>社宅契約の手続き&lt;/li>
&lt;li>新たに顧問弁護士さんとの契約手続き&lt;/li>
&lt;li>信託銀行の投資信託運用のための手続き&lt;/li>
&lt;/ul></content></item><item><title>結合テストのデバッグ</title><link>/diary/posts/2023/1219/</link><pubDate>Tue, 19 Dec 2023 08:56:57 +0900</pubDate><guid>/diary/posts/2023/1219/</guid><description>1時に寝て5時半に起きて7時半に起きた。なんか週の前半からバテている。
gitlab ci/cd の dind で mongodb のレプリカセット接続ができない 先日対応した mongodb のレプリカセット対応 で残った最後の課題。ローカルで実行すれば結合テストは動くが、gitlab ci/cd 環境では動作しないという問題が残っていた。gitlab-runner をローカルで実行できる ようにして、設定やパラメーターを変えたり、デバッグコードを埋め込んだり、コンテナに attach して振る舞いを確認したり、いろいろデバッグして原因はレプリカセット接続におけるホスト名の解決がコンテナ間でできていなかったことがわかった。
mongodb の結合テストは dockertest を使って実装している。これを gitlab ci/cd で動かすには dind を有効にする必要がある。dind 環境では2つのコンテナを使って結合テストが実行されるわけだが、テストが実行されるコンテナと mongodb コンテナが起動するコンテナの2つが生成される。このときにテストが実行されるコンテナから実際に mongodb が起動するコンテナのホスト名の解決と、mongodb が起動するコンテナ上での自分のホスト名の解決の2つが成立していないとレプリカセット接続ができない。要は1台のローカルホスト上で結合テストを実行するのと、2つのコンテナ上で実行されるのでは設定を変更する必要があるということに気付いた。
具体的には dockertest の次のパラメーターを、実行環境から解決するホスト名を考慮して設定すればよいと気付いた。
pool.RunWithOptions(&amp;amp;dockertest.RunOptions{ ... Hostname: executor, Env: []string{ ... fmt.Sprintf(&amp;#34;MONGODB_ADVERTISED_HOSTNAME=%s&amp;#34;, executor), ... } }) たったこれだけの修正だし、現状の動作の振る舞いが分かればすぐに直せるものではあるけれど、このデバッグにはまた2-3時間を費やした。mongodb のレプリカセット接続はなかなか大変。</description><content>&lt;p>1時に寝て5時半に起きて7時半に起きた。なんか週の前半からバテている。&lt;/p>
&lt;h2 id="gitlab-cicd-の-dind-で-mongodb-のレプリカセット接続ができない">gitlab ci/cd の dind で mongodb のレプリカセット接続ができない&lt;/h2>
&lt;p>先日対応した &lt;a href="/diary/diary/posts/2023/1214/">mongodb のレプリカセット対応&lt;/a> で残った最後の課題。ローカルで実行すれば結合テストは動くが、gitlab ci/cd 環境では動作しないという問題が残っていた。&lt;a href="/diary/diary/posts/2023/1218/">gitlab-runner をローカルで実行できる&lt;/a> ようにして、設定やパラメーターを変えたり、デバッグコードを埋め込んだり、コンテナに attach して振る舞いを確認したり、いろいろデバッグして原因はレプリカセット接続におけるホスト名の解決がコンテナ間でできていなかったことがわかった。&lt;/p>
&lt;p>mongodb の結合テストは &lt;a href="https://github.com/ory/dockertest">dockertest&lt;/a> を使って実装している。これを gitlab ci/cd で動かすには dind を有効にする必要がある。dind 環境では2つのコンテナを使って結合テストが実行されるわけだが、テストが実行されるコンテナと mongodb コンテナが起動するコンテナの2つが生成される。このときにテストが実行されるコンテナから実際に mongodb が起動するコンテナのホスト名の解決と、mongodb が起動するコンテナ上での自分のホスト名の解決の2つが成立していないとレプリカセット接続ができない。要は1台のローカルホスト上で結合テストを実行するのと、2つのコンテナ上で実行されるのでは設定を変更する必要があるということに気付いた。&lt;/p>
&lt;p>具体的には dockertest の次のパラメーターを、実行環境から解決するホスト名を考慮して設定すればよいと気付いた。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">pool&lt;/span>.&lt;span style="color:#a6e22e">RunWithOptions&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">dockertest&lt;/span>.&lt;span style="color:#a6e22e">RunOptions&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Hostname&lt;/span>: &lt;span style="color:#a6e22e">executor&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Env&lt;/span>: []&lt;span style="color:#66d9ef">string&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Sprintf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;MONGODB_ADVERTISED_HOSTNAME=%s&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">executor&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>})
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>たったこれだけの修正だし、現状の動作の振る舞いが分かればすぐに直せるものではあるけれど、このデバッグにはまた2-3時間を費やした。mongodb のレプリカセット接続はなかなか大変。&lt;/p></content></item><item><title>コンテナイメージの移行</title><link>/diary/posts/2023/1214/</link><pubDate>Thu, 14 Dec 2023 08:32:58 +0900</pubDate><guid>/diary/posts/2023/1214/</guid><description>1時に寝て3時に起きて6時半に起きた。スマホで呪術廻戦のゲームを開いたまま寝てた。
サードパーティの mongodb コンテナへの移行 昨日の mongodb のサードパーティのコンテナイメージ調査 の続き。
レプリカセットの削除 基本的に一度作ったレプリカセットを削除することはないせいか、レプリカセットを削除するユーティリティは提供されていない。なんらかの理由でレプリカセットを再作成したいときは、レプリカセットの設定が保存されている local database を削除する。
またレプリカセットの稼働中に local database を削除することはできないため、mongod サーバーを --replSet を指定していない状態で起動させ、そのときに次のようにして local database を削除できる。
test&amp;gt; use admin admin&amp;gt; db.grantRolesToUser(&amp;#34;root&amp;#34;, [&amp;#34;__system&amp;#34;]); { ok: 1 } admin&amp;gt; use local switched to db local local&amp;gt; db.dropDatabase() { ok: 1, dropped: &amp;#39;local&amp;#39; } local&amp;gt; use admin switched to db admin admin&amp;gt; db.revokeRolesFromUser(&amp;#34;root&amp;#34;, [&amp;#34;__system&amp;#34;]); { ok: 1 } コンテナを使ったレプリカセットの初期設定 bitnami/mongodb を使うと、ローカルのシングルノードでレプリカセットを使うには次のような設定になる。
mongo: image: docker.io/bitnami/mongodb:7.0.1 user: root # デフォルトは非 root ユーザーで起動するのでローカルの開発環境なら root で実行した方が手間がない volumes: - .</description><content>&lt;p>1時に寝て3時に起きて6時半に起きた。スマホで呪術廻戦のゲームを開いたまま寝てた。&lt;/p>
&lt;h2 id="サードパーティの-mongodb-コンテナへの移行">サードパーティの mongodb コンテナへの移行&lt;/h2>
&lt;p>昨日の &lt;a href="/diary/diary/posts/2023/1211/">mongodb のサードパーティのコンテナイメージ調査&lt;/a> の続き。&lt;/p>
&lt;h3 id="レプリカセットの削除">レプリカセットの削除&lt;/h3>
&lt;p>基本的に一度作ったレプリカセットを削除することはないせいか、レプリカセットを削除するユーティリティは提供されていない。なんらかの理由でレプリカセットを再作成したいときは、レプリカセットの設定が保存されている local database を削除する。&lt;/p>
&lt;p>またレプリカセットの稼働中に local database を削除することはできないため、mongod サーバーを &lt;code>--replSet&lt;/code> を指定していない状態で起動させ、そのときに次のようにして local database を削除できる。&lt;/p>
&lt;pre tabindex="0">&lt;code>test&amp;gt; use admin
admin&amp;gt; db.grantRolesToUser(&amp;#34;root&amp;#34;, [&amp;#34;__system&amp;#34;]);
{ ok: 1 }
admin&amp;gt; use local
switched to db local
local&amp;gt; db.dropDatabase()
{ ok: 1, dropped: &amp;#39;local&amp;#39; }
local&amp;gt; use admin
switched to db admin
admin&amp;gt; db.revokeRolesFromUser(&amp;#34;root&amp;#34;, [&amp;#34;__system&amp;#34;]);
{ ok: 1 }
&lt;/code>&lt;/pre>&lt;h3 id="コンテナを使ったレプリカセットの初期設定">コンテナを使ったレプリカセットの初期設定&lt;/h3>
&lt;p>&lt;a href="https://hub.docker.com/r/bitnami/mongodb">bitnami/mongodb&lt;/a> を使うと、ローカルのシングルノードでレプリカセットを使うには次のような設定になる。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">mongo&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">image&lt;/span>: &lt;span style="color:#ae81ff">docker.io/bitnami/mongodb:7.0.1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">user&lt;/span>: &lt;span style="color:#ae81ff">root &lt;/span> &lt;span style="color:#75715e"># デフォルトは非 root ユーザーで起動するのでローカルの開発環境なら root で実行した方が手間がない&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">volumes&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">./volumes/mongodb:/bitnami/mongodb&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">environment&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">MONGODB_ROOT_USER&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;${MONGO_USER}&amp;#34;&lt;/span> &lt;span style="color:#75715e"># 認証ユーザー&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">MONGODB_ROOT_PASSWORD&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;${MONGO_PASSWORD}&amp;#34;&lt;/span> &lt;span style="color:#75715e"># 認証ユーザーのパスワード&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">MONGODB_ADVERTISED_HOSTNAME&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;mongo-primary&amp;#34;&lt;/span> &lt;span style="color:#75715e"># レプリカセットのノードを ip アドレスではなくホスト名で指定する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">MONGODB_REPLICA_SET_NAME&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;myrs&amp;#34;&lt;/span> &lt;span style="color:#75715e"># レプリカセットの名前&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">MONGODB_REPLICA_SET_MODE&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;primary&amp;#34;&lt;/span> &lt;span style="color:#75715e"># プライマリノードとして設定&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">MONGODB_REPLICA_SET_KEY&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;my/replication/common/key123&amp;#34;&lt;/span> &lt;span style="color:#75715e"># キーファイルのコンテンツ (base64 でデコードできる値)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">MONGODB_SYSTEM_LOG_VERBOSITY&lt;/span>: &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#75715e"># ログレベル&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">hostname&lt;/span>: &lt;span style="color:#ae81ff">mongo-primary &lt;/span> &lt;span style="color:#75715e"># コンテナの内外から解決できるホスト名を指定&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">container_name&lt;/span>: &lt;span style="color:#ae81ff">mongo &lt;/span> &lt;span style="color:#75715e"># コンテナ名 (docker container ls で表示される名前)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">ports&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">27017&lt;/span>:&lt;span style="color:#ae81ff">27017&lt;/span> &lt;span style="color:#75715e"># レプリカセットを運用する場合はポート番号のマッピングを一致させる必要がある&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">restart&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;always&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この設定でレプリカセットを初期した場合、レプリカセットの initialize 処理は、次のような config/member をもつ。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">members&lt;/span>&lt;span style="color:#f92672">:&lt;/span> [{ &lt;span style="color:#a6e22e">_id&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#a6e22e">host&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;mongo-primary:27017&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">priority&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span> }]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>コンテナの内部からは mongo-primary というホスト名に対して、コンテナネットワーク内のローカル ip アドレスが解決される。&lt;/p>
&lt;pre tabindex="0">&lt;code>c67a5ca94a77:/app# dig +short mongo-primary
192.168.240.3
&lt;/code>&lt;/pre>&lt;p>ここで host os 上のアプリケーションから mongo コンテナに対してレプリカセット接続をする場合 &lt;code>replicaSet=${レプリカセットの名前}&lt;/code> のパラメーターを追加する。&lt;/p>
&lt;pre tabindex="0">&lt;code>mongodb://root:password@localhost:27017/?authMechanism=DEFAULT&amp;amp;replicaSet=myrs
&lt;/code>&lt;/pre>&lt;p>これは localhost:27017 にレプリカセットの接続を試行し、接続できるとレプリカセットのメンバーが返される。&lt;/p>
&lt;p>レプリカセットのメンバーには &lt;code>mongo-primary:27017&lt;/code> という設定が行われているため、mongo-primary というホスト名に対して host os 上で名前解決できる必要がある。そのために /etc/hosts に次の設定を行う。&lt;/p>
&lt;pre tabindex="0">&lt;code>$ sudo vi /etc/hosts
...
127.0.0.1 mongo-primary
&lt;/code>&lt;/pre>&lt;p>&lt;a href="https://www.mongodb.com/products/tools/compass">compass&lt;/a> で接続した場合、レプリカセット接続であれば、レプリカセットの名前が接続情報として表示される。&lt;/p>
&lt;h2 id="ダイニングテーブル引き取り">ダイニングテーブル引き取り&lt;/h2>
&lt;p>実は火曜日にも長机を引き取りに行ってきて、今日はダイニングテーブルを引き取りに行ってきた。この3日間で2つもテーブルが手に入った。いつも目ぼしいと思ったものは、すぐに他の人と取り引きが成立してしまうのに、たまたま続けて私と取り引きが成立した。車で20分ぐらいの距離のマンションまで引き取りに行った。20時の予定を、19時10分には着いてしまって、先方も快く対応してくれた。私よりも見た目すこし年配の方で人当たりのよい感じの方だった。ジモティのやり取りはその人の性格が出るもので、受け渡しだけささっとやって余計な話しはしないパターンもあれば、愛想よく話しながら受け渡しをするパターンもある。先方によると、大事に使っていたテーブルのようにみえるので私も離れのオフィススペースで大事に使おうと思う。&lt;/p></content></item><item><title>mongodb のサードパーティのコンテナイメージ</title><link>/diary/posts/2023/1213/</link><pubDate>Wed, 13 Dec 2023 20:35:00 +0900</pubDate><guid>/diary/posts/2023/1213/</guid><description>23時に寝て3時に起きて寝たかどうか覚えていないうちに6時半になっていて7時半に起きた。
json を介した go の bool 値のバリエーション go-playground/validator のバリデータには required というバリデーションオプションがある。しかし、このオプションは go のゼロ値でないことをチェックするという仕様になっている。bool のゼロ値は false となるため、リクエストした JSON データに false を設定していたのか、未設定だったのかの違いを検出できない。これはバリデータの問題ではなく、go の json ライブラリの制約のようなもので使い勝手のよい仕様とは言えない。私もこの振る舞いに起因する不具合に遭遇したこともあるし、こういうときにどうしたらよいかも過去に3回ぐらいは調べている気がする。
How to validate bool #142 現時点での私の最適化は次のコードになる。データ構造として *bool 型にすれば、ポインタ型のゼロ値は nil となるため、true, false, nil の3値でバリデーションできる。しかし、私はこのデータ構造を好ましく思わない。というのは、内部的には true/false の2値でしか管理しないメンバーを、json のバリデーションのためだけに nil も許容する3値にすることがよい設計だと私は思えない。そこでバリデータによるバリデーションは諦めて、json の Unmarshal 処理をフックしてバリデーション相当の処理を自分で実装する。このやり方のデメリットはメンバーが追加されたときに自分で UnmarshalJSON() メソッドを保守する必要がある点になる。しかし、メリットとして内部のデータ構造の型は bool 型で扱える。一概にどちらがよいとは言いにくいかもしれないし、設計上の好みかもしれない。
type reqMyData struct { Name string `json:&amp;#34;name&amp;#34;` View *bool `json:&amp;#34;view&amp;#34;` } type MyData struct { Name string `json:&amp;#34;name&amp;#34;` View bool `json:&amp;#34;view&amp;#34;` } func (d *MyData) UnmarshalJSON(data []byte) error { var tmp reqMyData if err := json.</description><content>&lt;p>23時に寝て3時に起きて寝たかどうか覚えていないうちに6時半になっていて7時半に起きた。&lt;/p>
&lt;h2 id="json-を介した-go-の-bool-値のバリエーション">json を介した go の bool 値のバリエーション&lt;/h2>
&lt;p>&lt;a href="https://github.com/go-playground/validator">go-playground/validator&lt;/a> のバリデータには &lt;a href="https://pkg.go.dev/github.com/go-playground/validator/v10#hdr-Required">required&lt;/a> というバリデーションオプションがある。しかし、このオプションは go のゼロ値でないことをチェックするという仕様になっている。bool のゼロ値は false となるため、リクエストした JSON データに false を設定していたのか、未設定だったのかの違いを検出できない。これはバリデータの問題ではなく、go の json ライブラリの制約のようなもので使い勝手のよい仕様とは言えない。私もこの振る舞いに起因する不具合に遭遇したこともあるし、こういうときにどうしたらよいかも過去に3回ぐらいは調べている気がする。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/go-playground/validator/issues/142">How to validate bool #142&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>現時点での私の最適化は次のコードになる。データ構造として &lt;code>*bool&lt;/code> 型にすれば、ポインタ型のゼロ値は nil となるため、true, false, nil の3値でバリデーションできる。しかし、私はこのデータ構造を好ましく思わない。というのは、内部的には true/false の2値でしか管理しないメンバーを、json のバリデーションのためだけに nil も許容する3値にすることがよい設計だと私は思えない。そこでバリデータによるバリデーションは諦めて、json の Unmarshal 処理をフックしてバリデーション相当の処理を自分で実装する。このやり方のデメリットはメンバーが追加されたときに自分で UnmarshalJSON() メソッドを保守する必要がある点になる。しかし、メリットとして内部のデータ構造の型は &lt;code>bool&lt;/code> 型で扱える。一概にどちらがよいとは言いにくいかもしれないし、設計上の好みかもしれない。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">reqMyData&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Name&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#e6db74">`json:&amp;#34;name&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">View&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#e6db74">`json:&amp;#34;view&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">MyData&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Name&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#e6db74">`json:&amp;#34;name&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">View&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#e6db74">`json:&amp;#34;view&amp;#34;`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">d&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">MyData&lt;/span>) &lt;span style="color:#a6e22e">UnmarshalJSON&lt;/span>(&lt;span style="color:#a6e22e">data&lt;/span> []&lt;span style="color:#66d9ef">byte&lt;/span>) &lt;span style="color:#66d9ef">error&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">tmp&lt;/span> &lt;span style="color:#a6e22e">reqMyData&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">json&lt;/span>.&lt;span style="color:#a6e22e">Unmarshal&lt;/span>(&lt;span style="color:#a6e22e">data&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">tmp&lt;/span>); &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Errorf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;failed to unmarshal as reqMyData&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">tmp&lt;/span>.&lt;span style="color:#a6e22e">View&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Errorf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;required view field&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">d&lt;/span>.&lt;span style="color:#a6e22e">Name&lt;/span> = &lt;span style="color:#a6e22e">tmp&lt;/span>.&lt;span style="color:#a6e22e">Name&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">d&lt;/span>.&lt;span style="color:#a6e22e">View&lt;/span> = &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">tmp&lt;/span>.&lt;span style="color:#a6e22e">View&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="サードパーティの-mongodb-コンテナイメージ">サードパーティの mongodb コンテナイメージ&lt;/h2>
&lt;p>先日の &lt;a href="/diary/diary/posts/2023/1211/">mongodb のレプリカセット調査&lt;/a> の続き。コードレビューをしていて &lt;a href="https://hub.docker.com/r/bitnami/mongodb">bitnami/mongodb&lt;/a> というサードパーティのコンテナイメージを使った方がよいのではないか？というコメントがあったのでその調査をしてみた。VMware 社が提供しているサードパーティのコンテナイメージらしい。&lt;/p>
&lt;blockquote>
&lt;p>MongoDB(R) is run and maintained by MongoDB, which is a completely separate project from Bitnami.&lt;/p>
&lt;/blockquote>
&lt;p>まず MongoDB プロジェクトとはまったく別管理であることが書いてある。&lt;/p>
&lt;blockquote>
&lt;p>Bitnami イメージを使用する理由&lt;/p>
&lt;ul>
&lt;li>Bitnamiはアップストリームソースの変更を綿密に追跡し、自動化されたシステムを使用してこのイメージの新しいバージョンを迅速に公開します。&lt;/li>
&lt;li>Bitnami イメージでは、最新のバグ修正と機能をできるだけ早く利用できます。&lt;/li>
&lt;li>Bitnamiのコンテナ、仮想マシン、クラウドイメージは、同じコンポーネントと構成アプローチを使用しているため、プロジェクトのニーズに応じて形式を簡単に切り替えることができます。&lt;/li>
&lt;li>Bitnamiのイメージはすべて、minideb（最小限のDebianベースのコンテナイメージ）またはscratch（明示的に空のイメージ）をベースにしています。&lt;/li>
&lt;li>Docker Hubで利用可能なすべてのBitnamiイメージは、Docker Content Trust（DCT）で署名されています。DOCKER_CONTENT_TRUST=1 を使用して、イメージの完全性を確認できます。&lt;/li>
&lt;li>Bitnamiコンテナイメージは定期的にリリースされ、最新のディストリビューションパッケージが利用可能です。&lt;/li>
&lt;/ul>
&lt;p>MongoDB®を本番環境で使用したいですか？Bitnami Application Catalogのエンタープライズ版であるVMware Tanzu Application Catalogをお試しください。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;a href="https://hub.docker.com/_/mongo">mongo&lt;/a> の公式イメージは ubuntu をベースイメージにしている。ubuntu よりは minideb の方が軽いのかな？そしてちゃんと upstream にも追随しているみたい。このベースイメージの違いによるものかは定かではないが、結合テストのイメージも移行してみたところ、10-20秒ほど結合テストの実行時間が速くなった。割合にすると10%程度かな。&lt;/p>
&lt;blockquote>
&lt;p>KubernetesにMongoDB®をデプロイするには？&lt;/p>
&lt;p>Bitnami アプリケーションを Helm Chart としてデプロイすることは、Kubernetes 上で当社のアプリケーションを使い始める最も簡単な方法です。インストールの詳細については、Bitnami MongoDB® Chart GitHub リポジトリを参照してください。&lt;/p>
&lt;p>Bitnami コンテナは、クラスタへの Helm Charts のデプロイと管理に Kubeapps と一緒に使用できます。&lt;/p>
&lt;/blockquote>
&lt;p>helm chart も提供しているようで、いずれクラウド版を作るときに MongoDB も k8s 上にデプロイする上でこのことは都合がよいように思える。&lt;/p>
&lt;p>レプリケーションを前提とした初期設定があり、entrypoint スクリプトもいくつか読んでみた感じだと、きれいに管理されていて保守もちゃんとやってくれそうにみえる。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/bitnami/containers/tree/main/bitnami/mongodb">https://github.com/bitnami/containers/tree/main/bitnami/mongodb&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>昨日、導入したばかりの公式イメージ + 自作スクリプトによるレプリケーション設定を廃止して、Bitnami のコンテナイメージを使うことに決めた。&lt;/p></content></item><item><title>owner/permission の違うファイルとリポジトリ管理</title><link>/diary/posts/2023/1211/</link><pubDate>Mon, 11 Dec 2023 09:37:23 +0900</pubDate><guid>/diary/posts/2023/1211/</guid><description>23時に寝て2時に起きて6時に起きて7時過ぎに起きた。なんか微妙な寝方をした。
先日の mongodb のレプリカセットの調査 の整理をしてマージリクエストを作成した。共通鍵の keyFile をどう扱えばいいのか、わからなくて、一旦コンテナ内の tmp 領域にコピーして、それを entrypoint スクリプトでコピーしてから owner/permission を変更するというやり方で、リポジトリ管理で共有しやすいようにしてみた。entrypoint スクリプトは root 権限で実行されることも理解した。
volumes: - ./mongo/keyfile:/var/tmp/keyfile.orig command: - mongod - --keyFile - /data/keyfile - --replSet - &amp;#34;myrs&amp;#34; entrypoint: - bash - -c - | if [[ ! -f /data/keyfile ]]; then cp /var/tmp/keyfile.orig /data/keyfile chmod 400 /data/keyfile chown mongodb:mongodb /data/keyfile fi exec docker-entrypoint.sh $$@ テックブログを読む会 昨日、西原さんに教えてもらった テックブログを読むイベント を探したら毎週月曜日に行われているようだった。早速 テックブログ一気読み選手権20231211杯 に参加した。HackMD で読んだメモを管理している。記事を選択して、読んで、所感をまとめて、他の人たちと共有する。ただそれだけのイベント。ちょうど30分で終わって、自分の勉強にもなったし、他の人の話しも聞いて参考になった。たった30分でも、なにもやらないよりずっとよい。1ヶ月ほど参加してやり方を学んだらチームにも展開してみようかと考えている。</description><content>&lt;p>23時に寝て2時に起きて6時に起きて7時過ぎに起きた。なんか微妙な寝方をした。&lt;/p>
&lt;p>先日の &lt;a href="/diary/diary/posts/2023/1207/">mongodb のレプリカセットの調査&lt;/a> の整理をしてマージリクエストを作成した。共通鍵の keyFile をどう扱えばいいのか、わからなくて、一旦コンテナ内の tmp 領域にコピーして、それを entrypoint スクリプトでコピーしてから owner/permission を変更するというやり方で、リポジトリ管理で共有しやすいようにしてみた。entrypoint スクリプトは root 権限で実行されることも理解した。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">volumes&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">./mongo/keyfile:/var/tmp/keyfile.orig&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">command&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">mongod&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - --&lt;span style="color:#ae81ff">keyFile&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">/data/keyfile&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - --&lt;span style="color:#ae81ff">replSet&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#e6db74">&amp;#34;myrs&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">entrypoint&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">bash&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - -&lt;span style="color:#ae81ff">c&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - |&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> if [[ ! -f /data/keyfile ]]; then
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> cp /var/tmp/keyfile.orig /data/keyfile
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> chmod 400 /data/keyfile
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> chown mongodb:mongodb /data/keyfile
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> fi
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> exec docker-entrypoint.sh $$@&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="テックブログを読む会">テックブログを読む会&lt;/h2>
&lt;p>昨日、西原さんに教えてもらった &lt;a href="/diary/diary/posts/2023/1210/">テックブログを読むイベント&lt;/a> を探したら毎週月曜日に行われているようだった。早速 &lt;a href="https://blogreading.connpass.com/event/304979/">テックブログ一気読み選手権20231211杯&lt;/a> に参加した。HackMD で読んだメモを管理している。記事を選択して、読んで、所感をまとめて、他の人たちと共有する。ただそれだけのイベント。ちょうど30分で終わって、自分の勉強にもなったし、他の人の話しも聞いて参考になった。たった30分でも、なにもやらないよりずっとよい。1ヶ月ほど参加してやり方を学んだらチームにも展開してみようかと考えている。&lt;/p></content></item><item><title>mongodb のレプリカセットのデプロイ調査</title><link>/diary/posts/2023/1207/</link><pubDate>Thu, 07 Dec 2023 09:26:50 +0900</pubDate><guid>/diary/posts/2023/1207/</guid><description>4時前に寝て6時半に起きた。1時過ぎまで作業して、帰って少しゲームして、うまく眠れなくてだらだらしていた。
mongodb のレプリカセットの調査 以前 mongodb でトランザクションを使うときにレプリカセットが必要 なことがわかった。他機能の開発途中だったので一旦後回しにしていたものを回収している。状況によってはメンバーに委譲してもよかったんだけど、私が遊撃で出張ってみることにした。実際に調べてみてコンテナの運用も考慮するとけっこう難しいことがわかってきた。
mongosh からは Replication Methods を使ってレプリカセットの操作ができる。これはユーティリティのようなもので mongodb としての低レベルのコマンド操作は Replication Commands になる。mongo-go-driver はレプリカセット向けのユーティリティを提供していないため、Replication Commands を RunCommand() の低レベル API を使って自分で実装しないといけない。
例えば、レプリカセットの初期化をするときは次のように replSetInitiate というコマンドを適切なパラメーターで呼び出す。あまりドキュメントで丁寧に説明されていないので試行錯誤でエラーメッセージをみながら実装することになる。とくにはまるのが mongod のサーバーは --replSet myrs のようにレプリカセットを指定して起動させるものの、初期化コマンドを実行するときはまだレプリカセットを設定していないため、レプリカセットを指定せず、且つ direct パラメーターをセットしないと mongod サーバーに接続できない。この微妙な設定を把握するのにはまった。これが正しい手順かどうかもわからないが、ググったりしているとフォーラムでそういったコメントが散見されたりする。おそらく mongosh の Replication Methods を使うと、クライアントからサーバー接続は裏方でよしなにやってくれるのでそっちの方が簡単ではある。
func (r *ReplicaSet) Initiate(ctx context.Context, config bson.M) error { client, err := r.connectDirect(ctx) if err != nil { return fmt.Errorf(&amp;#34;failed to connect with direct: %w&amp;#34;, err) } defer client.Disconnect(ctx) var result bson.</description><content>&lt;p>4時前に寝て6時半に起きた。1時過ぎまで作業して、帰って少しゲームして、うまく眠れなくてだらだらしていた。&lt;/p>
&lt;h2 id="mongodb-のレプリカセットの調査">mongodb のレプリカセットの調査&lt;/h2>
&lt;p>以前 &lt;a href="/diary/diary/posts/2023/1101/#mongo-とトランザクションとレプリカセット">mongodb でトランザクションを使うときにレプリカセットが必要&lt;/a> なことがわかった。他機能の開発途中だったので一旦後回しにしていたものを回収している。状況によってはメンバーに委譲してもよかったんだけど、私が遊撃で出張ってみることにした。実際に調べてみてコンテナの運用も考慮するとけっこう難しいことがわかってきた。&lt;/p>
&lt;p>&lt;a href="https://www.mongodb.com/docs/mongodb-shell/">mongosh&lt;/a> からは &lt;a href="https://www.mongodb.com/docs/v7.0/reference/method/js-replication/">Replication Methods&lt;/a> を使ってレプリカセットの操作ができる。これはユーティリティのようなもので mongodb としての低レベルのコマンド操作は &lt;a href="https://www.mongodb.com/docs/manual/reference/command/nav-replication/">Replication Commands&lt;/a> になる。&lt;a href="https://github.com/mongodb/mongo-go-driver">mongo-go-driver&lt;/a> はレプリカセット向けのユーティリティを提供していないため、Replication Commands を RunCommand() の低レベル API を使って自分で実装しないといけない。&lt;/p>
&lt;p>例えば、レプリカセットの初期化をするときは次のように &lt;code>replSetInitiate&lt;/code> というコマンドを適切なパラメーターで呼び出す。あまりドキュメントで丁寧に説明されていないので試行錯誤でエラーメッセージをみながら実装することになる。とくにはまるのが mongod のサーバーは &lt;code>--replSet myrs&lt;/code> のようにレプリカセットを指定して起動させるものの、初期化コマンドを実行するときはまだレプリカセットを設定していないため、レプリカセットを指定せず、且つ &lt;code>direct&lt;/code> パラメーターをセットしないと mongod サーバーに接続できない。この微妙な設定を把握するのにはまった。これが正しい手順かどうかもわからないが、ググったりしているとフォーラムでそういったコメントが散見されたりする。おそらく mongosh の Replication Methods を使うと、クライアントからサーバー接続は裏方でよしなにやってくれるのでそっちの方が簡単ではある。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ReplicaSet&lt;/span>) &lt;span style="color:#a6e22e">Initiate&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span> &lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#a6e22e">config&lt;/span> &lt;span style="color:#a6e22e">bson&lt;/span>.&lt;span style="color:#a6e22e">M&lt;/span>) &lt;span style="color:#66d9ef">error&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">client&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">connectDirect&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Errorf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;failed to connect with direct: %w&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">defer&lt;/span> &lt;span style="color:#a6e22e">client&lt;/span>.&lt;span style="color:#a6e22e">Disconnect&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">result&lt;/span> &lt;span style="color:#a6e22e">bson&lt;/span>.&lt;span style="color:#a6e22e">M&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">cmd&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">bson&lt;/span>.&lt;span style="color:#a6e22e">D&lt;/span>{{&lt;span style="color:#a6e22e">Key&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;replSetInitiate&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">Value&lt;/span>: &lt;span style="color:#a6e22e">config&lt;/span>}}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">client&lt;/span>.&lt;span style="color:#a6e22e">Database&lt;/span>(&lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">db&lt;/span>).&lt;span style="color:#a6e22e">RunCommand&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span>, &lt;span style="color:#a6e22e">cmd&lt;/span>).&lt;span style="color:#a6e22e">Decode&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">result&lt;/span>); &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Errorf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;failed to run replSetInitiate(): %w&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">log&lt;/span>.&lt;span style="color:#a6e22e">PrettyPrint&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;completed to initiate&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">result&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">ReplicaSet&lt;/span>) &lt;span style="color:#a6e22e">connectDirect&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span> &lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">mongo&lt;/span>.&lt;span style="color:#a6e22e">Client&lt;/span>, &lt;span style="color:#66d9ef">error&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">opts&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">options&lt;/span>.&lt;span style="color:#a6e22e">Client&lt;/span>().
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">SetAuth&lt;/span>(&lt;span style="color:#a6e22e">options&lt;/span>.&lt;span style="color:#a6e22e">Credential&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Username&lt;/span>: &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">config&lt;/span>.&lt;span style="color:#a6e22e">User&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Password&lt;/span>: &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">config&lt;/span>.&lt;span style="color:#a6e22e">Passwd&lt;/span>.&lt;span style="color:#a6e22e">String&lt;/span>(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }).
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">SetHosts&lt;/span>(&lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">config&lt;/span>.&lt;span style="color:#a6e22e">Hosts&lt;/span>).
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">SetDirect&lt;/span>(&lt;span style="color:#66d9ef">true&lt;/span>) &lt;span style="color:#75715e">// must be true
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">mongo&lt;/span>.&lt;span style="color:#a6e22e">Connect&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span>, &lt;span style="color:#a6e22e">opts&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">InitSingleReplicaSet&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ctx&lt;/span> &lt;span style="color:#a6e22e">context&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>, &lt;span style="color:#a6e22e">cfg&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">config&lt;/span>.&lt;span style="color:#a6e22e">MongoDB&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) &lt;span style="color:#66d9ef">error&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">rs&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">NewReplicaSet&lt;/span>(&lt;span style="color:#a6e22e">cfg&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">initConfig&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">bson&lt;/span>.&lt;span style="color:#a6e22e">M&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;_id&amp;#34;&lt;/span>: &lt;span style="color:#a6e22e">cfg&lt;/span>.&lt;span style="color:#a6e22e">ReplicaSet&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;members&amp;#34;&lt;/span>: []&lt;span style="color:#a6e22e">bson&lt;/span>.&lt;span style="color:#a6e22e">M&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {&lt;span style="color:#e6db74">&amp;#34;_id&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;host&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;localhost:27017&amp;#34;&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">rs&lt;/span>.&lt;span style="color:#a6e22e">Initiate&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span>, &lt;span style="color:#a6e22e">initConfig&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>さらに mongod サーバーを起動するときに &lt;code>--replSet&lt;/code> と &lt;code>--keyFile&lt;/code> (認証が必要な場合のみ？) という2つのパラメーターを指定する必要がある。&lt;code>--replSet&lt;/code> はレプリカセットの識別子を指定する。そして &lt;code>--keyFile&lt;/code> は共通鍵を指定する。この共通鍵を生成するには次のようにする。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ openssl rand -base64 &lt;span style="color:#ae81ff">756&lt;/span> &amp;gt; my-mongo-keyfile
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ chown mongodb:mongodb my-mongo-keyfile
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ chmod &lt;span style="color:#ae81ff">400&lt;/span> my-mongo-keyfile
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>普通のサーバーインスタンスならすぐできることだが、コンテナの運用において面倒なのが owner とパーミッションを設定しないといけないところ。mongo のコンテナは mongodb ユーザーで起動するため、root でマウントされたファイルシステムには書き込みできなかったりして keyFile の配置をどう扱えばよいのかが難しい。docker hub の mongo の issues でもどうやって設定したらいいの？って議論が発散している。mongo 本体が公式のスクリプトや仕組みを提供していれば済む話しだけど、どうもそうではないみたい。だから泥臭い方法で自分でなんとかしないといけないようにみえる。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/docker-library/mongo/issues/246">Creating a mongo image set with &amp;ndash;replSet #246&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/docker-library/mongo/issues/339">Cannot configure replica sets with entrypoint-initdb #339&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>dockertest でもレプリカセットの設定について次の issue として登録されている。mongo のコンテナを使ったテストの場合、dockertest のレイヤーが挟まるのでさらにわかりにくくなっている。テストを動かすためにどういった設定が必要かは把握できたのでなにかよい方法を考えてコントリビュートしたい。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/ory/dockertest/issues/480">Create an example for starting mongodb as a replica set #480&lt;/a>&lt;/li>
&lt;/ul></content></item><item><title>穴場のビアバー</title><link>/diary/posts/2023/1101/</link><pubDate>Wed, 01 Nov 2023 08:44:08 +0900</pubDate><guid>/diary/posts/2023/1101/</guid><description>0時に寝て何度か起きて6時半に起きた。移動日の疲れもあってか、いつもよりよく眠れた気がする。
朝食バイキング 先々月から大崎探索 をしていて ニューオータニイン東京 に泊まってみた。川沿いの道を歩きながら朝食バイキングもおいしい。食品の品数があると満足度が高い。
プロジェクトの進捗報告 出張したときの月例報告の11回目。前回の進捗報告はこちら 。
まだ開発の序盤なので 事前に準備した資料 の内容を一通り終えて雑談の時間も多かったように思う。3回目の開発フェーズになるのもあり、メンバーの練度も上がって、開発の手際はかなりよくなっているように私からはみえている。それらも含めて、メンバーが自律的に issue を作ったり、タスクを自分に割り当てたりしながら開発が進むようになっていると報告した。プロジェクトオーナーからも、最近のマイルストーン定例をみていて、メンバーが気付きが増えている、自律的によくないところを改善しようという意思がみえるといった話題も出ていた。課題管理のプラクティスを実践してきて、着実によい開発者の習慣を身につけて、よい開発チームに育ってきているように、私からもみえている。あとは課題管理についてのコンテンツを私が書かないといけないのを、バーンナウトの影響もあってか、先月はさぼってしまっていたので、今月こそなんか書きますと、自分を追い込む意図でもその場で話題にした。
mongo とトランザクションとレプリカセット mongo には トランザクション の機能が提供されている。しかし、トランザクションを使うためには レプリケーション を有効にしないといけない。レプリケーションは通常は複数台のマシンでクラスタリングを構築するものになる。うちらはシングルノードの mongo を扱っているのでレプリケーションを必要としていない。それでも、ドキュメントを読んでいると、スタンドアローンでも本番環境ではレプリカセットを使う方がよいといった説明もみつかる。
Convert a Standalone mongod to a Replica Set ちょうど開発の要件としてトランザクションを必要とする状況も出てきた。mongo のレプリケーションやトランザクションの仕組みを理解するよい機会かもしれない。11月中には調査したいというところ。
エビスバー 大崎探検の2日目。YEBISU BAR 大崎店 へ行ってみた。大崎駅横の駅ビルの2階にある。アクセスもよい。水曜日なのに20-21時半ぐらいまでいて、お客さんは3組ぐらしかいなかった。よい意味で空いてて静かにゆっくり飲めてよかった。穴場のバーをみつけた。ビール2杯とつまみ2品でちょうど3000円程度。ちょっと割高かもしれないけど、場所とお店の雰囲気とゆっくりできたことを考慮するとちょうどよい価格帯にも思える。またゆっくり軽く飲みたいときに行こうと思う。</description><content>&lt;p>0時に寝て何度か起きて6時半に起きた。移動日の疲れもあってか、いつもよりよく眠れた気がする。&lt;/p>
&lt;h2 id="朝食バイキング">朝食バイキング&lt;/h2>
&lt;p>&lt;a href="/diary/diary/posts/2023/0919/#大崎に泊まる">先々月から大崎探索&lt;/a> をしていて &lt;a href="https://www.newotani-inntokyo.jp/">ニューオータニイン東京&lt;/a> に泊まってみた。川沿いの道を歩きながら朝食バイキングもおいしい。食品の品数があると満足度が高い。&lt;/p>
&lt;figure>&lt;img src="/diary/diary/img/2023/1101_breakfast.jpg"/>
&lt;/figure>
&lt;h2 id="プロジェクトの進捗報告">プロジェクトの進捗報告&lt;/h2>
&lt;p>出張したときの月例報告の11回目。&lt;a href="/diary/diary/posts/2023/0920/">前回の進捗報告はこちら&lt;/a> 。&lt;/p>
&lt;p>まだ開発の序盤なので &lt;a href="/diary/diary/posts/2023/1028/#近況報告の資料作り">事前に準備した資料&lt;/a> の内容を一通り終えて雑談の時間も多かったように思う。3回目の開発フェーズになるのもあり、メンバーの練度も上がって、開発の手際はかなりよくなっているように私からはみえている。それらも含めて、メンバーが自律的に issue を作ったり、タスクを自分に割り当てたりしながら開発が進むようになっていると報告した。プロジェクトオーナーからも、最近のマイルストーン定例をみていて、メンバーが気付きが増えている、自律的によくないところを改善しようという意思がみえるといった話題も出ていた。課題管理のプラクティスを実践してきて、着実によい開発者の習慣を身につけて、よい開発チームに育ってきているように、私からもみえている。あとは課題管理についてのコンテンツを私が書かないといけないのを、バーンナウトの影響もあってか、先月はさぼってしまっていたので、今月こそなんか書きますと、自分を追い込む意図でもその場で話題にした。&lt;/p>
&lt;h2 id="mongo-とトランザクションとレプリカセット">mongo とトランザクションとレプリカセット&lt;/h2>
&lt;p>mongo には &lt;a href="https://www.mongodb.com/docs/manual/core/transactions/">トランザクション&lt;/a> の機能が提供されている。しかし、トランザクションを使うためには &lt;a href="https://www.mongodb.com/docs/v7.0/replication/">レプリケーション&lt;/a> を有効にしないといけない。レプリケーションは通常は複数台のマシンでクラスタリングを構築するものになる。うちらはシングルノードの mongo を扱っているのでレプリケーションを必要としていない。それでも、ドキュメントを読んでいると、スタンドアローンでも本番環境ではレプリカセットを使う方がよいといった説明もみつかる。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.mongodb.com/docs/manual/tutorial/convert-standalone-to-replica-set/">Convert a Standalone mongod to a Replica Set&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>ちょうど開発の要件としてトランザクションを必要とする状況も出てきた。mongo のレプリケーションやトランザクションの仕組みを理解するよい機会かもしれない。11月中には調査したいというところ。&lt;/p>
&lt;h2 id="エビスバー">エビスバー&lt;/h2>
&lt;p>大崎探検の2日目。&lt;a href="https://www.ginzalion.jp/shop/brand/yebisubar/shop60.html">YEBISU BAR 大崎店&lt;/a> へ行ってみた。大崎駅横の駅ビルの2階にある。アクセスもよい。水曜日なのに20-21時半ぐらいまでいて、お客さんは3組ぐらしかいなかった。よい意味で空いてて静かにゆっくり飲めてよかった。穴場のバーをみつけた。ビール2杯とつまみ2品でちょうど3000円程度。ちょっと割高かもしれないけど、場所とお店の雰囲気とゆっくりできたことを考慮するとちょうどよい価格帯にも思える。またゆっくり軽く飲みたいときに行こうと思う。&lt;/p>
&lt;p>&lt;figure>&lt;img src="/diary/diary/img/2023/1101_beer.jpg"/>
&lt;/figure>
&lt;figure>&lt;img src="/diary/diary/img/2023/1101_salad.jpg"/>
&lt;/figure>
&lt;figure>&lt;img src="/diary/diary/img/2023/1101_potate.jpg"/>
&lt;/figure>
&lt;/p></content></item><item><title>相続税の申告の一歩手前</title><link>/diary/posts/2023/1004/</link><pubDate>Wed, 04 Oct 2023 08:26:17 +0900</pubDate><guid>/diary/posts/2023/1004/</guid><description>22時頃から寝始めて何度か起きて6時に起きた。早寝早起き。
会計士事務所への訪問 相続税の申告手続きを未だにやっている。
父が失くなったのが 昨年の12月26日 になる。相続税は死亡を知った日から10ヶ月以内と期限が決められている。それを過ぎると算税や延滞税などのペナルティが科せられる。うちの期限は10月26日になる。1-3月ぐらい葬儀やらお仕事やらで忙しかったものの、4月ぐらいから相続の手続きに着手した。5月29日に親族の相続関連の書類を取りまとめて弁護士さんへ送付した。それから銀行口座の解約やら司法書士さんやら税理士さんの作業やらなんやらあって、いまもまだ会計士さんに申告の書類を作ってもらっているところ。その過程でいくつか質疑応答があってそれを調査したりしている。
その会計士さんの事務所が近所にあるのでお昼に訪問して挨拶してきた。申告に必要な書類の提出をしつつ軽く打ち合わせをした。税務署は20年遡って口座のお金を動きを調べるらしい。話しているときに死亡保険金とかないですか？と聞かれて、母が受けとったと話していたなと思い出して、それも父の遺産として扱う必要がありますと言われて、確かにそうだと思って申告漏れしていることに気付いた。これで死亡保険金の書類が必要になってまた取り寄せに時間がかかる。こんな感じに五月雨式に遅れていくので10ヶ月ぎりぎりになりそうな雰囲気。来週中に申告が終わる嬉しいなといったところ。
mongodb の初期化ツール ちょっと前から少しずつ mongodb の初期化ツールを作っている。コレクションの作成ならびにインデックスの追加を、さらに初期データの投入も制御したい。mongodb のバージョンが 6.0.x のときは作成済みのコレクションに対して同じ設定で作成しようとすると、既に作成済みというエラーが発生していた。それが 7.0.x になってエラーにならないようになっていることに気付いた。調べてみると、次の issue で同じ設定なら作成の結果に関係なく冪等であるのでエラーとして扱わなくてよいという考え方になる。
Make create command idempotent on mongod これは初期化ツールを作っている私にとっては朗報で、同じコレクションに対して複数の操作をしても変更した設定だけが有効になるといった振る舞いをする。こういう細かい所もバージョンアップをしながら改善していくことが伺えて学びになった。</description><content>&lt;p>22時頃から寝始めて何度か起きて6時に起きた。早寝早起き。&lt;/p>
&lt;h2 id="会計士事務所への訪問">会計士事務所への訪問&lt;/h2>
&lt;p>相続税の申告手続きを未だにやっている。&lt;/p>
&lt;p>父が失くなったのが &lt;a href="/diary/diary/posts/2022/1226/">昨年の12月26日&lt;/a> になる。相続税は死亡を知った日から10ヶ月以内と期限が決められている。それを過ぎると算税や延滞税などのペナルティが科せられる。うちの期限は10月26日になる。1-3月ぐらい葬儀やらお仕事やらで忙しかったものの、4月ぐらいから相続の手続きに着手した。5月29日に親族の相続関連の書類を取りまとめて弁護士さんへ送付した。それから銀行口座の解約やら司法書士さんやら税理士さんの作業やらなんやらあって、いまもまだ会計士さんに申告の書類を作ってもらっているところ。その過程でいくつか質疑応答があってそれを調査したりしている。&lt;/p>
&lt;p>その会計士さんの事務所が近所にあるのでお昼に訪問して挨拶してきた。申告に必要な書類の提出をしつつ軽く打ち合わせをした。税務署は20年遡って口座のお金を動きを調べるらしい。話しているときに死亡保険金とかないですか？と聞かれて、母が受けとったと話していたなと思い出して、それも父の遺産として扱う必要がありますと言われて、確かにそうだと思って申告漏れしていることに気付いた。これで死亡保険金の書類が必要になってまた取り寄せに時間がかかる。こんな感じに五月雨式に遅れていくので10ヶ月ぎりぎりになりそうな雰囲気。来週中に申告が終わる嬉しいなといったところ。&lt;/p>
&lt;h2 id="mongodb-の初期化ツール">mongodb の初期化ツール&lt;/h2>
&lt;p>ちょっと前から少しずつ mongodb の初期化ツールを作っている。コレクションの作成ならびにインデックスの追加を、さらに初期データの投入も制御したい。mongodb のバージョンが 6.0.x のときは作成済みのコレクションに対して同じ設定で作成しようとすると、既に作成済みというエラーが発生していた。それが 7.0.x になってエラーにならないようになっていることに気付いた。調べてみると、次の issue で同じ設定なら作成の結果に関係なく冪等であるのでエラーとして扱わなくてよいという考え方になる。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://jira.mongodb.org/browse/SERVER-60064">Make create command idempotent on mongod&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>これは初期化ツールを作っている私にとっては朗報で、同じコレクションに対して複数の操作をしても変更した設定だけが有効になるといった振る舞いをする。こういう細かい所もバージョンアップをしながら改善していくことが伺えて学びになった。&lt;/p></content></item><item><title>資料作りの一日</title><link>/diary/posts/2023/0914/</link><pubDate>Thu, 14 Sep 2023 20:35:21 +0900</pubDate><guid>/diary/posts/2023/0914/</guid><description>23時に寝て何度か起きて6時に起きた。疲労も溜まっているのでなるべく早く寝るように努めている。旅行中ずっと早起きしていたから早起きするのは苦にならない。
今開発の大きなふりかえりの資料作り ふりかえりのために課題管理システムの issue 情報から統計的な数値を取得する。
gitlab の cli ツールを使って issue 情報を取得して mongodb にインポートする。
$ glab api --paginate &amp;#34;groups/product%2Funicorncidm/issues?milestone=2023-09-05&amp;amp;not[labels]=Duplicate,Invalid,Wontfix&amp;#34; | jq -c &amp;#39;.[]&amp;#39; &amp;gt; 2023-09-05-issues.json $ mongoimport --authenticationDatabase=admin --uri &amp;#34;mongodb://root:secret@localhost:27017&amp;#34; --db gitlab --collection issues 2023-09-05-issues.json mongodb で aggregation (sql で言うところの group by 句に相当する) するときはパイプライン処理を実装する。例えば、最初にデータをフィルターして、次にグルーピングして、最後にソートするのは次のようなパラメーターになる。
$ mongosh --username root --password secret test&amp;gt; use gitlab gitlab&amp;gt; db.issues.aggregate([ { $match: { $or: [ { &amp;#34;milestone.title&amp;#34;: &amp;#34;2023-09-05&amp;#34; },{ &amp;#34;milestone.title&amp;#34;: &amp;#34;2023-09-19&amp;#34; } ] } }, { $group: { &amp;#34;_id&amp;#34;: { milestone: &amp;#34;$milestone.</description><content>&lt;p>23時に寝て何度か起きて6時に起きた。疲労も溜まっているのでなるべく早く寝るように努めている。旅行中ずっと早起きしていたから早起きするのは苦にならない。&lt;/p>
&lt;h2 id="今開発の大きなふりかえりの資料作り">今開発の大きなふりかえりの資料作り&lt;/h2>
&lt;p>ふりかえりのために課題管理システムの issue 情報から統計的な数値を取得する。&lt;/p>
&lt;p>gitlab の &lt;a href="https://gitlab.com/gitlab-org/cli">cli&lt;/a> ツールを使って issue 情報を取得して mongodb にインポートする。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ glab api --paginate &lt;span style="color:#e6db74">&amp;#34;groups/product%2Funicorncidm/issues?milestone=2023-09-05&amp;amp;not[labels]=Duplicate,Invalid,Wontfix&amp;#34;&lt;/span> | jq -c &lt;span style="color:#e6db74">&amp;#39;.[]&amp;#39;&lt;/span> &amp;gt; 2023-09-05-issues.json
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ mongoimport --authenticationDatabase&lt;span style="color:#f92672">=&lt;/span>admin --uri &lt;span style="color:#e6db74">&amp;#34;mongodb://root:secret@localhost:27017&amp;#34;&lt;/span> --db gitlab --collection issues 2023-09-05-issues.json
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>mongodb で aggregation (sql で言うところの group by 句に相当する) するときはパイプライン処理を実装する。例えば、最初にデータをフィルターして、次にグルーピングして、最後にソートするのは次のようなパラメーターになる。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ mongosh --username root --password secret
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>test&amp;gt; use gitlab
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>gitlab&amp;gt; db.issues.aggregate&lt;span style="color:#f92672">([&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">{&lt;/span> $match: &lt;span style="color:#f92672">{&lt;/span> $or: &lt;span style="color:#f92672">[&lt;/span> &lt;span style="color:#f92672">{&lt;/span> &lt;span style="color:#e6db74">&amp;#34;milestone.title&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;2023-09-05&amp;#34;&lt;/span> &lt;span style="color:#f92672">}&lt;/span>,&lt;span style="color:#f92672">{&lt;/span> &lt;span style="color:#e6db74">&amp;#34;milestone.title&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;2023-09-19&amp;#34;&lt;/span> &lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#f92672">}&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">{&lt;/span> $group: &lt;span style="color:#f92672">{&lt;/span> &lt;span style="color:#e6db74">&amp;#34;_id&amp;#34;&lt;/span>: &lt;span style="color:#f92672">{&lt;/span> milestone: &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$milestone&lt;span style="color:#e6db74">.title&amp;#34;&lt;/span> , author: &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$author&lt;span style="color:#e6db74">.username&amp;#34;&lt;/span> &lt;span style="color:#f92672">}&lt;/span>, councount: &lt;span style="color:#f92672">{&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$sum&lt;span style="color:#e6db74">&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#f92672">}&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">{&lt;/span> $sort: &lt;span style="color:#f92672">{&lt;/span> _id: &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">])&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これで前回の開発のときに取得した数値と今回の開発の数値を比較してみると、いろいろわかることもあって、メンバーが成長していることも伺えて、課題管理をしながら開発を進めることのメリットを実感できる開発になったのではないかと思う。gitlab のアクティビティ図 (草生え図) をみても前回の開発よりも草がたくさん生えているので課題管理に習熟している様子が伺える。これをあと2-3年ぐらいすれば、課題管理を使いこなせる一般の開発者になるのではないかと思う。課題管理 + イテレーション開発でチームビルディングしていくところの、地盤のようなものはできたようにみえる。&lt;/p>
&lt;p>この草生え図を匿名化して利用許可をもらって、うちの会社でいうところの課題管理ができるようになると、メンバーの働き方はこうなるというサンプルとして紹介させてもらうつもり。また来週メンバーにもその許諾を取ろうと思う。&lt;/p>
&lt;h2 id="次開発の要件打ち合わせの資料作り">次開発の要件打ち合わせの資料作り&lt;/h2>
&lt;p>今開発を始めるときに洗い出した要件の未対応のものと、今開発でやり残した非機能要件の開発課題を資料にまとめてたたき台とした。それだけでも3-4ヶ月分の開発課題になりそうだし、アーキテクチャとして大きな意思決定も1つある。私自身、7割型は決まっているが、考え方や要件によってはもう1つの案でいくのもよいかもしれない。機能要件は実際にお客さん先へ導入するときにもいくつか出てくるだろうけれど、非機能要件の運用に影響を与える懸念のところはなるべく早く改善しておきたい。次の開発期間にそこだけ対応すれば、一定の安心をもってお客さんへ提供できるようになると思う。&lt;/p></content></item><item><title>お盆の最終日</title><link>/diary/posts/2023/0816/</link><pubDate>Wed, 16 Aug 2023 13:44:29 +0900</pubDate><guid>/diary/posts/2023/0816/</guid><description>1時に寝て何度か起きて8時半に起きた。数ヶ月に1回ぐらいの頻度でしかないことだけど寝坊した。起きたら8時半であれ？と思った。起きてから家でそのぐらいの時間までだらだらするのはちょくちょくあることだけど、気付かず寝てたのは久しぶりだった。
台風が過ぎた後の焼き鳥屋さん 今朝に寝坊した理由はこれだと思うけれど、昨日の22時から晩ご飯を求めて仲のよい焼き鳥屋さんへ行ってきた。台風で9割以上のお店が閉めている中、唯一と言っていいぐらいの珍しさで開いてた。そのお店 (グループ) のオーナーは雨が降ろうが槍が降ろうが営業日は開けるという方針らしい。マスターも夕方から台風は過ぎて雨も弱まっていたので普通に営業していたらしい。しかし、お客さんは数グループと少なかったと仰っていた。私が22時に行って誰もいなくて24時までいたけれど、誰も来なかった。通常なら22時だと他に2-3グループはいて、その後も最低でも1グループは飲みにやってくるぐらいの人気のある焼き鳥屋さんだ。そもそも駅から人が出てこないし、道にも人が歩いていない。物流も止まっていたのでいくつか仕入れが出来なくて提供できないメニューもあった。
いつもなら2杯飲んで帰るところを、こんな日だから売上に貢献しようと思って3杯飲んで寝坊した気がする。
mongodb 7.0.0 リリース ちょうど qa テスト前で mongodb のメジャーバージョンがリリースされそうなので毎週のようにチェックしていた。rc10 までいって ga されたみたい。
MongoDB 7.0.0 is released まだ docker hub には正式なリリースバージョンのコンテナイメージは公開されていない。しかし、rc10 が ga になったはずなのでひとまずはそれを使って開発環境とテスト環境を 7.0.0 に移行した。うちの用途だと ttl インデックスを作り直す以外には移行作業は必要なかった。自動テストはそのまま成功したし、テスト環境のデータもそのまま移行してパッとみた感じでは正常に動いている。来週から qa テストも始まるのでぎりぎり間に合ったというところ。MongoDB Software Lifecycle Schedules によると、だいたい mongodb は3年サポートされる。メジャーバージョンが年に1回リリースされているようにみえるので、いまメジャーバージョンを上げておくと1年余裕をもって運用できる。
テックブログの執筆開始 お昼からテックブログの執筆に着手した。あまり大きな意味はないのだけど、お手伝い先のテックブログの記事を早く3つ書きたかった。別に三部作というわけでもない。けれど、テックブログ書いてますよと他者へ伝えるときに最低3つぐらい記事を書いていないと、全然書いてないやんと私なら思ってしまう。3つぐらいあれば、この人はこういう技術に関心があるんだ、こんな業務をやっているんだ、内容もしっかり書けているねとか、そういう判断を下すことができる最低限のコンテンツ量と言えるのではないだろうか。私にとってはそれが3つの記事と言える。ちょっと前に公開した podcast でテックブログの記事を読んでくださいと話したのでリスナーが聞く前に増やしておきたい。ちょうどプロダクトのプレスリリースも出たのでその宣伝も兼ねられるし、勉強会のネタにもなるし、私の義務感を軽減してストレス解消にもなるし、ここは踏ん張って今日・明日で下書きを書き終えたい。</description><content>&lt;p>1時に寝て何度か起きて8時半に起きた。数ヶ月に1回ぐらいの頻度でしかないことだけど寝坊した。起きたら8時半であれ？と思った。起きてから家でそのぐらいの時間までだらだらするのはちょくちょくあることだけど、気付かず寝てたのは久しぶりだった。&lt;/p>
&lt;h2 id="台風が過ぎた後の焼き鳥屋さん">台風が過ぎた後の焼き鳥屋さん&lt;/h2>
&lt;p>今朝に寝坊した理由はこれだと思うけれど、昨日の22時から晩ご飯を求めて仲のよい焼き鳥屋さんへ行ってきた。台風で9割以上のお店が閉めている中、唯一と言っていいぐらいの珍しさで開いてた。そのお店 (グループ) のオーナーは雨が降ろうが槍が降ろうが営業日は開けるという方針らしい。マスターも夕方から台風は過ぎて雨も弱まっていたので普通に営業していたらしい。しかし、お客さんは数グループと少なかったと仰っていた。私が22時に行って誰もいなくて24時までいたけれど、誰も来なかった。通常なら22時だと他に2-3グループはいて、その後も最低でも1グループは飲みにやってくるぐらいの人気のある焼き鳥屋さんだ。そもそも駅から人が出てこないし、道にも人が歩いていない。物流も止まっていたのでいくつか仕入れが出来なくて提供できないメニューもあった。&lt;/p>
&lt;p>いつもなら2杯飲んで帰るところを、こんな日だから売上に貢献しようと思って3杯飲んで寝坊した気がする。&lt;/p>
&lt;h2 id="mongodb-700-リリース">mongodb 7.0.0 リリース&lt;/h2>
&lt;p>ちょうど qa テスト前で mongodb のメジャーバージョンがリリースされそうなので毎週のようにチェックしていた。rc10 までいって ga されたみたい。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.mongodb.com/community/forums/t/mongodb-7-0-0-is-released/239732">MongoDB 7.0.0 is released&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>まだ docker hub には正式なリリースバージョンのコンテナイメージは公開されていない。しかし、rc10 が ga になったはずなのでひとまずはそれを使って開発環境とテスト環境を 7.0.0 に移行した。うちの用途だと ttl インデックスを作り直す以外には移行作業は必要なかった。自動テストはそのまま成功したし、テスト環境のデータもそのまま移行してパッとみた感じでは正常に動いている。来週から qa テストも始まるのでぎりぎり間に合ったというところ。&lt;a href="https://www.mongodb.com/support-policy/lifecycles">MongoDB Software Lifecycle Schedules&lt;/a> によると、だいたい mongodb は3年サポートされる。メジャーバージョンが年に1回リリースされているようにみえるので、いまメジャーバージョンを上げておくと1年余裕をもって運用できる。&lt;/p>
&lt;h2 id="テックブログの執筆開始">テックブログの執筆開始&lt;/h2>
&lt;p>お昼からテックブログの執筆に着手した。あまり大きな意味はないのだけど、お手伝い先のテックブログの記事を早く3つ書きたかった。別に三部作というわけでもない。けれど、テックブログ書いてますよと他者へ伝えるときに最低3つぐらい記事を書いていないと、全然書いてないやんと私なら思ってしまう。3つぐらいあれば、この人はこういう技術に関心があるんだ、こんな業務をやっているんだ、内容もしっかり書けているねとか、そういう判断を下すことができる最低限のコンテンツ量と言えるのではないだろうか。私にとってはそれが3つの記事と言える。&lt;a href="/diary/diary/posts/2023/0815/#課題管理とプロジェクトマネージメントの話を熱く語る">ちょっと前に公開した podcast&lt;/a> でテックブログの記事を読んでくださいと話したのでリスナーが聞く前に増やしておきたい。ちょうどプロダクトのプレスリリースも出たのでその宣伝も兼ねられるし、勉強会のネタにもなるし、私の義務感を軽減してストレス解消にもなるし、ここは踏ん張って今日・明日で下書きを書き終えたい。&lt;/p></content></item><item><title>年一ゲストの podcast 収録</title><link>/diary/posts/2023/0809/</link><pubDate>Wed, 09 Aug 2023 23:43:36 +0900</pubDate><guid>/diary/posts/2023/0809/</guid><description>夕方に寝て晩ご飯食べてきて23時に寝て7時に起きた。起きてから podcast のネタ帳を書いていた。本当は前日の夜に書くと宣言したものの、夜は眠くて普通に寝てた。
mongodb のインデックス追加 テスト環境の履歴テーブルにドキュメントが135万件ほど入っている。管理画面の履歴一覧を表示すると、一覧がレンダリングされるのに約1秒かかるようになった。遅い。インデックスなしでフルスキャンしているのでデフォルトのソートキーのインデックスが必要なことはすぐに想定できた。実際に compass でクエリを explain で実行してみるとフルスキャンしていることと、どのぐらいの時間がかかっているのかを計測できた。
デフォルトのソートキーのインデックスを追加すると explain の画面で数十 msec かかっていた時間が解消された。ソートキーに対して自動的にインデックスが使われることもわかった。
管理画面からも数十 msec で一覧が表示されるようになった。私の感覚ではひと昔のデータベースは10万件を超えたら1秒ぐらいかかった気はするが、いまはマシンスペックもミドルウェアの性能も上がっているのでそれが100万件超になったんだなという印象。実運用だとすぐに発生する問題が普通の開発をしていると気付きにくくなる懸念があることを学んだ。
podcast 収録 お仕事を終えてから、年一ゲストとして出演している terapyon channel の podcast の収録へ行ってきた。本当は6月頃に出演依頼が来ていたのを、私がお手伝いしている開発のプレスリリースや事例紹介が終わってからの方が話せる内容が多くてよいということで延期してもらっていた。事例紹介はまだ公開できていないけれど、別に事例紹介なくても先方にうちの会社が手伝っていることを公開してよい許可はもらっているので podcast の中で話してもまったく問題ない。
昨日てらださんとたまたまやり取りしていたときに、せっかく東京に来ているのでオフラインで収録しては？と言ったらその方向になって、翌日即収録という行き当たりばったりやっつけ計画で話しが進んだ。非商用の podcast で話すのでそこまで品質に責任をもつ必要もない。19時半にてらださんの会社のオフィスへ伺い、20時頃から収録を始めて、なんやらかんやら盛り上がって言いたい放題言って、2時間経っていた。オンラインで収録するよりも、オフラインの方がずっと多くのことを短い時間で話せるように感じた。相槌うったり会話の掛け合いがしやすいので間が短い気がする。内容的にはちょっと話し過ぎで聞く人は疲れて最後まで聞いてもらえないかもしれない。その後、近くの居酒屋さんへ飲みに行って1時間ほど飲んで24時前にはホテルへ戻ってきた。楽しかったー。
てらださんの近況の中に llm を使ってサービスを開発するときに LangChain というツールがあって、これを使うと簡単にいろんな言語処理ができて楽しいといったことを共有してもらった。いまは触る余裕がないけれど、覚えておきたい。</description><content>&lt;p>夕方に寝て晩ご飯食べてきて23時に寝て7時に起きた。起きてから podcast のネタ帳を書いていた。本当は前日の夜に書くと宣言したものの、夜は眠くて普通に寝てた。&lt;/p>
&lt;h2 id="mongodb-のインデックス追加">mongodb のインデックス追加&lt;/h2>
&lt;p>テスト環境の履歴テーブルにドキュメントが135万件ほど入っている。管理画面の履歴一覧を表示すると、一覧がレンダリングされるのに約1秒かかるようになった。遅い。インデックスなしでフルスキャンしているのでデフォルトのソートキーのインデックスが必要なことはすぐに想定できた。実際に &lt;a href="https://www.mongodb.com/ja-jp/products/compass">compass&lt;/a> でクエリを explain で実行してみるとフルスキャンしていることと、どのぐらいの時間がかかっているのかを計測できた。&lt;/p>
&lt;figure>&lt;img src="/diary/diary/img/2023/0809_mongodb-explain1.png"/>
&lt;/figure>
&lt;p>デフォルトのソートキーのインデックスを追加すると explain の画面で数十 msec かかっていた時間が解消された。ソートキーに対して自動的にインデックスが使われることもわかった。&lt;/p>
&lt;figure>&lt;img src="/diary/diary/img/2023/0809_mongodb-explain2.png"/>
&lt;/figure>
&lt;p>管理画面からも数十 msec で一覧が表示されるようになった。私の感覚ではひと昔のデータベースは10万件を超えたら1秒ぐらいかかった気はするが、いまはマシンスペックもミドルウェアの性能も上がっているのでそれが100万件超になったんだなという印象。実運用だとすぐに発生する問題が普通の開発をしていると気付きにくくなる懸念があることを学んだ。&lt;/p>
&lt;h2 id="podcast-収録">podcast 収録&lt;/h2>
&lt;p>お仕事を終えてから、年一ゲストとして出演している &lt;a href="https://podcast.terapyon.net/">terapyon channel&lt;/a> の podcast の収録へ行ってきた。本当は6月頃に出演依頼が来ていたのを、私がお手伝いしている開発のプレスリリースや事例紹介が終わってからの方が話せる内容が多くてよいということで延期してもらっていた。事例紹介はまだ公開できていないけれど、別に事例紹介なくても先方にうちの会社が手伝っていることを公開してよい許可はもらっているので podcast の中で話してもまったく問題ない。&lt;/p>
&lt;p>昨日てらださんとたまたまやり取りしていたときに、せっかく東京に来ているのでオフラインで収録しては？と言ったらその方向になって、翌日即収録という行き当たりばったりやっつけ計画で話しが進んだ。非商用の podcast で話すのでそこまで品質に責任をもつ必要もない。19時半にてらださんの会社のオフィスへ伺い、20時頃から収録を始めて、なんやらかんやら盛り上がって言いたい放題言って、2時間経っていた。オンラインで収録するよりも、オフラインの方がずっと多くのことを短い時間で話せるように感じた。相槌うったり会話の掛け合いがしやすいので間が短い気がする。内容的にはちょっと話し過ぎで聞く人は疲れて最後まで聞いてもらえないかもしれない。その後、近くの居酒屋さんへ飲みに行って1時間ほど飲んで24時前にはホテルへ戻ってきた。楽しかったー。&lt;/p>
&lt;p>てらださんの近況の中に llm を使ってサービスを開発するときに &lt;a href="https://www.langchain.com/">LangChain&lt;/a> というツールがあって、これを使うと簡単にいろんな言語処理ができて楽しいといったことを共有してもらった。いまは触る余裕がないけれど、覚えておきたい。&lt;/p></content></item><item><title>リフレクションにはまった半日</title><link>/diary/posts/2023/0703/</link><pubDate>Mon, 03 Jul 2023 07:35:25 +0900</pubDate><guid>/diary/posts/2023/0703/</guid><description>23時に寝て5時に起きて6時半に起きた。ストレッチで伸ばしたせいか、いつもよりよく眠れた。先週は主に旅行へ行っていて非日常でリフレッシュした。今朝は朝ご飯に野菜サラダを作って食べて7時半には家を出れた。
非同期の ldap 検索の api 先日送った go-ldap の pr を完了した。送ったときはチャンネル用いた検索 api だったのだけど、それから設計を議論して非同期検索を主とした api として生まれ変わった。レビューに1ヶ月を要したものの2人のメンバーから approve をもらって無事にマージされた。
Add search asynchronously with context #440 この一歩は大きくてこの機能を突破口にうちらの要件に足りない機能を実装していく。プロトコル部分の修正が過去の draft 実装から参考にできるのであれば今週中にはまた pr を送りたい。
mongodb の unmarshal 実装 mongodb-driver での bson の marshal/unmarshal を実装する。mongo-driver/bson に unmarshal について2つの interface が紹介されている。
type Unmarshaler interface { UnmarshalBSON([]byte) error } type ValueUnmarshaler interface { UnmarshalBSONValue(bsontype.Type, []byte) error } bson の byte 列を unmarshal するにあたり、構造体そのものには UnmarshalBSON() を、構造体のメンバーには UnmarshalBSONValue() を使う。これでうまくいきそうに思えたのだけど、interface を介したデコード処理で意図した振る舞いにならないことに気付いた。mongodb-driver は decode/unmarshal 処理を reflect を使って実装している。要件の詳細は省く (interface を使いたい背景がある) が、再現コードが次になる。</description><content>&lt;p>23時に寝て5時に起きて6時半に起きた。ストレッチで伸ばしたせいか、いつもよりよく眠れた。先週は主に旅行へ行っていて非日常でリフレッシュした。今朝は朝ご飯に野菜サラダを作って食べて7時半には家を出れた。&lt;/p>
&lt;h2 id="非同期の-ldap-検索の-api">非同期の ldap 検索の api&lt;/h2>
&lt;p>先日送った &lt;a href="/diary/diary/posts/2023/0601/#チャンネルを用いた-ldap-検索の-api">go-ldap の pr&lt;/a> を完了した。送ったときはチャンネル用いた検索 api だったのだけど、それから設計を議論して非同期検索を主とした api として生まれ変わった。レビューに1ヶ月を要したものの2人のメンバーから approve をもらって無事にマージされた。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/go-ldap/ldap/pull/440">Add search asynchronously with context #440&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>この一歩は大きくてこの機能を突破口にうちらの要件に足りない機能を実装していく。プロトコル部分の修正が過去の draft 実装から参考にできるのであれば今週中にはまた pr を送りたい。&lt;/p>
&lt;h2 id="mongodb-の-unmarshal-実装">mongodb の unmarshal 実装&lt;/h2>
&lt;p>mongodb-driver での bson の marshal/unmarshal を実装する。&lt;a href="https://pkg.go.dev/go.mongodb.org/mongo-driver/bson">mongo-driver/bson&lt;/a> に unmarshal について2つの interface が紹介されている。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Unmarshaler&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">UnmarshalBSON&lt;/span>([]&lt;span style="color:#66d9ef">byte&lt;/span>) &lt;span style="color:#66d9ef">error&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">ValueUnmarshaler&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">UnmarshalBSONValue&lt;/span>(&lt;span style="color:#a6e22e">bsontype&lt;/span>.&lt;span style="color:#a6e22e">Type&lt;/span>, []&lt;span style="color:#66d9ef">byte&lt;/span>) &lt;span style="color:#66d9ef">error&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>bson の byte 列を unmarshal するにあたり、構造体そのものには &lt;code>UnmarshalBSON()&lt;/code> を、構造体のメンバーには &lt;code>UnmarshalBSONValue()&lt;/code> を使う。これでうまくいきそうに思えたのだけど、interface を介したデコード処理で意図した振る舞いにならないことに気付いた。mongodb-driver は decode/unmarshal 処理を &lt;a href="https://pkg.go.dev/reflect">reflect&lt;/a> を使って実装している。要件の詳細は省く (interface を使いたい背景がある) が、再現コードが次になる。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">MyInterface&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">MyFunc&lt;/span>() &lt;span style="color:#66d9ef">error&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">MyType&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">MyType&lt;/span>) &lt;span style="color:#a6e22e">MyFunc&lt;/span>() &lt;span style="color:#66d9ef">error&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">tMyInterface&lt;/span> = &lt;span style="color:#a6e22e">reflect&lt;/span>.&lt;span style="color:#a6e22e">TypeOf&lt;/span>((&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">MyInterface&lt;/span>)(&lt;span style="color:#66d9ef">nil&lt;/span>)).&lt;span style="color:#a6e22e">Elem&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">some&lt;/span>(&lt;span style="color:#a6e22e">v&lt;/span> &lt;span style="color:#a6e22e">reflect&lt;/span>.&lt;span style="color:#a6e22e">Value&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">f&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">v&lt;/span>.&lt;span style="color:#a6e22e">Convert&lt;/span>(&lt;span style="color:#a6e22e">tMyInterface&lt;/span>).&lt;span style="color:#a6e22e">MethodByName&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;MyFunc&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;got&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">f&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;=========&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">t1&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">MyType&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">some&lt;/span>(&lt;span style="color:#a6e22e">reflect&lt;/span>.&lt;span style="color:#a6e22e">ValueOf&lt;/span>(&lt;span style="color:#a6e22e">t1&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// the zero value of an interface is nil
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">t2&lt;/span> &lt;span style="color:#a6e22e">MyInterface&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">some&lt;/span>(&lt;span style="color:#a6e22e">reflect&lt;/span>.&lt;span style="color:#a6e22e">ValueOf&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">t2&lt;/span>).&lt;span style="color:#a6e22e">Elem&lt;/span>())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このコードを実行すると次のエラーになる。&lt;/p>
&lt;pre tabindex="0">&lt;code>panic: reflect: Method on nil interface value
&lt;/code>&lt;/pre>&lt;p>ドキュメントにも interface の nil の値を呼び出すと panic するよと書いてある。&lt;/p>
&lt;blockquote>
&lt;p>Method returns a function value corresponding to v&amp;rsquo;s i&amp;rsquo;th method. The arguments to a Call on the returned function should not include a receiver; the returned function will always use v as the receiver. Method panics if i is out of range or if v is a nil interface value.&lt;/p>
&lt;p>&lt;a href="https://pkg.go.dev/reflect#Value.Method">https://pkg.go.dev/reflect#Value.Method&lt;/a>&lt;/p>
&lt;/blockquote></content></item><item><title>gitlab issues と mongodb による分析</title><link>/diary/posts/2023/0511/</link><pubDate>Thu, 11 May 2023 09:06:56 +0900</pubDate><guid>/diary/posts/2023/0511/</guid><description>0時に寝て何度か起きて7時に起きた。今日も一日資料作りをしていた。
gitlab issues の解析 ふりかえりの資料を作っていて gitlab issues の解析を始めた。gitlab にも分析系機能は提供されているが、大半が有償機能で free では使えない。実質 free で役に立ちそうなレポートを私はみつけられなかった。
Analyze GitLab usage gitlab は glab cli というツールを提供している。試しに glab を使って issues の解析ができないかとやってみたが、グループ単位ではなくプロジェクト単位でしか操作できないようにみえた。そこで rest api を呼び出すための便利ツールとして使うことにした。要は rest api で任意のデータを取得してそれを使ってローカルで解析することにした。例えば、次のようにして特定ラベルを除外した特定グループのマイルストーンごとの issues をすべて取得できる。
$ mygrpid=&amp;#34;xxx&amp;#34; $ milestones=&amp;#34;2022-11 2022-12 2023-01 2023-02 2023-03 2023-04&amp;#34; $ for i in $milestones; do echo $i; glab api --paginate &amp;#34;groups/${mygrpid}/issues?milestone=${i}&amp;amp;not[labels]=Duplicate,Invalid,Wontfix&amp;#34; | jq -c &amp;#39;.[]&amp;#39; &amp;gt; &amp;#34;${i}-issues.json&amp;#34;; done あとはこの json データをそのまま分析のためのデータベースに取り込む。今回は mongodb にインポートしてみた。mongodb だとスキーマを定義しなくても json データをそのままインポートできてアドホックな分析に便利そうに思えた。オブジェクトの入れ子構造をもつ json データのようなものを rdbms にインポートするのはひと工夫必要なことから json データをそのままインポートできるドキュメントデータベースの有効性を理解できた。インポートしたら MongoDB Shell を使うとてっとり早い。例えば、マイルストーンごとの issues の件数などは次のようにして集計できる。</description><content>&lt;p>0時に寝て何度か起きて7時に起きた。今日も一日資料作りをしていた。&lt;/p>
&lt;h2 id="gitlab-issues-の解析">gitlab issues の解析&lt;/h2>
&lt;p>ふりかえりの資料を作っていて gitlab issues の解析を始めた。gitlab にも分析系機能は提供されているが、大半が有償機能で free では使えない。実質 free で役に立ちそうなレポートを私はみつけられなかった。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.gitlab.com/ee/user/analytics/">Analyze GitLab usage&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>gitlab は &lt;a href="https://gitlab.com/gitlab-org/cli">glab cli&lt;/a> というツールを提供している。試しに glab を使って issues の解析ができないかとやってみたが、グループ単位ではなくプロジェクト単位でしか操作できないようにみえた。そこで rest api を呼び出すための便利ツールとして使うことにした。要は rest api で任意のデータを取得してそれを使ってローカルで解析することにした。例えば、次のようにして特定ラベルを除外した特定グループのマイルストーンごとの issues をすべて取得できる。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ mygrpid&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;xxx&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ milestones&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;2022-11 2022-12 2023-01 2023-02 2023-03 2023-04&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ &lt;span style="color:#66d9ef">for&lt;/span> i in $milestones; &lt;span style="color:#66d9ef">do&lt;/span> echo $i; glab api --paginate &lt;span style="color:#e6db74">&amp;#34;groups/&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>mygrpid&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/issues?milestone=&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>i&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;amp;not[labels]=Duplicate,Invalid,Wontfix&amp;#34;&lt;/span> | jq -c &lt;span style="color:#e6db74">&amp;#39;.[]&amp;#39;&lt;/span> &amp;gt; &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>i&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">-issues.json&amp;#34;&lt;/span>; &lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>あとはこの json データをそのまま分析のためのデータベースに取り込む。今回は mongodb にインポートしてみた。mongodb だとスキーマを定義しなくても json データをそのままインポートできてアドホックな分析に便利そうに思えた。オブジェクトの入れ子構造をもつ json データのようなものを rdbms にインポートするのはひと工夫必要なことから json データをそのままインポートできるドキュメントデータベースの有効性を理解できた。インポートしたら &lt;a href="https://www.mongodb.com/products/shell">MongoDB Shell&lt;/a> を使うとてっとり早い。例えば、マイルストーンごとの issues の件数などは次のようにして集計できる。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>gitlab&amp;gt; db.issues.aggregate&lt;span style="color:#f92672">([{&lt;/span> $group: &lt;span style="color:#f92672">{&lt;/span> &lt;span style="color:#e6db74">&amp;#34;_id&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$milestone&lt;span style="color:#e6db74">.title&amp;#34;&lt;/span>, count: &lt;span style="color:#f92672">{&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$sum&lt;span style="color:#e6db74">&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#f92672">}&lt;/span>, &lt;span style="color:#f92672">{&lt;/span> $sort: &lt;span style="color:#f92672">{&lt;/span> _id: &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">}}])&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">{&lt;/span> _id: &lt;span style="color:#e6db74">&amp;#39;2022-11&amp;#39;&lt;/span>, count: &lt;span style="color:#ae81ff">348&lt;/span> &lt;span style="color:#f92672">}&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">{&lt;/span> _id: &lt;span style="color:#e6db74">&amp;#39;2022-12&amp;#39;&lt;/span>, count: &lt;span style="color:#ae81ff">346&lt;/span> &lt;span style="color:#f92672">}&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">{&lt;/span> _id: &lt;span style="color:#e6db74">&amp;#39;2023-01&amp;#39;&lt;/span>, count: &lt;span style="color:#ae81ff">338&lt;/span> &lt;span style="color:#f92672">}&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">{&lt;/span> _id: &lt;span style="color:#e6db74">&amp;#39;2023-02&amp;#39;&lt;/span>, count: &lt;span style="color:#ae81ff">357&lt;/span> &lt;span style="color:#f92672">}&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">{&lt;/span> _id: &lt;span style="color:#e6db74">&amp;#39;2023-03&amp;#39;&lt;/span>, count: &lt;span style="color:#ae81ff">347&lt;/span> &lt;span style="color:#f92672">}&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">{&lt;/span> _id: &lt;span style="color:#e6db74">&amp;#39;2023-04&amp;#39;&lt;/span>, count: &lt;span style="color:#ae81ff">336&lt;/span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>担当者別に &lt;code>Enhance&lt;/code> ラベルが付いた issues の件数を数えるときには次のようになる。sql を使えないというデメリットを json データをそのままインポートできるメリットの方が上回るときは mongodb のクエリを学ぶ機会になる。私も mongodb の aggregation の実行方法をドキュメントみながらやってた。全然わからないので慣れが必要になる。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>gitlab&amp;gt; db.issues.aggregate&lt;span style="color:#f92672">([{&lt;/span> $group: &lt;span style="color:#f92672">{&lt;/span> &lt;span style="color:#e6db74">&amp;#34;_id&amp;#34;&lt;/span>: &lt;span style="color:#f92672">{&lt;/span> assignee: &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$assignee&lt;span style="color:#e6db74">.username&amp;#34;&lt;/span>, enhance: &lt;span style="color:#f92672">{&lt;/span>$in: &lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Enhance&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$labels&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#f92672">]}&lt;/span> &lt;span style="color:#f92672">}&lt;/span>, count: &lt;span style="color:#f92672">{&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$sum&lt;span style="color:#e6db74">&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#f92672">}&lt;/span>, &lt;span style="color:#f92672">{&lt;/span>$match: &lt;span style="color:#f92672">{&lt;/span>&lt;span style="color:#e6db74">&amp;#34;_id.enhance&amp;#34;&lt;/span>: true&lt;span style="color:#f92672">}}&lt;/span>, &lt;span style="color:#f92672">{&lt;/span> $sort: &lt;span style="color:#f92672">{&lt;/span> _id: &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">}}])&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">{&lt;/span> _id: &lt;span style="color:#f92672">{&lt;/span> assignee: &lt;span style="color:#e6db74">&amp;#39;bob&amp;#39;&lt;/span>, enhance: true &lt;span style="color:#f92672">}&lt;/span>, count: &lt;span style="color:#ae81ff">84&lt;/span> &lt;span style="color:#f92672">}&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">{&lt;/span> _id: &lt;span style="color:#f92672">{&lt;/span> assignee: &lt;span style="color:#e6db74">&amp;#39;john&amp;#39;&lt;/span>, enhance: true &lt;span style="color:#f92672">}&lt;/span>, count: &lt;span style="color:#ae81ff">143&lt;/span> &lt;span style="color:#f92672">}&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">{&lt;/span> _id: &lt;span style="color:#f92672">{&lt;/span> assignee: &lt;span style="color:#e6db74">&amp;#39;mary&amp;#39;&lt;/span>, enhance: true &lt;span style="color:#f92672">}&lt;/span>, count: &lt;span style="color:#ae81ff">53&lt;/span> &lt;span style="color:#f92672">}&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">{&lt;/span> _id: &lt;span style="color:#f92672">{&lt;/span> assignee: &lt;span style="color:#e6db74">&amp;#39;parks&amp;#39;&lt;/span>, enhance: true &lt;span style="color:#f92672">}&lt;/span>, count: &lt;span style="color:#ae81ff">78&lt;/span> &lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></content></item><item><title>一日中リファクタリング</title><link>/diary/posts/2023/0407/</link><pubDate>Fri, 07 Apr 2023 13:16:56 +0900</pubDate><guid>/diary/posts/2023/0407/</guid><description>0時に寝て7時に起きた。昨日は夜にホテルで作業しようと思いながらテレビをみているうちに寝落ちしてた。朝から夜までずっとリファクタリングのためにコードを書いたり、コンテナ環境の設定を変更したりしていた。
mongodb のコネクションプール MongoDB Drivers の Connection Example に次のようなことが書いてある。
Reuse Your Client
We recommend that you reuse your client across sessions and operations. You can use the same Client instance to perform multiple tasks, instead of creating a new one each time. The Client type is safe for concurrent use by multiple goroutines. To learn more about how connection pools work in the driver, see the FAQ page.
mongodb drivers の client は goroutine safe なので再利用することを推奨している。内部的にはコネクションプールをもっていて mongodb とのコネクションを再利用できる。具体的にはライブラリ内部に次のようなコードがみつかる。context にセッション情報があればそれを使い、なければクライアントの sessionPool (コネクションプール) を使ってセッションを取得して mongodb にアクセスする関数の終わりで終了処理を行う。</description><content>&lt;p>0時に寝て7時に起きた。昨日は夜にホテルで作業しようと思いながらテレビをみているうちに寝落ちしてた。朝から夜までずっとリファクタリングのためにコードを書いたり、コンテナ環境の設定を変更したりしていた。&lt;/p>
&lt;h2 id="mongodb-のコネクションプール">mongodb のコネクションプール&lt;/h2>
&lt;p>MongoDB Drivers の &lt;a href="https://www.mongodb.com/docs/drivers/go/current/fundamentals/connection/#connection-example">Connection Example&lt;/a> に次のようなことが書いてある。&lt;/p>
&lt;blockquote>
&lt;p>Reuse Your Client&lt;/p>
&lt;p>We recommend that you reuse your client across sessions and operations. You can use the same Client instance to perform multiple tasks, instead of creating a new one each time. The Client type is safe for concurrent use by multiple goroutines. To learn more about how connection pools work in the driver, see the &lt;a href="https://www.mongodb.com/docs/drivers/go/current/faq/#std-label-golang-faq-connection-pool">FAQ&lt;/a> page.&lt;/p>
&lt;/blockquote>
&lt;p>mongodb drivers の client は goroutine safe なので再利用することを推奨している。内部的にはコネクションプールをもっていて mongodb とのコネクションを再利用できる。具体的にはライブラリ内部に次のようなコードがみつかる。context にセッション情報があればそれを使い、なければクライアントの sessionPool (コネクションプール) を使ってセッションを取得して mongodb にアクセスする関数の終わりで終了処理を行う。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">sess&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">sessionFromContext&lt;/span>(&lt;span style="color:#a6e22e">ctx&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">sess&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#a6e22e">coll&lt;/span>.&lt;span style="color:#a6e22e">client&lt;/span>.&lt;span style="color:#a6e22e">sessionPool&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">sess&lt;/span> = &lt;span style="color:#a6e22e">session&lt;/span>.&lt;span style="color:#a6e22e">NewImplicitClientSession&lt;/span>(&lt;span style="color:#a6e22e">coll&lt;/span>.&lt;span style="color:#a6e22e">client&lt;/span>.&lt;span style="color:#a6e22e">sessionPool&lt;/span>, &lt;span style="color:#a6e22e">coll&lt;/span>.&lt;span style="color:#a6e22e">client&lt;/span>.&lt;span style="color:#a6e22e">id&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">defer&lt;/span> &lt;span style="color:#a6e22e">sess&lt;/span>.&lt;span style="color:#a6e22e">EndSession&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>既存のコードはコネクションプールのことを考慮していないコードになっていたので大きくリファクタリングして効率化した。&lt;/p>
&lt;h2 id="docker-hub-の-pull-制限">docker hub の pull 制限&lt;/h2>
&lt;p>午前中はリファクタリング、午後は docker compose 環境の変更と再構築、午後はバグ修正と一日中 docker image を取得する作業をしていた。gitlab ci/cd が動くとテストと docker image 生成の処理が動くのでその過程で関連する docker image を pull する。夕方になって gitlab ci/cd で初めて次のエラーが発生することに気付いた。前にお手伝いしていた職場でもそういう現象が起こると聞いて、docker login するコードを github actions のスクリプトに追加していたので、rate limit がかかることは知っていた。&lt;/p>
&lt;pre tabindex="0">&lt;code>You have reached your pull rate limit. You may increase the limit by authenticating and upgrading: https://www.docker.com/increase-rate-limits.
&lt;/code>&lt;/pre>&lt;p>&lt;a href="https://www.docker.com/increase-rate-limits/">Understanding Your Docker Hub Rate Limit&lt;/a> によると、6時間あたり匿名アクセスは100、
free ユーザーは200を上限としているらしい。匿名アクセスは ip アドレスでカウントしているのだろうから場合によっては会社内からのアクセスをすべてカウントされたりするかもしれない。課金するとこの上限が24時間あたり5000になる。docker hub のプライベートリポジトリを利用する意図で team プランの課金を検討していたが、docker hub のアクセス制限を緩和するために課金する必要があるかもしれない。&lt;/p></content></item><item><title>mongodb のトランザクションの考え方</title><link>/diary/posts/2023/0224/</link><pubDate>Fri, 24 Feb 2023 12:22:57 +0900</pubDate><guid>/diary/posts/2023/0224/</guid><description>1時に寝て8時に起きた。3時頃に気分悪くて起きて少し吐いてそれからまた寝た。丸1日機能拡張とリファクタリングのために go のコードを書いていた。
mongodb のトランザクション管理 2つの web api から同じコレクションの異なるフィールドを更新したい。mongodb で厳密なトランザクションを管理するようなアプリケーションではないけど、なるべく整合性を維持できるように努めることはやっておきたい。mongodb でトランザクションに近いことを実現する方法として次の記事が参考になった。
How To SELECT &amp;hellip; FOR UPDATE inside MongoDB Transactions この記事では findOneAndUpdate() という api を使って、更新時に必ず変更されるフィールドを含めることで find したときのそのフィールドの値が変わっていればエラーになってくれることでトランザクション相当の機能が提供されると書いてある。必ず変更されるフィールドとして ObjectId を使えば他の更新処理を検出するのに役立つだろうとある。いま私が開発しているアプリケーションでは同じフィールドを複数の web api から更新するわけではないのでここまで厳密なトランザクション管理は必要にない。
既存の処理が Replace を使って実装されていたのを Update を使うように変更する。Replace と Update の違いはドキュメント全体を更新するのか、一部のフィールドのみを更新するのかの違いになる。具体的には go のドライバーにおいて次のメソッドの使い分けになる。
FindOneAndReplace FindOneAndUpdate これらのメソッドを使うことで find と replace/update の操作を1回の処理でできるから効率もよいらしい。</description><content>&lt;p>1時に寝て8時に起きた。3時頃に気分悪くて起きて少し吐いてそれからまた寝た。丸1日機能拡張とリファクタリングのために go のコードを書いていた。&lt;/p>
&lt;h2 id="mongodb-のトランザクション管理">mongodb のトランザクション管理&lt;/h2>
&lt;p>2つの web api から同じコレクションの異なるフィールドを更新したい。mongodb で厳密なトランザクションを管理するようなアプリケーションではないけど、なるべく整合性を維持できるように努めることはやっておきたい。mongodb でトランザクションに近いことを実現する方法として次の記事が参考になった。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.mongodb.com/blog/post/how-to-select--for-update-inside-mongodb-transactions">How To SELECT &amp;hellip; FOR UPDATE inside MongoDB Transactions&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>この記事では &lt;code>findOneAndUpdate()&lt;/code> という api を使って、更新時に必ず変更されるフィールドを含めることで find したときのそのフィールドの値が変わっていればエラーになってくれることでトランザクション相当の機能が提供されると書いてある。必ず変更されるフィールドとして &lt;a href="https://www.mongodb.com/docs/manual/reference/method/ObjectId/">ObjectId&lt;/a> を使えば他の更新処理を検出するのに役立つだろうとある。いま私が開発しているアプリケーションでは同じフィールドを複数の web api から更新するわけではないのでここまで厳密なトランザクション管理は必要にない。&lt;/p>
&lt;p>既存の処理が &lt;a href="https://www.mongodb.com/docs/drivers/go/current/usage-examples/replaceOne/">Replace&lt;/a> を使って実装されていたのを &lt;a href="https://www.mongodb.com/docs/drivers/go/current/usage-examples/updateOne/">Update&lt;/a> を使うように変更する。Replace と Update の違いはドキュメント全体を更新するのか、一部のフィールドのみを更新するのかの違いになる。具体的には go のドライバーにおいて次のメソッドの使い分けになる。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://pkg.go.dev/go.mongodb.org/mongo-driver/mongo#Collection.FindOneAndReplace">FindOneAndReplace&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://pkg.go.dev/go.mongodb.org/mongo-driver/mongo#Collection.FindOneAndUpdate">FindOneAndUpdate&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>これらのメソッドを使うことで find と replace/update の操作を1回の処理でできるから効率もよいらしい。&lt;/p></content></item><item><title>mongodb の view 調査</title><link>/diary/posts/2023/0219/</link><pubDate>Sun, 19 Feb 2023 02:45:02 +0900</pubDate><guid>/diary/posts/2023/0219/</guid><description>4時半に寝て11時に起きた。午後から go のコードをリファクタリングしてた。平日はメンバーの issue を監視して困ってたらコメントしたり、マージリクエストをレビューしたり、管理画面の振る舞いを検証したりと、コードを書いていても途中で作業がちょくちょく中断する。休日にコードを書くとその中断がない分、いつもよりかなり捗った。リファクタリングに思いの外、時間を取られている気がしたのはそのせいもあるか。
mongodb の view 作成 実はこれまで mongodb を扱ったことがなくて今回初めて触っている。とくに難しくもないのだけど、ドキュメントを探してやりたいことを調べたり、デバッグや開発のためのツールとしてどういうものがあるかといった知見がない。ないものは仕方ないので1からドキュメントを読みながら開発というか、リファクタリングをしている。mongodb そのものの知見はなくても、様々なデータベースを操作する開発をしてきたのでやりたいことに対して実装方法はいくつか検討がつくし、その実装を支援するための機能もあるはずだと予測がつくので探すのも早い。
ある collection から複数のデータ構造のレスポンスを返すような処理がある。こういったものは view を使うとうまく整理できると知っているので調べると mongodb view が提供されていることがわかる。3.4 から追加されたらしい。いまクエリの中で aggregation pipeline を書いている処理のいくつかは、あらかじめ view を定義してクエリすることでインフラ層を堅牢にした上で実装もシンプルにできる。さらに 4.2 から on-demand materialized view が追加されていて、標準の view と比較して aggregation pipeline の計算結果をディスクに保持するのでパフォーマンス上のメリットがある。元データの更新が頻繁でなければ on-demand を使った方がよいのだろうと推測する。
またこれまで mongodb の管理画面に mongo-express を使っている。view の振る舞いを確認しようとしたところ、どうも view には対応していないようにみえる。web ベースの管理画面を他にも探してみたが、どうも他に適当なものがない。mongodb が公式に compass というデスクトップアプリケーションの gui クライアントを提供している。macos なら brew からインストールできた。
&amp;gt; brew install mongodb-compass このツールは collection も view も両方扱えるし、クエリやパイプラインも実行できて機能も充実している。web ベースじゃないとインフラとして共有はできないところだけが残念なところ。それでも開発する上ではとても強力なツールにみえる。適当にデータをインポートしたり、テストで aggregation pipeline を作成してみて、それをエクスポートして view を生成するときのスキーマ定義も作ることができた。ui も洗練していて、こんな優れたデスクトップアプリケーションは久しぶりにみたと思うぐらい感心した。</description><content>&lt;p>4時半に寝て11時に起きた。午後から go のコードをリファクタリングしてた。平日はメンバーの issue を監視して困ってたらコメントしたり、マージリクエストをレビューしたり、管理画面の振る舞いを検証したりと、コードを書いていても途中で作業がちょくちょく中断する。休日にコードを書くとその中断がない分、いつもよりかなり捗った。リファクタリングに思いの外、時間を取られている気がしたのはそのせいもあるか。&lt;/p>
&lt;h2 id="mongodb-の-view-作成">mongodb の view 作成&lt;/h2>
&lt;p>実はこれまで mongodb を扱ったことがなくて今回初めて触っている。とくに難しくもないのだけど、ドキュメントを探してやりたいことを調べたり、デバッグや開発のためのツールとしてどういうものがあるかといった知見がない。ないものは仕方ないので1からドキュメントを読みながら開発というか、リファクタリングをしている。mongodb そのものの知見はなくても、様々なデータベースを操作する開発をしてきたのでやりたいことに対して実装方法はいくつか検討がつくし、その実装を支援するための機能もあるはずだと予測がつくので探すのも早い。&lt;/p>
&lt;p>ある collection から複数のデータ構造のレスポンスを返すような処理がある。こういったものは view を使うとうまく整理できると知っているので調べると &lt;a href="https://www.mongodb.com/docs/manual/core/views/">mongodb view&lt;/a> が提供されていることがわかる。3.4 から追加されたらしい。いまクエリの中で &lt;a href="https://www.mongodb.com/docs/manual/core/aggregation-pipeline/#std-label-aggregation-pipeline">aggregation pipeline&lt;/a> を書いている処理のいくつかは、あらかじめ view を定義してクエリすることでインフラ層を堅牢にした上で実装もシンプルにできる。さらに 4.2 から &lt;a href="https://www.mongodb.com/docs/manual/core/materialized-views/#std-label-manual-materialized-views">on-demand materialized view&lt;/a> が追加されていて、標準の view と比較して aggregation pipeline の計算結果をディスクに保持するのでパフォーマンス上のメリットがある。元データの更新が頻繁でなければ on-demand を使った方がよいのだろうと推測する。&lt;/p>
&lt;p>またこれまで mongodb の管理画面に &lt;a href="https://github.com/mongo-express/mongo-express">mongo-express&lt;/a> を使っている。view の振る舞いを確認しようとしたところ、どうも view には対応していないようにみえる。web ベースの管理画面を他にも探してみたが、どうも他に適当なものがない。mongodb が公式に &lt;a href="https://www.mongodb.com/products/compass">compass&lt;/a> というデスクトップアプリケーションの gui クライアントを提供している。macos なら brew からインストールできた。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&amp;gt; brew install mongodb-compass
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このツールは collection も view も両方扱えるし、クエリやパイプラインも実行できて機能も充実している。web ベースじゃないとインフラとして共有はできないところだけが残念なところ。それでも開発する上ではとても強力なツールにみえる。適当にデータをインポートしたり、テストで aggregation pipeline を作成してみて、それをエクスポートして view を生成するときのスキーマ定義も作ることができた。ui も洗練していて、こんな優れたデスクトップアプリケーションは久しぶりにみたと思うぐらい感心した。&lt;/p></content></item></channel></rss>