<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Spring Boot on</title><link>/diary/tags/spring-boot/</link><description>Recent content in Spring Boot on</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Wed, 28 Sep 2022 08:20:18 +0900</lastBuildDate><atom:icon>/diary/favicon.ico</atom:icon><icon>/diary/favicon.ico</icon><atom:link href="/diary/tags/spring-boot/index.xml" rel="self" type="application/rss+xml"/><item><title>url エンコーディングと uri の仕様</title><link>/diary/posts/2022/0928/</link><pubDate>Wed, 28 Sep 2022 08:20:18 +0900</pubDate><guid>/diary/posts/2022/0928/</guid><description>1時に寝ようとして、寝てたか起きてたかわからない時間を過ごして7時に起きた。
WebClient と query string のエンコーディング 以前にも WebClient の基本 について少し書いた。data={&amp;quot;x&amp;quot;: 1, &amp;quot;y&amp;quot;: 2} のような json 文字列を query string でリクエストしようとしたときに少しはまったので書いておく。java 標準ライブラリの URLEncoder を使ってエンコードするとスペースが + になる。これは html の仕様として正しいが、uri の仕様としては不正になる。そのため + を %20 に置き換える必要がある。
private String encode(String data) throws UnsupportedEncodingException { // NOTE: the URI doesn&amp;#39;t allow &amp;#39;+&amp;#39; character return URLEncoder.encode(data, StandardCharsets.UTF_8).replace(&amp;#34;+&amp;#34;, &amp;#34;%20&amp;#34;); } このロジックで {&amp;quot;x&amp;quot;: 1, &amp;quot;y&amp;quot;: 2} を url エンコードすると次の文字列になる。
%7B%22x%22%3A%201%2C%20%22y%22%3A%202%7D あらかじめ url エンコーディングした文字列を渡すと、今度は WebClient が % を %25 にさらにエンコーディングしてしまう。Spring WebClient Requests with Parameters 6.</description><content>&lt;p>1時に寝ようとして、寝てたか起きてたかわからない時間を過ごして7時に起きた。&lt;/p>
&lt;h2 id="webclient-と-query-string-のエンコーディング">WebClient と query string のエンコーディング&lt;/h2>
&lt;p>以前にも &lt;a href="/diary/diary/posts/2022/0722/#spring-webflux-とプロキシ">WebClient の基本&lt;/a> について少し書いた。&lt;code>data={&amp;quot;x&amp;quot;: 1, &amp;quot;y&amp;quot;: 2}&lt;/code> のような json 文字列を query string でリクエストしようとしたときに少しはまったので書いておく。java 標準ライブラリの URLEncoder を使ってエンコードするとスペースが &lt;code>+&lt;/code> になる。これは html の仕様として正しいが、uri の仕様としては不正になる。そのため &lt;code>+&lt;/code> を &lt;code>%20&lt;/code> に置き換える必要がある。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> String &lt;span style="color:#a6e22e">encode&lt;/span>(String data) &lt;span style="color:#66d9ef">throws&lt;/span> UnsupportedEncodingException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// NOTE: the URI doesn&amp;#39;t allow &amp;#39;+&amp;#39; character&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> URLEncoder.&lt;span style="color:#a6e22e">encode&lt;/span>(data, StandardCharsets.&lt;span style="color:#a6e22e">UTF_8&lt;/span>).&lt;span style="color:#a6e22e">replace&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;+&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;%20&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このロジックで &lt;code>{&amp;quot;x&amp;quot;: 1, &amp;quot;y&amp;quot;: 2}&lt;/code> を url エンコードすると次の文字列になる。&lt;/p>
&lt;pre tabindex="0">&lt;code>%7B%22x%22%3A%201%2C%20%22y%22%3A%202%7D
&lt;/code>&lt;/pre>&lt;p>あらかじめ url エンコーディングした文字列を渡すと、今度は WebClient が &lt;code>%&lt;/code> を &lt;code>%25&lt;/code> にさらにエンコーディングしてしまう。&lt;a href="https://www.baeldung.com/webflux-webclient-parameters#encoding-mode">Spring WebClient Requests with Parameters 6.Encoding Mode&lt;/a> によると、次の4つのエンコーディングモードをカスタマイズできる。デフォルトは &lt;em>TEMPLATE_AND_VALUES&lt;/em> らしい。&lt;/p>
&lt;ul>
&lt;li>TEMPLATE_AND_VALUES: Pre-encode the URI template and strictly encode URI variables when expanded&lt;/li>
&lt;li>VALUES_ONLY: Do not encode the URI template, but strictly encode URI variables after expanding them into the template&lt;/li>
&lt;li>URI_COMPONENTS: Encode URI component value after expending URI variables&lt;/li>
&lt;li>NONE: No encoding will be applied&lt;/li>
&lt;/ul>
&lt;p>もとの url エンコード済みの文字列が次のようなものになってしまう。&lt;/p>
&lt;pre tabindex="0">&lt;code>%257B%2522x%2522%253A%25...
&lt;/code>&lt;/pre>&lt;p>既存の実装をあまり変えたくもなくてやや力技で実装した。局所的な変更だからまぁいっか。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>webClient.&lt;span style="color:#a6e22e">get&lt;/span>().&lt;span style="color:#a6e22e">uri&lt;/span>(uriBuilder &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> uriObj &lt;span style="color:#f92672">=&lt;/span> uriBuilder.&lt;span style="color:#a6e22e">path&lt;/span>(getControllerBasePath() &lt;span style="color:#f92672">+&lt;/span> path).&lt;span style="color:#a6e22e">queryParams&lt;/span>(query).&lt;span style="color:#a6e22e">build&lt;/span>(pathParams);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (encodedData &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> uri &lt;span style="color:#f92672">=&lt;/span> uriObj.&lt;span style="color:#a6e22e">toString&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> connector &lt;span style="color:#f92672">=&lt;/span> uri.&lt;span style="color:#a6e22e">contains&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;?&amp;#34;&lt;/span>) &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;amp;&amp;#34;&lt;/span> : &lt;span style="color:#e6db74">&amp;#34;?&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> uriObj &lt;span style="color:#f92672">=&lt;/span> URI.&lt;span style="color:#a6e22e">create&lt;/span>(String.&lt;span style="color:#a6e22e">format&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;%s%sdata=%s&amp;#34;&lt;/span>, uri, connector, encodedData));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> uriObj;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}).&lt;span style="color:#a6e22e">retrieve&lt;/span>()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="よいエラーメッセージわるいエラーメッセージ">よいエラーメッセージ、わるいエラーメッセージ&lt;/h2>
&lt;p>タイトルに惹かれてちょっと期待外れ。&lt;em>art&lt;/em> というと日本人は芸術と高度なものを期待しがちだけど、&lt;em>the art of&lt;/em> だと技術の体系といった意味合いもあるのでちょとしたノウハウを解説する技術ブログのようなものでも誤っていない。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://medium.com/s/user-friendly/the-art-of-the-error-message-9f878d0bff80">The Art of the Error Message&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>ユーザー体験をよくするためのエラーメッセージのコツとして次の3つを提案している。&lt;/p>
&lt;ul>
&lt;li>何が起きたのか、なぜ起きたのかを説明する&lt;/li>
&lt;li>次のステップを提案する&lt;/li>
&lt;li>適切なトーンで書く&lt;/li>
&lt;/ul>
&lt;p>この3つの具体例としてどのようなものかを説明している。私にとってはそう目新しいものではないが、エラーメッセージにトーンという概念はなかったので最近の流行りなのかなと思った。&lt;/p></content></item><item><title>spring boot におけるプロキシ実装</title><link>/diary/posts/2022/0818/</link><pubDate>Thu, 18 Aug 2022 10:27:56 +0900</pubDate><guid>/diary/posts/2022/0818/</guid><description>0時に寝て7時に起きた。
spring boot における簡易的なミドルウェアの実装 bff (backend for frontend) の web api サーバーから別の web api サーバーのエンドポイントを呼び出す処理を書いていてただプロキシする処理のためだけに controller を書くのも面倒だなと気付いた。controller よりも低いレイヤで raw request を扱うにはどうしたらいいかを調べてみたら spring の Filter を使うのが最も簡単そうにみえた。その spring の Filter の1つである OncePerRequestFilter を使って簡易的なプロキシの処理を実装してみた。OncePerRequestFilter はリクエストに対して1度だけ呼ばれることが保証された Filter になる。これらのドキュメントがどこにあるかわからなかったので baeldung のチュートリアル What Is OncePerRequestFilter? をみた方が早いかもしれない。
Filter が複数あるときは実行順序を指定したいときは Order というアノテーションで制御できる。
@Component @Order(30) public class MyFilter extends OncePerRequestFilter { ... } OncePerRequestFilter の doFilterInternal メソッドをオーバーライドすれば任意のミドルウェアっぽい処理を実装できる。
@Override protected void doFilterInternal( HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { // ここに任意の前処理を実装する filterChain.</description><content>&lt;p>0時に寝て7時に起きた。&lt;/p>
&lt;h2 id="spring-boot-における簡易的なミドルウェアの実装">spring boot における簡易的なミドルウェアの実装&lt;/h2>
&lt;p>bff (backend for frontend) の web api サーバーから別の web api サーバーのエンドポイントを呼び出す処理を書いていてただプロキシする処理のためだけに &lt;a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#getting-started.first-application.code.mvc-annotations">controller&lt;/a> を書くのも面倒だなと気付いた。controller よりも低いレイヤで raw request を扱うにはどうしたらいいかを調べてみたら spring の &lt;em>Filter&lt;/em> を使うのが最も簡単そうにみえた。その spring の Filter の1つである &lt;em>OncePerRequestFilter&lt;/em> を使って簡易的なプロキシの処理を実装してみた。OncePerRequestFilter はリクエストに対して1度だけ呼ばれることが保証された Filter になる。これらのドキュメントがどこにあるかわからなかったので baeldung のチュートリアル &lt;a href="https://www.baeldung.com/spring-onceperrequestfilter">What Is OncePerRequestFilter?&lt;/a> をみた方が早いかもしれない。&lt;/p>
&lt;p>Filter が複数あるときは実行順序を指定したいときは &lt;a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#web.servlet.embedded-container.servlets-filters-listeners.beans">Order&lt;/a> というアノテーションで制御できる。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Component&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Order&lt;/span>(30)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MyFilter&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> OncePerRequestFilter {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>OncePerRequestFilter の &lt;em>doFilterInternal&lt;/em> メソッドをオーバーライドすれば任意のミドルウェアっぽい処理を実装できる。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">protected&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">doFilterInternal&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throws&lt;/span> ServletException, IOException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ここに任意の前処理を実装する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> filterChain.&lt;span style="color:#a6e22e">doFilter&lt;/span>(request, response);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ここに任意の後処理を実装する&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>あとは HttpServletRequest と HttpServletResponse を直接操作してリクエストから必要な情報を取り出して、クライアントでリクエストして返ってきたレスポンスをそのまま返してあげればよい。簡単に実装したものが次になる。クライアントには &lt;a href="/diary/diary/posts/2022/0722/">以前に少し調べたことを書いた WebClient&lt;/a> を使っている。WebClient じゃなければ、もう少しシンプルに書ける気もする。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Component&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Order&lt;/span>(30)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">RequestForwardFilter&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> OncePerRequestFilter {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Autowired&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>RequestForwardMatcher&lt;span style="color:#f92672">&amp;gt;&lt;/span> matchers;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">protected&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">doFilterInternal&lt;/span>(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) &lt;span style="color:#66d9ef">throws&lt;/span> ServletException, IOException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> matcher &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">getMatcher&lt;/span>(request);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (matcher.&lt;span style="color:#a6e22e">isEmpty&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> filterChain.&lt;span style="color:#a6e22e">doFilter&lt;/span>(request, response);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> writeResponse(response, &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">forwardRequest&lt;/span>(request, matcher.&lt;span style="color:#a6e22e">get&lt;/span>().&lt;span style="color:#a6e22e">getWebClient&lt;/span>()));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> Optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">forwardRequest&lt;/span>(HttpServletRequest request, WebClient webClient) &lt;span style="color:#66d9ef">throws&lt;/span> IOException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> method &lt;span style="color:#f92672">=&lt;/span> HttpMethod.&lt;span style="color:#a6e22e">resolve&lt;/span>(request.&lt;span style="color:#a6e22e">getMethod&lt;/span>().&lt;span style="color:#a6e22e">toUpperCase&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> originalUri &lt;span style="color:#f92672">=&lt;/span> request.&lt;span style="color:#a6e22e">getRequestURI&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> uri &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">getUri&lt;/span>(originalUri, request.&lt;span style="color:#a6e22e">getQueryString&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> spec &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">getSpec&lt;/span>(method, webClient, uri, request.&lt;span style="color:#a6e22e">getReader&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> spec.&lt;span style="color:#a6e22e">retrieve&lt;/span>().&lt;span style="color:#a6e22e">bodyToMono&lt;/span>(&lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span>.&lt;span style="color:#a6e22e">class&lt;/span>).&lt;span style="color:#a6e22e">blockOptional&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">writeResponse&lt;/span>(HttpServletResponse response, Optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&amp;gt;&lt;/span> bytes) &lt;span style="color:#66d9ef">throws&lt;/span> IOException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (bytes.&lt;span style="color:#a6e22e">isEmpty&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> stream &lt;span style="color:#f92672">=&lt;/span> response.&lt;span style="color:#a6e22e">getOutputStream&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stream.&lt;span style="color:#a6e22e">write&lt;/span>(bytes.&lt;span style="color:#a6e22e">get&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stream.&lt;span style="color:#a6e22e">flush&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stream.&lt;span style="color:#a6e22e">close&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">byte&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> &lt;span style="color:#a6e22e">getRequestBody&lt;/span>(BufferedReader reader) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> reader.&lt;span style="color:#a6e22e">lines&lt;/span>().&lt;span style="color:#a6e22e">collect&lt;/span>(Collectors.&lt;span style="color:#a6e22e">joining&lt;/span>()).&lt;span style="color:#a6e22e">getBytes&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> String &lt;span style="color:#a6e22e">getUri&lt;/span>(String originalUri, String queryString) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> path &lt;span style="color:#f92672">=&lt;/span> originalUri.&lt;span style="color:#a6e22e">replace&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/api&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (StringUtils.&lt;span style="color:#a6e22e">hasLength&lt;/span>(queryString)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> String.&lt;span style="color:#a6e22e">format&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;%s?%s&amp;#34;&lt;/span>, path, queryString);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> path;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> WebClient.&lt;span style="color:#a6e22e">RequestHeadersSpec&lt;/span>&lt;span style="color:#f92672">&amp;lt;?&amp;gt;&lt;/span> getSpec(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> HttpMethod method, WebClient webClient, String uri, BufferedReader reader) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">switch&lt;/span> (method) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> GET:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> webClient.&lt;span style="color:#a6e22e">get&lt;/span>().&lt;span style="color:#a6e22e">uri&lt;/span>(uri);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> POST:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> webClient.&lt;span style="color:#a6e22e">post&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">uri&lt;/span>(uri)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">header&lt;/span>(HttpHeaders.&lt;span style="color:#a6e22e">CONTENT_TYPE&lt;/span>, MediaType.&lt;span style="color:#a6e22e">APPLICATION_JSON_VALUE&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">bodyValue&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">getRequestBody&lt;/span>(reader));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> PUT:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> webClient.&lt;span style="color:#a6e22e">put&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">uri&lt;/span>(uri)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">header&lt;/span>(HttpHeaders.&lt;span style="color:#a6e22e">CONTENT_TYPE&lt;/span>, MediaType.&lt;span style="color:#a6e22e">APPLICATION_JSON_VALUE&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">bodyValue&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">getRequestBody&lt;/span>(reader));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> DELETE:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> webClient.&lt;span style="color:#a6e22e">delete&lt;/span>().&lt;span style="color:#a6e22e">uri&lt;/span>(uri);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">default&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> RuntimeException(String.&lt;span style="color:#a6e22e">format&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Unsupported HTTP method: %s&amp;#34;&lt;/span>, method));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> Optional&lt;span style="color:#f92672">&amp;lt;&lt;/span>RequestForwardMatcher&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">getMatcher&lt;/span>(HttpServletRequest request) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">var&lt;/span> matcher : &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">matchers&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (matcher.&lt;span style="color:#a6e22e">match&lt;/span>(request)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Optional.&lt;span style="color:#a6e22e">of&lt;/span>(matcher);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Optional.&lt;span style="color:#a6e22e">empty&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>matcher のサンプル実装。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">RequestForwardMatcher&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> String ASTERISK &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;*&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> Pattern pattern;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> methods;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> WebClient webClient;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">RequestForwardMatcher&lt;/span>(String pattern, List&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">&amp;gt;&lt;/span> methods, WebClient webClient) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">pattern&lt;/span> &lt;span style="color:#f92672">=&lt;/span> Pattern.&lt;span style="color:#a6e22e">compile&lt;/span>(pattern);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">methods&lt;/span> &lt;span style="color:#f92672">=&lt;/span> methods;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">webClient&lt;/span> &lt;span style="color:#f92672">=&lt;/span> webClient;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">matchMethod&lt;/span>(String method) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">methods&lt;/span>.&lt;span style="color:#a6e22e">contains&lt;/span>(ASTERISK)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">methods&lt;/span>.&lt;span style="color:#a6e22e">contains&lt;/span>(method);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">match&lt;/span>(HttpServletRequest request) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>matchMethod(request.&lt;span style="color:#a6e22e">getMethod&lt;/span>())) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">pattern&lt;/span>.&lt;span style="color:#a6e22e">matcher&lt;/span>(request.&lt;span style="color:#a6e22e">getRequestURI&lt;/span>()).&lt;span style="color:#a6e22e">matches&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> WebClient &lt;span style="color:#a6e22e">getWebClient&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">webClient&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></content></item><item><title>リアクティブプログラミングと WebClient</title><link>/diary/posts/2022/0722/</link><pubDate>Fri, 22 Jul 2022 17:38:30 +0900</pubDate><guid>/diary/posts/2022/0722/</guid><description>0時に寝て6時に起きた。金曜日は非稼働日だけど、今週は月曜日が祝日だったから普通に働いてた。
spring-webflux とプロキシ たまたま api client 周りを触っている。それらは spring の WebClient で実装されている。WebClient は spring-webflux プロジェクトが提供している http リクエストを扱うためのクライアントでリアクティブプログラミングを用いた設計になっている。リアクティブという言葉がピンとこなければ非同期フレームワークを用いた http クライアントと言い換えても大枠ではあっているのではないかと思う。spring-webflux プロジェクトそのものはノンブロッキング、バックプレッシャーといった機能をサポートする web アプリケーションフレームワークを提供するもの。
Web on Reactive Stack Reactor というコアライブラリを使って spring-webflux のフレームワークは実装されている。このデータ構造の1つに Mono と Flux が出てくる。初見の開発者はこの名前のデータ構造がよくわからんというところから始まる。私がそうだった。ドキュメントの説明によると、Mono は0から1、Flux は0からNまでのデータ列の概念を扱うという。おそらく json のようなレスポンスを返す場合は Mono を使い、ストリームを返すレスポンスは Flux を使えばいいんじゃないかと思う。
Reactor is the reactive library of choice for Spring WebFlux. It provides the Mono and Flux API types to work on data sequences of 0..1 (Mono) and 0..N (Flux) through a rich set of operators aligned with the ReactiveX vocabulary of operators.</description><content>&lt;p>0時に寝て6時に起きた。金曜日は非稼働日だけど、今週は月曜日が祝日だったから普通に働いてた。&lt;/p>
&lt;h2 id="spring-webflux-とプロキシ">spring-webflux とプロキシ&lt;/h2>
&lt;p>たまたま api client 周りを触っている。それらは spring の &lt;em>WebClient&lt;/em> で実装されている。WebClient は spring-webflux プロジェクトが提供している http リクエストを扱うためのクライアントでリアクティブプログラミングを用いた設計になっている。リアクティブという言葉がピンとこなければ非同期フレームワークを用いた http クライアントと言い換えても大枠ではあっているのではないかと思う。spring-webflux プロジェクトそのものはノンブロッキング、バックプレッシャーといった機能をサポートする web アプリケーションフレームワークを提供するもの。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html">Web on Reactive Stack&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://github.com/reactor/reactor">Reactor&lt;/a> というコアライブラリを使って spring-webflux のフレームワークは実装されている。このデータ構造の1つに &lt;em>Mono&lt;/em> と &lt;em>Flux&lt;/em> が出てくる。初見の開発者はこの名前のデータ構造がよくわからんというところから始まる。私がそうだった。ドキュメントの説明によると、Mono は0から1、Flux は0からNまでのデータ列の概念を扱うという。おそらく json のようなレスポンスを返す場合は Mono を使い、ストリームを返すレスポンスは Flux を使えばいいんじゃないかと思う。&lt;/p>
&lt;blockquote>
&lt;p>Reactor is the reactive library of choice for Spring WebFlux. It provides the Mono and Flux API types to work on data sequences of 0..1 (Mono) and 0..N (Flux) through a rich set of operators aligned with the ReactiveX vocabulary of operators. Reactor is a Reactive Streams library and, therefore, all of its operators support non-blocking back pressure. Reactor has a strong focus on server-side Java. It is developed in close collaboration with Spring.&lt;/p>
&lt;p>WebFlux requires Reactor as a core dependency but it is interoperable with other reactive libraries via Reactive Streams. As a general rule, a WebFlux API accepts a plain Publisher as input, adapts it to a Reactor type internally, uses that, and returns either a Flux or a Mono as output. So, you can pass any Publisher as input and you can apply operations on the output, but you need to adapt the output for use with another reactive library. Whenever feasible (for example, annotated controllers), WebFlux adapts transparently to the use of RxJava or another reactive library. See Reactive Libraries for more details.&lt;/p>
&lt;p>&lt;a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-reactive-api">https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-reactive-api&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>いまローカルの開発環境では vpn 接続をしてプロキシ経由でアクセスするサーバーがいる。WebClient のプロキシ経由で通信できないという問題があることを同僚から教えてもらった。プロキシ経由でアクセスしようとすると認可エラーになってしまう。なにかしらプロキシ経由の接続に問題がある。&lt;/p>
&lt;pre tabindex="0">&lt;code>Caused by: io.netty.handler.proxy.HttpProxyHandler$HttpProxyConnectException: http, none, /10.100.101.10:8080 =&amp;gt; /192.168.201.35:18980, status: 403 Forbidden
&lt;/code>&lt;/pre>&lt;p>同僚は WebClient のデフォルトでは http の &lt;a href="https://developer.mozilla.org/ja/docs/Web/HTTP/Methods/CONNECT">CONNECT&lt;/a> メソッドを使って通信しようとするが、それを &lt;a href="http://www.squid-cache.org/">squid&lt;/a> がサポートしていないか、設定を変更しないとダメなんじゃないかと話していた。その内容が正しいかどうか、私は未検証だけどデフォルト設定では通信できないことがわかった。ここで WebClient の設定の1つに &lt;a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-client-builder">ClientHttpConnector&lt;/a> があり、任意の http client ライブラリに置き換えられる。ソースをみると次の4つの ClientHttpConnector が使えるらしい。デフォルトが ReactorClientHttpConnector になる。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> ClientHttpConnector &lt;span style="color:#a6e22e">initConnector&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (reactorClientPresent) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ReactorClientHttpConnector();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (jettyClientPresent) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> JettyClientHttpConnector();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (httpComponentsClientPresent) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> HttpComponentsClientHttpConnector();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> JdkClientHttpConnector();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>試しに &lt;a href="https://github.com/jetty-project/jetty-reactive-httpclient">jetty-reactive-httpclient&lt;/a> を使って JettyClientHttpConnector に置き換えてみたところ、プロキシサーバー経由のアクセスができるようになった。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> WebClient &lt;span style="color:#a6e22e">create&lt;/span>(String proxyIp, &lt;span style="color:#66d9ef">int&lt;/span> proxyPort) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> httpClient &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> HttpClient();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> httpClient.&lt;span style="color:#a6e22e">setFollowRedirects&lt;/span>(&lt;span style="color:#66d9ef">true&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> httpClient.&lt;span style="color:#a6e22e">getProxyConfiguration&lt;/span>().&lt;span style="color:#a6e22e">getProxies&lt;/span>().&lt;span style="color:#a6e22e">add&lt;/span>(&lt;span style="color:#66d9ef">new&lt;/span> HttpProxy(proxyIp, proxyPort));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> connector &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> JettyClientHttpConnector(httpClient);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> WebClient.&lt;span style="color:#a6e22e">builder&lt;/span>().&lt;span style="color:#a6e22e">clientConnector&lt;/span>(connector).&lt;span style="color:#a6e22e">build&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></content></item><item><title>データベースを介したテストではまった話し</title><link>/diary/posts/2022/0613/</link><pubDate>Mon, 13 Jun 2022 10:20:17 +0900</pubDate><guid>/diary/posts/2022/0613/</guid><description>1時に寝て7時に起きた。帰りにふらっと仲のよい焼き鳥屋さんに寄ったらちょっとしたハプニングがあって長居してしまった。他に来ていたお客さんのカップルが別れ話を始め、こじれてややこしい状況になって、この騒動が一段落しないと席を立てない空気になってしまって終わるのを待ってた。マスターの知り合いらしくて、そのお客さんが帰ってから当事者たちの背景を聞いたりしてた。人生いろいろあるよなぁ。
spring の Transactional アノテーション spring フレームワークには Transactional というアノテーションがある。SpringBootTest を使ったテストのときに使うと、テストメソッドの終了時に自動的にデータベースへの書き込みがロールバックされて便利なことを テストコードのリファクタリング をしていたときに気付いた。
スレッドプールを使ってマルチスレッドで並行実行する処理を書いてそのテストを書いてみたら意図した結果にならない。なんでだろう？と2時間ほどはまってデバッグしていた。テストデータの書き込みが、実際にはデータベースにコミットされていないので、テストを実行しているスレッド以外のワーカースレッドからデータベースにアクセスしてもテストデータを参照できないからだと気付いた。データベースのトランザクションに細工すると、こういうはまりどころがあるなぁと気付いて Transactional を使わずに普通にテストを書いた。その分、自分でテストメソッドが呼ばれてコミットされたテストデータを削除する必要がある。調べていたときに他にも副作用がいろいろあるよという記事もみつけた。
Don’t Use @Transactional in Tests</description><content>&lt;p>1時に寝て7時に起きた。帰りにふらっと仲のよい焼き鳥屋さんに寄ったらちょっとしたハプニングがあって長居してしまった。他に来ていたお客さんのカップルが別れ話を始め、こじれてややこしい状況になって、この騒動が一段落しないと席を立てない空気になってしまって終わるのを待ってた。マスターの知り合いらしくて、そのお客さんが帰ってから当事者たちの背景を聞いたりしてた。人生いろいろあるよなぁ。&lt;/p>
&lt;h2 id="spring-の-transactional-アノテーション">spring の Transactional アノテーション&lt;/h2>
&lt;p>spring フレームワークには &lt;a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Transactional.html">Transactional&lt;/a> というアノテーションがある。&lt;a href="https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/test/context/SpringBootTest.html">SpringBootTest&lt;/a> を使ったテストのときに使うと、テストメソッドの終了時に自動的にデータベースへの書き込みがロールバックされて便利なことを &lt;a href="/diary/diary/posts/2022/0208/#テストコードのリファクタリング">テストコードのリファクタリング&lt;/a> をしていたときに気付いた。&lt;/p>
&lt;p>スレッドプールを使ってマルチスレッドで並行実行する処理を書いてそのテストを書いてみたら意図した結果にならない。なんでだろう？と2時間ほどはまってデバッグしていた。テストデータの書き込みが、実際にはデータベースにコミットされていないので、テストを実行しているスレッド以外のワーカースレッドからデータベースにアクセスしてもテストデータを参照できないからだと気付いた。データベースのトランザクションに細工すると、こういうはまりどころがあるなぁと気付いて Transactional を使わずに普通にテストを書いた。その分、自分でテストメソッドが呼ばれてコミットされたテストデータを削除する必要がある。調べていたときに他にも副作用がいろいろあるよという記事もみつけた。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://dev.to/henrykeys/don-t-use-transactional-in-tests-40eb">Don’t Use @Transactional in Tests&lt;/a>&lt;/li>
&lt;/ul></content></item><item><title>お花見の場所探し</title><link>/diary/posts/2022/0401/</link><pubDate>Fri, 01 Apr 2022 15:55:25 +0900</pubDate><guid>/diary/posts/2022/0401/</guid><description>0時に寝て5時過ぎに起きた。
spring framework の脆弱性対応 起きてタイムライン眺めてたら spring framework の脆弱性の公式アナウンスが出ていたのですぐに準備してオフィス行って7時前から脆弱性対応の作業をしてた。
Spring Framework RCE, Early Announcement 大学の研究室にいた頃、root staff と呼ばれるシステム管理者をやっていた。研究室のネットワークをすべて freebsd で自分たちで構築していたので os の脆弱性が公表されると研究室のすべての os のパッチ適用をやっていた。具体的にはパッチの当たった kernel をビルドして再起動するといった作業。
それを2年間やっていたせいか、脆弱性情報が公開されるとすぐに対応する癖みたいなものがついた。7時前から作業して検証して7時11分に PR を作成した。レビューアは誰も作業を始めてないけど。金曜日は非稼働日なので私が作業しなくてもよいのだけど、ここまでやったら安心して他の作業に移ることができた。
生田川公園の桜 地元のコミュニティでオミクロン株の感染が落ち着いてきたのでリアルお花見をしたいねという話題があがっている。私自身、お花見に毎年参加するような人間でもないけれど、たしかにコロナ禍になってからはお花見やってないだろうし、個人的にも数年はお花見やってないからやってもいいかなという気持ちにはなった。近場だと 生田川公園 という場所があり、特筆するほど桜がとてもきれいという場所ではないが、一応は桜があって、お花見するスペースもあって、形としては成り立つようなところ。お仕事を終えてから自転車で開花状況を見に行った。19時頃に行って寒くても何組かはお花見している集団はいた。開花状況は7-8割といったところかな。今週末から来週にかけてぐらいが見頃だと思う。</description><content>&lt;p>0時に寝て5時過ぎに起きた。&lt;/p>
&lt;h2 id="spring-framework-の脆弱性対応">spring framework の脆弱性対応&lt;/h2>
&lt;p>起きてタイムライン眺めてたら spring framework の脆弱性の公式アナウンスが出ていたのですぐに準備してオフィス行って7時前から脆弱性対応の作業をしてた。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://spring.io/blog/2022/03/31/spring-framework-rce-early-announcement">Spring Framework RCE, Early Announcement&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>大学の研究室にいた頃、root staff と呼ばれるシステム管理者をやっていた。研究室のネットワークをすべて freebsd で自分たちで構築していたので os の脆弱性が公表されると研究室のすべての os のパッチ適用をやっていた。具体的にはパッチの当たった kernel をビルドして再起動するといった作業。&lt;/p>
&lt;p>それを2年間やっていたせいか、脆弱性情報が公開されるとすぐに対応する癖みたいなものがついた。7時前から作業して検証して7時11分に PR を作成した。レビューアは誰も作業を始めてないけど。金曜日は非稼働日なので私が作業しなくてもよいのだけど、ここまでやったら安心して他の作業に移ることができた。&lt;/p>
&lt;figure>&lt;img src="/diary/diary/img/2022/0401_springframework.png"/>
&lt;/figure>
&lt;h2 id="生田川公園の桜">生田川公園の桜&lt;/h2>
&lt;p>地元のコミュニティでオミクロン株の感染が落ち着いてきたのでリアルお花見をしたいねという話題があがっている。私自身、お花見に毎年参加するような人間でもないけれど、たしかにコロナ禍になってからはお花見やってないだろうし、個人的にも数年はお花見やってないからやってもいいかなという気持ちにはなった。近場だと &lt;a href="https://www.kobe-park.or.jp/kouen_keikaku/2018/11/05/%E7%94%9F%E7%94%B0%E5%B7%9D%E5%85%AC%E5%9C%92/">生田川公園&lt;/a> という場所があり、特筆するほど桜がとてもきれいという場所ではないが、一応は桜があって、お花見するスペースもあって、形としては成り立つようなところ。お仕事を終えてから自転車で開花状況を見に行った。19時頃に行って寒くても何組かはお花見している集団はいた。開花状況は7-8割といったところかな。今週末から来週にかけてぐらいが見頃だと思う。&lt;/p>
&lt;p>&lt;figure>&lt;img src="/diary/diary/img/2022/0401_park1.jpg"/>
&lt;/figure>
&lt;figure>&lt;img src="/diary/diary/img/2022/0401_park2.jpg"/>
&lt;/figure>
&lt;/p></content></item><item><title>spring boot の環境とログ設定</title><link>/diary/posts/2022/0324/</link><pubDate>Thu, 24 Mar 2022 07:54:35 +0900</pubDate><guid>/diary/posts/2022/0324/</guid><description>0時に寝て4時に起きて6時に起きた。
spring のプロファイル設定 spring の Profiles の仕組みを使って環境ごとの設定を作る。デプロイは k8s で管理しているため、spring boot の Externalized Configuration の仕組みを使って、環境変数から application.yml に定義された設定を書き換える。k8s は kustomize で管理していて prod, test, dev の3つの環境で任意の設定を記述できる。
問題はログ出力の設定を環境ごとに変えたい。具体的には datadog に連携されるログは構造化ログ (json lines) を、ローカルの開発ではコンソールログをみたい。Log4j Spring Boot Support によると、1つの設定ファイルに複数のプロファイル設定を記述できるようにもみえるけど、実際にやってみたらうまく動かなかった。xml ではなく yml を使っているせいかもしれないし、私の記述方法が誤っているのかもしれない。いずれにしても yml で複数のプロファイルを設定しているサンプルをみつけられなかった。
そこで Different Log4j2 Configurations per Spring Profile をみて、環境ごとにログ設定ファイルも分割することにした。application.yml には次のように記述する。
spring: profiles: active: dev logging: config: classpath:log4j2-${spring.profiles.active}.yml ローカル開発向けの lgo4j2-dev.yml は次のようになる。
Configuration: status: warn name: YAMLConfig appenders: Console: name: STDOUT target: SYSTEM_OUT PatternLayout: Pattern: &amp;#34;%d{yyyy-MM-dd HH:mm:ss.</description><content>&lt;p>0時に寝て4時に起きて6時に起きた。&lt;/p>
&lt;h2 id="spring-のプロファイル設定">spring のプロファイル設定&lt;/h2>
&lt;p>spring の &lt;a href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.profiles">Profiles&lt;/a> の仕組みを使って環境ごとの設定を作る。デプロイは k8s で管理しているため、spring boot の &lt;a href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config">Externalized Configuration&lt;/a> の仕組みを使って、環境変数から application.yml に定義された設定を書き換える。k8s は kustomize で管理していて prod, test, dev の3つの環境で任意の設定を記述できる。&lt;/p>
&lt;p>問題はログ出力の設定を環境ごとに変えたい。具体的には datadog に連携されるログは構造化ログ (json lines) を、ローカルの開発ではコンソールログをみたい。&lt;a href="https://logging.apache.org/log4j/2.x/log4j-spring-boot/index.html">Log4j Spring Boot Support&lt;/a> によると、1つの設定ファイルに複数のプロファイル設定を記述できるようにもみえるけど、実際にやってみたらうまく動かなかった。xml ではなく yml を使っているせいかもしれないし、私の記述方法が誤っているのかもしれない。いずれにしても yml で複数のプロファイルを設定しているサンプルをみつけられなかった。&lt;/p>
&lt;p>そこで &lt;a href="https://www.baeldung.com/spring-log4j2-config-per-profile">Different Log4j2 Configurations per Spring Profile&lt;/a> をみて、環境ごとにログ設定ファイルも分割することにした。application.yml には次のように記述する。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yml" data-lang="yml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">spring&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">profiles&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">active&lt;/span>: &lt;span style="color:#ae81ff">dev&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">logging&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">config&lt;/span>: &lt;span style="color:#ae81ff">classpath:log4j2-${spring.profiles.active}.yml&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ローカル開発向けの lgo4j2-dev.yml は次のようになる。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yml" data-lang="yml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">Configuration&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">status&lt;/span>: &lt;span style="color:#ae81ff">warn&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">YAMLConfig&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">appenders&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">Console&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">STDOUT&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">target&lt;/span>: &lt;span style="color:#ae81ff">SYSTEM_OUT&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">PatternLayout&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">Pattern&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;%d{yyyy-MM-dd HH:mm:ss.SSS}[%t]%-5level %logger{36} - %msg%n&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>k8s のマニフェストで環境変数を次のように定義すれば prod というプロファイルが設定される。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yml" data-lang="yml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">apps/v1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">Deployment&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">my-service&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">spec&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">template&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">spec&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">containers&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">my-service&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">env&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">spring.profiles.active&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">value&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;prod&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>クラウド環境向けの log4j2-prod.yml は次のようになる。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yml" data-lang="yml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">Configuration&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">status&lt;/span>: &lt;span style="color:#ae81ff">warn&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">YAMLConfig&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">appenders&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">Console&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">STDOUT&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">target&lt;/span>: &lt;span style="color:#ae81ff">SYSTEM_OUT&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">EcsLayout&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">serviceName&lt;/span>: &lt;span style="color:#ae81ff">my-service&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">serviceNodeName&lt;/span>: &lt;span style="color:#66d9ef">null&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">includeMarkers&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">KeyValuePair&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">key&lt;/span>: &lt;span style="color:#ae81ff">type&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">value&lt;/span>: &lt;span style="color:#ae81ff">app&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></content></item><item><title>テストコードのリファクタリング</title><link>/diary/posts/2022/0208/</link><pubDate>Tue, 08 Feb 2022 09:04:49 +0900</pubDate><guid>/diary/posts/2022/0208/</guid><description>0時に寝て6時に起きた。今日は7時半から23時過ぎまで集中してコードを書いてた。最近は19-20時には帰って、晩ご飯食べて、ドラクエタクトやったり漫画読んだりだらだらしている。そんな暇あったら積ん読の本読めって感じだ。
テストコードのリファクタリング 業務機能の開発をするにあたって、既存のテストコードをみていて、@BeforeEach というテストメソッド単位に呼ばれるメソッドでテストデータの削除と postgresql の sequence のリセット処理をしていた。こんなの共通処理ですべてのテーブルの truncate と sequence のリセット処理をすればいいやんとか思って、いろいろ調べて2つのリファクタリングの PR を作成した。先日 JUnit5 の拡張 を調べたばかりだから、テストの共通化のノウハウが溜まっている。Testcontainers Postgres Module と連携して、postgresql コンテナに接続して sequence のリセット処理を汎用のテスト拡張として実装した。テストを実装する開発者は、次のように @ExtendWith(DatabaseInitializer.class) をアノテーションに付与すれば、自分で sequence のリセット処理を @BeforeEach のメソッドに実装する必要がなくなる。
@SpringBootTest @Transactional @ExtendWith(SetupDatabaseContainer.class) @ExtendWith(DatabaseInitializer.class) class MyTest { ... } この作業の過程で spring boot の @Transactional はデフォルトでテストメソッドの実行後にロールバックする機能が提供されていて、いままで @BeforeEach のメソッドで明示的にテーブルのデータを削除する必要はなかったんやと気付いた。じゃあ、なぜ削除するコードを書いてたかと言うと、テストの外部で初期データを作成する仕組みがあるから、初期データを削除する目的でそうしていたことが判明した。そして、一部のコードはそこで作った外部の初期データに依存して実装されていた。テストコードの一部が外部のデータに依存しつつ、テストメソッドでは外部のデータに依存しないように削除のコードが書いてある。書いていて何を言っているのかわからないと思うけど、私も調べてて訳がわからんくて、PR に「いまの状況はかなりややこしい」と前置きしつつ、無駄なコードや仕組みを取り除くための修正を行った。本当は機能開発やらないといけないのにテストコードのリファクタリングするのに大きな時間をかけるわけにはいかないだろうという意図で、半日掛けてリファクタリングして23時過ぎまで作業して、既存のテストコードも含めて全部直した。このリファクタリングで数十のテストケースの約300行ぐらいの初期化コードをなくせた。</description><content>&lt;p>0時に寝て6時に起きた。今日は7時半から23時過ぎまで集中してコードを書いてた。最近は19-20時には帰って、晩ご飯食べて、ドラクエタクトやったり漫画読んだりだらだらしている。そんな暇あったら積ん読の本読めって感じだ。&lt;/p>
&lt;h2 id="テストコードのリファクタリング">テストコードのリファクタリング&lt;/h2>
&lt;p>業務機能の開発をするにあたって、既存のテストコードをみていて、&lt;code>@BeforeEach&lt;/code> というテストメソッド単位に呼ばれるメソッドでテストデータの削除と postgresql の sequence のリセット処理をしていた。こんなの共通処理ですべてのテーブルの truncate と sequence のリセット処理をすればいいやんとか思って、いろいろ調べて2つのリファクタリングの PR を作成した。先日 &lt;a href="/diary/diary/posts/2022/0116/">JUnit5 の拡張&lt;/a> を調べたばかりだから、テストの共通化のノウハウが溜まっている。&lt;a href="https://www.testcontainers.org/modules/databases/postgres/">Testcontainers Postgres Module&lt;/a> と連携して、postgresql コンテナに接続して sequence のリセット処理を汎用のテスト拡張として実装した。テストを実装する開発者は、次のように &lt;code>@ExtendWith(DatabaseInitializer.class)&lt;/code> をアノテーションに付与すれば、自分で sequence のリセット処理を &lt;code>@BeforeEach&lt;/code> のメソッドに実装する必要がなくなる。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@SpringBootTest&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Transactional&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@ExtendWith&lt;/span>(SetupDatabaseContainer.&lt;span style="color:#a6e22e">class&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@ExtendWith&lt;/span>(DatabaseInitializer.&lt;span style="color:#a6e22e">class&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MyTest&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>この作業の過程で spring boot の &lt;a href="https://spring.pleiades.io/spring-framework/docs/current/reference/html/testing.html#testcontext-tx-enabling-transactions">@Transactional&lt;/a> はデフォルトでテストメソッドの実行後にロールバックする機能が提供されていて、いままで &lt;code>@BeforeEach&lt;/code> のメソッドで明示的にテーブルのデータを削除する必要はなかったんやと気付いた。じゃあ、なぜ削除するコードを書いてたかと言うと、テストの外部で初期データを作成する仕組みがあるから、初期データを削除する目的でそうしていたことが判明した。そして、一部のコードはそこで作った外部の初期データに依存して実装されていた。テストコードの一部が外部のデータに依存しつつ、テストメソッドでは外部のデータに依存しないように削除のコードが書いてある。書いていて何を言っているのかわからないと思うけど、私も調べてて訳がわからんくて、PR に「いまの状況はかなりややこしい」と前置きしつつ、無駄なコードや仕組みを取り除くための修正を行った。本当は機能開発やらないといけないのにテストコードのリファクタリングするのに大きな時間をかけるわけにはいかないだろうという意図で、半日掛けてリファクタリングして23時過ぎまで作業して、既存のテストコードも含めて全部直した。このリファクタリングで数十のテストケースの約300行ぐらいの初期化コードをなくせた。&lt;/p></content></item><item><title>spring boot の xml 変換の仕組み</title><link>/diary/posts/2022/0120/</link><pubDate>Thu, 20 Jan 2022 07:39:24 +0900</pubDate><guid>/diary/posts/2022/0120/</guid><description>0時に寝て吐き気がして3時に起きて、断続的に仮眠をとってみたけど、それでも気分悪くて5時から起きてた。昨日の晩ご飯食べて寝てから吐き気が出てきた。なにかの食べ合わせなのだろうか。コロッケとその後にチョコレート食べたのが悪かったのか。普通にオフィスへ行ってお仕事してたら直った。
spring boot の xml 変換 いまお手伝いしているお仕事で spring boot で SOAP の xml 通信しているサービスがある。任意の文字列を受け取って任意の文字列を返すような仕組みで設計されていて、xml の変換処理を jackson を使ってアプリケーションコードで書いていた。
これをやるならミドルウェアでやるべきだなと思って spring boot のドキュメントを調べてみた。Error Handling のように例外が発生したときの処理をフックする ResponseEntityExceptionHandler のようなミドルウェアに近い仕組みはあるが、通常のレスポンスに対して行う処理はなかった。代わりに HttpMessageConverters という、レスポンスを変換する仕組み自体は操作できないが、変換する変換器は置き換えたり拡張したりできるようになっている。レスポンスのデータフォーマットのカスタマイズをしたい場合は HttpMessageConverters で行うというのが spring boot 的なやり方にみえる。
さらに調べていると Write an XML REST Service に jackson-dataformat-xml がクラスパスにあれば jackson の ObjectMapper を使って xml に変換するよと書いてあって、試しにレスポンスのオブジェクトを返したら自動的に xml に変換されるという振る舞いを確認できた。つまり、アプリケーションコードで xml の変換処理を自前で実装しなくてもほぼ同じことを spring boot のデフォルトの仕組みでやってくれるというわけだ。jackson の ObjectMapper のカスタマイズがしたいときもいくつかやり方がある。例えば、 @Configuration をもつ Config オブジェクトで次のような bean を生成すれば任意の設定にカスタマイズした ObjectMapper が使われるようになる。
@Bean public Jackson2ObjectMapperBuilderCustomizer configureObjectMapper() { return builder -&amp;gt; { builder.</description><content>&lt;p>0時に寝て吐き気がして3時に起きて、断続的に仮眠をとってみたけど、それでも気分悪くて5時から起きてた。昨日の晩ご飯食べて寝てから吐き気が出てきた。なにかの食べ合わせなのだろうか。コロッケとその後にチョコレート食べたのが悪かったのか。普通にオフィスへ行ってお仕事してたら直った。&lt;/p>
&lt;h2 id="spring-boot-の-xml-変換">spring boot の xml 変換&lt;/h2>
&lt;p>いまお手伝いしているお仕事で spring boot で &lt;a href="https://en.wikipedia.org/wiki/SOAP">SOAP&lt;/a> の xml 通信しているサービスがある。任意の文字列を受け取って任意の文字列を返すような仕組みで設計されていて、xml の変換処理を jackson を使ってアプリケーションコードで書いていた。&lt;/p>
&lt;p>これをやるならミドルウェアでやるべきだなと思って spring boot のドキュメントを調べてみた。&lt;a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#web.servlet.spring-mvc.error-handling">Error Handling&lt;/a> のように例外が発生したときの処理をフックする ResponseEntityExceptionHandler のようなミドルウェアに近い仕組みはあるが、通常のレスポンスに対して行う処理はなかった。代わりに &lt;a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#web.servlet.spring-mvc.message-converters">HttpMessageConverters&lt;/a> という、レスポンスを変換する仕組み自体は操作できないが、変換する変換器は置き換えたり拡張したりできるようになっている。レスポンスのデータフォーマットのカスタマイズをしたい場合は HttpMessageConverters で行うというのが spring boot 的なやり方にみえる。&lt;/p>
&lt;p>さらに調べていると &lt;a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#howto.spring-mvc.write-xml-rest-service">Write an XML REST Service&lt;/a> に &lt;code>jackson-dataformat-xml&lt;/code> がクラスパスにあれば jackson の ObjectMapper を使って xml に変換するよと書いてあって、試しにレスポンスのオブジェクトを返したら自動的に xml に変換されるという振る舞いを確認できた。つまり、アプリケーションコードで xml の変換処理を自前で実装しなくてもほぼ同じことを spring boot のデフォルトの仕組みでやってくれるというわけだ。jackson の ObjectMapper のカスタマイズがしたいときもいくつかやり方がある。例えば、 &lt;code>@Configuration&lt;/code> をもつ Config オブジェクトで次のような bean を生成すれば任意の設定にカスタマイズした ObjectMapper が使われるようになる。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Bean&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> Jackson2ObjectMapperBuilderCustomizer &lt;span style="color:#a6e22e">configureObjectMapper&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> builder &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> builder.&lt;span style="color:#a6e22e">serializationInclusion&lt;/span>(JsonInclude.&lt;span style="color:#a6e22e">Include&lt;/span>.&lt;span style="color:#a6e22e">NON_EMPTY&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></content></item></channel></rss>