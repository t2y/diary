<!doctype html><html lang=en><head><title>spring boot :: forest nook</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=/diary/tags/spring-boot/><link rel=stylesheet href=/diary/assets/style.css><link rel=stylesheet href=/diary/assets/green.css><link rel=stylesheet href=/diary/style.css><link rel=apple-touch-icon href=/diary/img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=/diary/favicon.ico><meta name=twitter:card content="summary"><meta name=twitter:site content="t2y"><meta name=twitter:creator content><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:title" content="spring boot"><meta property="og:description" content><meta property="og:url" content="/diary/tags/spring-boot/"><meta property="og:site_name" content="forest nook"><meta property="og:image" content="/diary/favicon.ico"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><link href=/diary/tags/spring-boot/index.xml rel=alternate type=application/rss+xml title="forest nook"></head><body class=green><div class="container full headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/diary><div class=logo>forest nook</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/diary/about>自己紹介</a></li><li><a href=/diary/dates>月別一覧</a></li><li><a href=/diary/tags>タグ一覧</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/diary/about>自己紹介</a></li><li><a href=/diary/dates>月別一覧</a></li><li><a href=/diary/tags>タグ一覧</a></li></ul></nav></header><div class=content><div class=posts><div class="post on-list"><h1 class=post-title><a href=/diary/posts/2022/0722/>リアクティブプログラミングと WebClient</a></h1><div class=post-meta><span class=post-date>2022-07-22</span></div><span class=post-tags>#<a href=/diary/tags/java/>java</a>&nbsp;
#<a href=/diary/tags/spring-boot/>spring boot</a>&nbsp;</span><div class=post-content><p>0時に寝て6時に起きた。金曜日は非稼働日だけど、今週は月曜日が祝日だったから普通に働いてた。</p><h2 id=spring-webflux-とプロキシ>spring-webflux とプロキシ</h2><p>たまたま api client 周りを触っている。それらは spring の <em>WebClient</em> で実装されている。WebClient は spring-webflux プロジェクトが提供している http リクエストを扱うためのクライアントでリアクティブプログラミングを用いた設計になっている。リアクティブという言葉がピンとこなければ非同期フレームワークを用いた http クライアントと言い換えても大枠ではあっているのではないかと思う。spring-webflux プロジェクトそのものはノンブロッキング、バックプレッシャーといった機能をサポートする web アプリケーションフレームワークを提供するもの。</p><ul><li><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html>Web on Reactive Stack</a></li></ul><p><a href=https://github.com/reactor/reactor>Reactor</a> というコアライブラリを使って spring-webflux のフレームワークは実装されている。このデータ構造の1つに <em>Mono</em> と <em>Flux</em> が出てくる。初見の開発者はこの名前のデータ構造がよくわからんというところから始まる。私がそうだった。ドキュメントの説明によると、Mono は0から1、Flux は0からNまでのデータ列の概念を扱うという。おそらく json のようなレスポンスを返す場合は Mono を使い、ストリームを返すレスポンスは Flux を使えばいいんじゃないかと思う。</p><blockquote><p>Reactor is the reactive library of choice for Spring WebFlux. It provides the Mono and Flux API types to work on data sequences of 0..1 (Mono) and 0..N (Flux) through a rich set of operators aligned with the ReactiveX vocabulary of operators. Reactor is a Reactive Streams library and, therefore, all of its operators support non-blocking back pressure. Reactor has a strong focus on server-side Java. It is developed in close collaboration with Spring.</p><p>WebFlux requires Reactor as a core dependency but it is interoperable with other reactive libraries via Reactive Streams. As a general rule, a WebFlux API accepts a plain Publisher as input, adapts it to a Reactor type internally, uses that, and returns either a Flux or a Mono as output. So, you can pass any Publisher as input and you can apply operations on the output, but you need to adapt the output for use with another reactive library. Whenever feasible (for example, annotated controllers), WebFlux adapts transparently to the use of RxJava or another reactive library. See Reactive Libraries for more details.</p><p><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-reactive-api>https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-reactive-api</a></p></blockquote><p>いまローカルの開発環境では vpn 接続をしてプロキシ経由でアクセスするサーバーがいる。WebClient のプロキシ経由で通信できないという問題があることを同僚から教えてもらった。プロキシ経由でアクセスしようとすると認可エラーになってしまう。なにかしらプロキシ経由の接続に問題がある。</p><pre tabindex=0><code>Caused by: io.netty.handler.proxy.HttpProxyHandler$HttpProxyConnectException: http, none, /10.100.101.10:8080 =&gt; /192.168.201.35:18980, status: 403 Forbidden
</code></pre><p>同僚は WebClient のデフォルトでは http の <a href=https://developer.mozilla.org/ja/docs/Web/HTTP/Methods/CONNECT>CONNECT</a> メソッドを使って通信しようとするが、それを <a href=http://www.squid-cache.org/>squid</a> がサポートしていないか、設定を変更しないとダメなんじゃないかと話していた。その内容が正しいかどうか、私は未検証だけどデフォルト設定では通信できないことがわかった。ここで WebClient の設定の1つに <a href=https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-client-builder>ClientHttpConnector</a> があり、任意の http client ライブラリに置き換えられる。ソースをみると次の4つの ClientHttpConnector が使えるらしい。デフォルトが ReactorClientHttpConnector になる。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>  <span style=color:#66d9ef>private</span> ClientHttpConnector <span style=color:#a6e22e>initConnector</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>reactorClientPresent<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> ReactorClientHttpConnector<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>jettyClientPresent<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> JettyClientHttpConnector<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>httpComponentsClientPresent<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> HttpComponentsClientHttpConnector<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> JdkClientHttpConnector<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span></code></pre></div><p>試しに <a href=https://github.com/jetty-project/jetty-reactive-httpclient>jetty-reactive-httpclient</a> を使って JettyClientHttpConnector に置き換えてみたところ、プロキシサーバー経由のアクセスができるようになった。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> WebClient <span style=color:#a6e22e>create</span><span style=color:#f92672>(</span>String proxyIp<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> proxyPort<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    var httpClient <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HttpClient<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    httpClient<span style=color:#f92672>.</span><span style=color:#a6e22e>setFollowRedirects</span><span style=color:#f92672>(</span><span style=color:#66d9ef>true</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    httpClient<span style=color:#f92672>.</span><span style=color:#a6e22e>getProxyConfiguration</span><span style=color:#f92672>().</span><span style=color:#a6e22e>getProxies</span><span style=color:#f92672>().</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> HttpProxy<span style=color:#f92672>(</span>proxyIp<span style=color:#f92672>,</span> proxyPort<span style=color:#f92672>));</span>
</span></span><span style=display:flex><span>    var connector <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> JettyClientHttpConnector<span style=color:#f92672>(</span>httpClient<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> WebClient<span style=color:#f92672>.</span><span style=color:#a6e22e>builder</span><span style=color:#f92672>().</span><span style=color:#a6e22e>clientConnector</span><span style=color:#f92672>(</span>connector<span style=color:#f92672>).</span><span style=color:#a6e22e>build</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div></div></div><div class="post on-list"><h1 class=post-title><a href=/diary/posts/2022/0613/>データベースを介したテストではまった話し</a></h1><div class=post-meta><span class=post-date>2022-06-13</span></div><span class=post-tags>#<a href=/diary/tags/spring-boot/>spring boot</a>&nbsp;
#<a href=/diary/tags/testing/>testing</a>&nbsp;</span><div class=post-content><p>1時に寝て7時に起きた。帰りにふらっと仲のよい焼き鳥屋さんに寄ったらちょっとしたハプニングがあって長居してしまった。他に来ていたお客さんのカップルが別れ話を始め、こじれてややこしい状況になって、この騒動が一段落しないと席を立てない空気になってしまって終わるのを待ってた。マスターの知り合いらしくて、そのお客さんが帰ってから当事者たちの背景を聞いたりしてた。人生いろいろあるよなぁ。</p><h2 id=spring-の-transactional-アノテーション>spring の Transactional アノテーション</h2><p>spring フレームワークには <a href=https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Transactional.html>Transactional</a> というアノテーションがある。<a href=https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/test/context/SpringBootTest.html>SpringBootTest</a> を使ったテストのときに使うと、テストメソッドの終了時に自動的にデータベースへの書き込みがロールバックされて便利なことを <a href=/diary/posts/2022/0208/#テストコードのリファクタリング>テストコードのリファクタリング</a> をしていたときに気付いた。</p><p>スレッドプールを使ってマルチスレッドで並行実行する処理を書いてそのテストを書いてみたら意図した結果にならない。なんでだろう？と2時間ほどはまってデバッグしていた。テストデータの書き込みが、実際にはデータベースにコミットされていないので、テストを実行しているスレッド以外のワーカースレッドからデータベースにアクセスしてもテストデータを参照できないからだと気付いた。データベースのトランザクションに細工すると、こういうはまりどころがあるなぁと気付いて Transactional を使わずに普通にテストを書いた。その分、自分でテストメソッドが呼ばれてコミットされたテストデータを削除する必要がある。調べていたときに他にも副作用がいろいろあるよという記事もみつけた。</p><ul><li><a href=https://dev.to/henrykeys/don-t-use-transactional-in-tests-40eb>Don’t Use @Transactional in Tests</a></li></ul></div></div><div class="post on-list"><h1 class=post-title><a href=/diary/posts/2022/0401/>お花見の場所探し</a></h1><div class=post-meta><span class=post-date>2022-04-01</span></div><span class=post-tags>#<a href=/diary/tags/spring-boot/>spring boot</a>&nbsp;
#<a href=/diary/tags/security/>security</a>&nbsp;
#<a href=/diary/tags/life/>life</a>&nbsp;</span><div class=post-content><p>0時に寝て5時過ぎに起きた。</p><h2 id=spring-framework-の脆弱性対応>spring framework の脆弱性対応</h2><p>起きてタイムライン眺めてたら spring framework の脆弱性の公式アナウンスが出ていたのですぐに準備してオフィス行って7時前から脆弱性対応の作業をしてた。</p><ul><li><a href=https://spring.io/blog/2022/03/31/spring-framework-rce-early-announcement>Spring Framework RCE, Early Announcement</a></li></ul><p>大学の研究室にいた頃、root staff と呼ばれるシステム管理者をやっていた。研究室のネットワークをすべて freebsd で自分たちで構築していたので os の脆弱性が公表されると研究室のすべての os のパッチ適用をやっていた。具体的にはパッチの当たった kernel をビルドして再起動するといった作業。</p><p>それを2年間やっていたせいか、脆弱性情報が公開されるとすぐに対応する癖みたいなものがついた。7時前から作業して検証して7時11分に PR を作成した。レビューアは誰も作業を始めてないけど。金曜日は非稼働日なので私が作業しなくてもよいのだけど、ここまでやったら安心して他の作業に移ることができた。</p><figure><img src=/diary/img/2022/0401_springframework.png></figure><h2 id=生田川公園の桜>生田川公園の桜</h2><p>地元のコミュニティでオミクロン株の感染が落ち着いてきたのでリアルお花見をしたいねという話題があがっている。私自身、お花見に毎年参加するような人間でもないけれど、たしかにコロナ禍になってからはお花見やってないだろうし、個人的にも数年はお花見やってないからやってもいいかなという気持ちにはなった。近場だと <a href=https://www.kobe-park.or.jp/kouen_keikaku/2018/11/05/%E7%94%9F%E7%94%B0%E5%B7%9D%E5%85%AC%E5%9C%92/>生田川公園</a> という場所があり、特筆するほど桜がとてもきれいという場所ではないが、一応は桜があって、お花見するスペースもあって、形としては成り立つようなところ。お仕事を終えてから自転車で開花状況を見に行った。19時頃に行って寒くても何組かはお花見している集団はいた。開花状況は7-8割といったところかな。今週末から来週にかけてぐらいが見頃だと思う。</p><p><figure><img src=/diary/img/2022/0401_park1.jpg></figure><figure><img src=/diary/img/2022/0401_park2.jpg></figure></p></div></div><div class="post on-list"><h1 class=post-title><a href=/diary/posts/2022/0324/>spring boot の環境とログ設定</a></h1><div class=post-meta><span class=post-date>2022-03-24</span></div><span class=post-tags>#<a href=/diary/tags/spring-boot/>spring boot</a>&nbsp;
#<a href=/diary/tags/logging/>logging</a>&nbsp;
#<a href=/diary/tags/kubernetes/>kubernetes</a>&nbsp;</span><div class=post-content><p>0時に寝て4時に起きて6時に起きた。</p><h2 id=spring-のプロファイル設定>spring のプロファイル設定</h2><p>spring の <a href=https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.profiles>Profiles</a> の仕組みを使って環境ごとの設定を作る。デプロイは k8s で管理しているため、spring boot の <a href=https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config>Externalized Configuration</a> の仕組みを使って、環境変数から application.yml に定義された設定を書き換える。k8s は kustomize で管理していて prod, test, dev の3つの環境で任意の設定を記述できる。</p><p>問題はログ出力の設定を環境ごとに変えたい。具体的には datadog に連携されるログは構造化ログ (json lines) を、ローカルの開発ではコンソールログをみたい。<a href=https://logging.apache.org/log4j/2.x/log4j-spring-boot/index.html>Log4j Spring Boot Support</a> によると、1つの設定ファイルに複数のプロファイル設定を記述できるようにもみえるけど、実際にやってみたらうまく動かなかった。xml ではなく yml を使っているせいかもしれないし、私の記述方法が誤っているのかもしれない。いずれにしても yml で複数のプロファイルを設定しているサンプルをみつけられなかった。</p><p>そこで <a href=https://www.baeldung.com/spring-log4j2-config-per-profile>Different Log4j2 Configurations per Spring Profile</a> をみて、環境ごとにログ設定ファイルも分割することにした。application.yml には次のように記述する。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#f92672>spring</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>profiles</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>active</span>: <span style=color:#ae81ff>dev</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>logging</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>config</span>: <span style=color:#ae81ff>classpath:log4j2-${spring.profiles.active}.yml</span>
</span></span></code></pre></div><p>ローカル開発向けの lgo4j2-dev.yml は次のようになる。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#f92672>Configuration</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>status</span>: <span style=color:#ae81ff>warn</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>YAMLConfig</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>appenders</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>Console</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>name</span>: <span style=color:#ae81ff>STDOUT</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>target</span>: <span style=color:#ae81ff>SYSTEM_OUT</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>PatternLayout</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>Pattern</span>: <span style=color:#e6db74>&#34;%d{yyyy-MM-dd HH:mm:ss.SSS}[%t]%-5level %logger{36} - %msg%n&#34;</span>
</span></span></code></pre></div><p>k8s のマニフェストで環境変数を次のように定義すれば prod というプロファイルが設定される。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>apps/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Deployment</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-service</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>template</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-service</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>env</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>spring.profiles.active</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>value</span>: <span style=color:#e6db74>&#34;prod&#34;</span>
</span></span></code></pre></div><p>クラウド環境向けの log4j2-prod.yml は次のようになる。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yml data-lang=yml><span style=display:flex><span><span style=color:#f92672>Configuration</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>status</span>: <span style=color:#ae81ff>warn</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>YAMLConfig</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>appenders</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>Console</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>name</span>: <span style=color:#ae81ff>STDOUT</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>target</span>: <span style=color:#ae81ff>SYSTEM_OUT</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>EcsLayout</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>serviceName</span>: <span style=color:#ae81ff>my-service</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>serviceNodeName</span>: <span style=color:#66d9ef>null</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>includeMarkers</span>: <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>KeyValuePair</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>key</span>: <span style=color:#ae81ff>type</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>value</span>: <span style=color:#ae81ff>app</span>
</span></span></code></pre></div></div></div><div class="post on-list"><h1 class=post-title><a href=/diary/posts/2022/0208/>テストコードのリファクタリング</a></h1><div class=post-meta><span class=post-date>2022-02-08</span></div><span class=post-tags>#<a href=/diary/tags/java/>java</a>&nbsp;
#<a href=/diary/tags/spring-boot/>spring boot</a>&nbsp;
#<a href=/diary/tags/testing/>testing</a>&nbsp;</span><div class=post-content><p>0時に寝て6時に起きた。今日は7時半から23時過ぎまで集中してコードを書いてた。最近は19-20時には帰って、晩ご飯食べて、ドラクエタクトやったり漫画読んだりだらだらしている。そんな暇あったら積ん読の本読めって感じだ。</p><h2 id=テストコードのリファクタリング>テストコードのリファクタリング</h2><p>業務機能の開発をするにあたって、既存のテストコードをみていて、<code>@BeforeEach</code> というテストメソッド単位に呼ばれるメソッドでテストデータの削除と postgresql の sequence のリセット処理をしていた。こんなの共通処理ですべてのテーブルの truncate と sequence のリセット処理をすればいいやんとか思って、いろいろ調べて2つのリファクタリングの PR を作成した。先日 <a href=/diary/posts/2022/0116/>JUnit5 の拡張</a> を調べたばかりだから、テストの共通化のノウハウが溜まっている。<a href=https://www.testcontainers.org/modules/databases/postgres/>Testcontainers Postgres Module</a> と連携して、postgresql コンテナに接続して sequence のリセット処理を汎用のテスト拡張として実装した。テストを実装する開発者は、次のように <code>@ExtendWith(DatabaseInitializer.class)</code> をアノテーションに付与すれば、自分で sequence のリセット処理を <code>@BeforeEach</code> のメソッドに実装する必要がなくなる。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@SpringBootTest</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Transactional</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@ExtendWith</span><span style=color:#f92672>(</span>SetupDatabaseContainer<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@ExtendWith</span><span style=color:#f92672>(</span>DatabaseInitializer<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyTest</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>この作業の過程で spring boot の <a href=https://spring.pleiades.io/spring-framework/docs/current/reference/html/testing.html#testcontext-tx-enabling-transactions>@Transactional</a> はデフォルトでテストメソッドの実行後にロールバックする機能が提供されていて、いままで <code>@BeforeEach</code> のメソッドで明示的にテーブルのデータを削除する必要はなかったんやと気付いた。じゃあ、なぜ削除するコードを書いてたかと言うと、テストの外部で初期データを作成する仕組みがあるから、初期データを削除する目的でそうしていたことが判明した。そして、一部のコードはそこで作った外部の初期データに依存して実装されていた。テストコードの一部が外部のデータに依存しつつ、テストメソッドでは外部のデータに依存しないように削除のコードが書いてある。書いていて何を言っているのかわからないと思うけど、私も調べてて訳がわからんくて、PR に「いまの状況はかなりややこしい」と前置きしつつ、無駄なコードや仕組みを取り除くための修正を行った。本当は機能開発やらないといけないのにテストコードのリファクタリングするのに大きな時間をかけるわけにはいかないだろうという意図で、半日掛けてリファクタリングして23時過ぎまで作業して、既存のテストコードも含めて全部直した。このリファクタリングで数十のテストケースの約300行ぐらいの初期化コードをなくせた。</p></div></div><div class="post on-list"><h1 class=post-title><a href=/diary/posts/2022/0120/>spring boot の xml 変換の仕組み</a></h1><div class=post-meta><span class=post-date>2022-01-20</span></div><span class=post-tags>#<a href=/diary/tags/java/>java</a>&nbsp;
#<a href=/diary/tags/spring-boot/>spring boot</a>&nbsp;</span><div class=post-content><p>0時に寝て吐き気がして3時に起きて、断続的に仮眠をとってみたけど、それでも気分悪くて5時から起きてた。昨日の晩ご飯食べて寝てから吐き気が出てきた。なにかの食べ合わせなのだろうか。コロッケとその後にチョコレート食べたのが悪かったのか。普通にオフィスへ行ってお仕事してたら直った。</p><h2 id=spring-boot-の-xml-変換>spring boot の xml 変換</h2><p>いまお手伝いしているお仕事で spring boot で <a href=https://en.wikipedia.org/wiki/SOAP>SOAP</a> の xml 通信しているサービスがある。任意の文字列を受け取って任意の文字列を返すような仕組みで設計されていて、xml の変換処理を jackson を使ってアプリケーションコードで書いていた。</p><p>これをやるならミドルウェアでやるべきだなと思って spring boot のドキュメントを調べてみた。<a href=https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#web.servlet.spring-mvc.error-handling>Error Handling</a> のように例外が発生したときの処理をフックする ResponseEntityExceptionHandler のようなミドルウェアに近い仕組みはあるが、通常のレスポンスに対して行う処理はなかった。代わりに <a href=https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#web.servlet.spring-mvc.message-converters>HttpMessageConverters</a> という、レスポンスを変換する仕組み自体は操作できないが、変換する変換器は置き換えたり拡張したりできるようになっている。レスポンスのデータフォーマットのカスタマイズをしたい場合は HttpMessageConverters で行うというのが spring boot 的なやり方にみえる。</p><p>さらに調べていると <a href=https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#howto.spring-mvc.write-xml-rest-service>Write an XML REST Service</a> に <code>jackson-dataformat-xml</code> がクラスパスにあれば jackson の ObjectMapper を使って xml に変換するよと書いてあって、試しにレスポンスのオブジェクトを返したら自動的に xml に変換されるという振る舞いを確認できた。つまり、アプリケーションコードで xml の変換処理を自前で実装しなくてもほぼ同じことを spring boot のデフォルトの仕組みでやってくれるというわけだ。jackson の ObjectMapper のカスタマイズがしたいときもいくつかやり方がある。例えば、 <code>@Configuration</code> をもつ Config オブジェクトで次のような bean を生成すれば任意の設定にカスタマイズした ObjectMapper が使われるようになる。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Bean</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> Jackson2ObjectMapperBuilderCustomizer <span style=color:#a6e22e>configureObjectMapper</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> builder <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        builder<span style=color:#f92672>.</span><span style=color:#a6e22e>serializationInclusion</span><span style=color:#f92672>(</span>JsonInclude<span style=color:#f92672>.</span><span style=color:#a6e22e>Include</span><span style=color:#f92672>.</span><span style=color:#a6e22e>NON_EMPTY</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>};</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div></div></div><div class=pagination><div class=pagination__buttons></div></div></div></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>© 2021 Tetsuya Morimoto</span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script src=/diary/assets/main.js></script>
<script src=/diary/assets/prism.js></script></div></body></html>