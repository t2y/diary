<!doctype html><html lang=en><head><title>vue.js :: forest nook</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=/diary/tags/vue.js/><link rel=stylesheet href=/diary/styles.css><link rel=stylesheet href=/diary/style.css><link rel="shortcut icon" href=/diary/favicon.ico><meta name=twitter:card content="summary"><meta name=twitter:site content="t2y"><meta name=twitter:creator content><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:title" content="vue.js"><meta property="og:description" content><meta property="og:url" content="/diary/tags/vue.js/"><meta property="og:site_name" content="forest nook"><meta property="og:image" content="/diary/favicon.ico"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><link href=/diary/tags/vue.js/index.xml rel=alternate type=application/rss+xml title="forest nook"></head><body class=green><div class="container full headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/diary><div class=logo>forest nook</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/diary/about>自己紹介</a></li><li><a href=/diary/dates>月別一覧</a></li><li><a href=/diary/tags>タグ一覧</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/diary/about>自己紹介</a></li><li><a href=/diary/dates>月別一覧</a></li><li><a href=/diary/tags>タグ一覧</a></li></ul></nav></header><div class=content><div class=posts><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2022/1105/>フロントエンドの技術選定</a></h1><div class=post-meta><time class=post-date>2022-11-05 (Sat.) ::</time></div><span class=post-tags>#<a href=/diary/tags/react/>react</a>&nbsp;
#<a href=/diary/tags/vue.js/>vue.js</a>&nbsp;
#<a href=/diary/tags/svelte/>svelte</a>&nbsp;</span><div class=post-content><p>24時に BOOK AND BED TOKYO にチェックインして雑多なことして25時過ぎには寝て8時過ぎに起きてチェックアウトした。それから新幹線に乗って神戸まで戻ってきた。東京・品川から新神戸間は、往路は <a href=/diary/posts/2022/1031/#東京出張>EX早特21ワイド</a> だと12,630円で、復路は自由席で14,420円だった。私の中で時間の制約はストレスやエネルギーを使う。帰りは時間に縛られたくないという思いで新幹線の駅に着いてから自由席を買うようにしている。一方で2千円近い差額も大きいので次回以降は帰りの新幹線もEX早特21ワイドで取ることにした。</p><h2 id=フロントエンドの調査>フロントエンドの調査</h2><p>昼過ぎに家に戻ってきて洗濯や片付けしたら疲れてまた寝てた。晩ご飯食べて21時ぐらいからオフィスで作業してた。猫みたいな生活。オフィスからお手伝い先のネットワーク接続の設定をやったりしながらフロントエンドのコードを読んでみた。これは作り直した方がよいだろうと私の中で決意して、どういった技術で作り直すかの技術選定のための調査を開始した。既存のフロントエンド開発の背景や経緯を知らないのでまだ確定ではない。提案の準備のために調査をしておく。</p><p>ここ最近 <a href=https://svelte.dev/>svelte</a> の人気があるのをみかける。1年ほど前に三ノ宮.devで教えてもらってチュートリアルをやってみて、そのときは特にどうとも思わなくて、こんなやり方もあるんやな程度にみていた。その後 vue.js (nuxtjs) での開発を半年間ほど経験して、思いの外、私にとって vue.js がよいものにはみえなかった。react よりも簡単と聞いていたけど、私にとってはあまりそうは思えなかった。vue.js は vue.js なりの難しさ (学習コスト) があるように感じられた。管理画面のような小規模な用途に react や vue.js のようなリッチなライブラリ・フレームワークを使わなくてよい方法があるかを考えたときに svelte を思い出した。svelte の実際のアプリケーションのサンプルコードとして次のコードを読んでいた。</p><ul><li><a href=https://github.com/sveltejs/realworld>svelte realworld example</a></li></ul><p>vue.js の single-file components は svelte の前身である <a href=https://github.com/ractivejs/component-spec>ractive.js のコンポーネント</a> の概念に影響を受けているという。従って、svelte のコンポーネント開発は vue.js と考え方が近いものの、dom 操作は svelte のコンパイル時にコード生成するので仮想 dom は使わない。これがパフォーマンス上の大きなメリットと言われている。react や vue.js よりもずっと軽量なコンパイラ・フレームワークと言える。次のページに複数のフロントエンドの技術の流行をまとめている。svelte はこの2年ぐらいで人気が急上昇していることがわかる。</p><ul><li><a href=https://gist.github.com/tkrotoff/b1caa4c3a185629299ec234d2314e190>Front-end frameworks popularity (React, Vue, Angular and Svelte)</a></li></ul><p>また react と vue.js の現状もちゃんと把握しようと調べていて次の記事がおもしろかった。</p><ul><li><a href=https://zenn.dev/sa2knight/articles/why_react_folks_dont_choose_vue>[Twitter] React ユーザーが Vue を選ばない理由</a></li></ul><p>vue.js は vue3 で react になろうとしていて、その過程の過渡期には様々な問題を抱えているように私からはみえた。</p><ul><li>vue2 と vue3 は互換性がない</li><li>vue3 移行へのエコシステムの本気度がみえない</li><li>vue2 の開発者が本当に vue3 を求めているのか懐疑的</li><li>シェアだけみたら vue.js よりも react の方が高い</li></ul></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2022/1007/>フォームの enter key の振る舞いと制御</a></h1><div class=post-meta><time class=post-date>2022-10-07 (Fri.) ::</time></div><span class=post-tags>#<a href=/diary/tags/vue.js/>vue.js</a>&nbsp;</span><div class=post-content><p>1時に寝て3時に起きて5時までだらだらしてて8時に起きた。季節の変化のせいかな？夜眠れない生活が普通になってきた。最近セブンイレブンのマスカット紅茶をよく飲んでいるのでカフェインの摂り過ぎなのかもしれない。</p><h2 id=vuetify-の-v-form-の-enter-key-無効化>vuetify の v-form の enter key 無効化</h2><p>あるフォーム画面でテキスト入力欄で enter key を押下すると xhr リクエストが送信されてしまう。これがフォームのデフォルトの振る舞いかどうか、私はフロントエンドに詳しくないからよくわからない。検索などはその方が便利なときもあるだろうからそういう振る舞いがあることは知っている。業務の重要な情報を誤って確定してしまってはいけないから、画面によっては禁止した方がよい状況もある。vuetify の v-form を使っている画面だとデフォルトで enter key を入力すると submit 処理が実行されてしまう。パラメーターに渡される event 情報からもマウスクリックとキー入力の見分けがつかない。</p><ul><li><a href=https://vuetifyjs.com/en/api/v-form/#events>v-form events</a></li><li><a href=https://vuetifyjs.com/en/api/v-text-field/#events>v-text-field events</a></li></ul><p>それぞれのコンポーネントの events をみると、v-form は <code>input</code> と <code>submit</code> しか対応していない。v-form の設定で直接 enter key 入力のイベント制御はできない。<a href=https://v2.vuejs.org/v2/guide/components-custom-events.html#Binding-Native-Events-to-Components>Binding Native Events to Components</a> によると、そういった状況のために <code>.native</code> を使うと直接イベントをフックできるらしい。ここで v-text-field は <code>keyup</code> ではなく <code>keydown</code> のみを提供しているせいか <code>keydown</code> を次のように prevent してあげることでテキスト入力欄で enter key を押下しても submit 処理は呼ばれなくなった。但し、副作用として v-form の slots にあるすべてのコンポーネントの enter key の <code>keydown</code> イベントを prevent してしまう。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span>  <span style=color:#f92672>&lt;v-form</span>
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>@</span><span style=color:#a6e22e>submit=</span><span style=color:#e6db74>&#34;submit&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>@keydown.native.enter.prevent</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&gt;</span>
</span></span></code></pre></div><p>vuetify の issue をみていると過去には無効だったものを有効化したようにもみえる。なにが正しい振る舞いなのかよくわからないし、どうやって制御するのが正しい方法なのかよくわからなかった。</p><ul><li><a href=https://github.com/vuetifyjs/vuetify/issues/1545>[Feature Rquest] v-form prop: Enter key submits form #1545</a></li></ul></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2022/0908/>v-data-table のカラムのソートがよくわからない</a></h1><div class=post-meta><time class=post-date>2022-09-08 (Thu.) ::</time></div><span class=post-tags>#<a href=/diary/tags/vue.js/>vue.js</a>&nbsp;</span><div class=post-content><p>23時に寝て3時に起きて軽く apple イベントをみて寝て6時に起きた。</p><h2 id=画面周りのリファクタリング>画面周りのリファクタリング</h2><p>週明けに私が作った画面が本番環境にリリースされて運用を経てフィードバックが返ってきた。主には使い勝手の改善や要望だけど、何にしても実際に使ってもらってフォードバックがくるのは楽しい。丸1日リファクタリングしていて要望があったものはすべて改善できた。インフラ・バッチ処理、サーバーサイド、フロントエンドのすべてを担当しているから私が関わっているところなら適材適所にリファクタリングできる。システム全体を通してやりたいことを独力でできると楽しい。これは人間の独占欲や支配欲を刺激する。おそらくマズローの欲求でも高次の欲求に属するのだと思う。</p><p>v-data-table の <a href=https://vuetifyjs.com/en/api/v-data-table/#props-headers>props headers</a> でカラムの値に対してソートができる。ソート可能に設定すればあとは自動的にやってくれるのかと思いきや、自分で key function を実装しないとソートはされるけど正しい並び順にはならない。key functoin の返り値が number なので -1, 0, 1 の値でソートの入れ替えを実現しているようにみえる。javascript は true => 1, false => 0 と評価されるので単純な比較演算の結果からは意図したソートにならないからではないかと推測する。このやり方が正しい実装かはわからないけど、次のような key function を定義してあげることでソートを実行したときに意図した並び順になることを確認した。すべてのカラムにこんな実装書くの？というところに懸念はある。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>value</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;date&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>sortable</span>: <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>sort</span><span style=color:#f92672>:</span> (<span style=color:#a6e22e>x</span>: <span style=color:#66d9ef>Date</span>, <span style=color:#a6e22e>y</span>: <span style=color:#66d9ef>Date</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>y</span> <span style=color:#f92672>?</span> <span style=color:#f92672>-</span><span style=color:#a6e22e>1</span> : <span style=color:#66d9ef>1</span>;
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>},
</span></span></code></pre></div></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2022/0905/>レンダリングの致命的なバグ</a></h1><div class=post-meta><time class=post-date>2022-09-05 (Mon.) ::</time></div><span class=post-tags>#<a href=/diary/tags/vue.js/>vue.js</a>&nbsp;</span><div class=post-content><p>0時に寝て6時に起きた。</p><h2 id=vuejs-のライフサイクル>vuejs のライフサイクル</h2><p>先日 vuejs で <a href=/diary/posts/2022/0831/#バッチ処理一覧と手動実行>画面作り</a> に挑戦して出来たと喜んでいたが、検索して一覧画面のデータを更新した際に、フォームも再レンダリングされないといけないところがそうなっておらず、データは置き換わっているが画面に表示される値は変わっていないという致命的なバグがあることに気付いた。普通に開発していたら気付きそうなものだが、ローカルの dev server で動かしているとコードを更新すると再レンダリングが実行されるので検索後に画面の一覧が更新されないということを見逃したんだと思う。<a href=https://v2.vuejs.org/v2/guide/instance.html#Lifecycle-Diagram>Lifecycle Diagram</a> もみながら適切なフックポイントの振る舞いを確認したりしていた。setup 後、初期化されてその後に <em>mounted</em> が動いて、その後パラメーターが更新されたときに watch して再更新をかけるといった次のコードでも意図した振る舞いになることは確認した。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span>  <span style=color:#a6e22e>setup</span>(<span style=color:#a6e22e>props</span>, <span style=color:#a6e22e>context</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>data</span><span style=color:#f92672>:</span> { [<span style=color:#a6e22e>key</span>: <span style=color:#66d9ef>string</span>]<span style=color:#f92672>:</span> <span style=color:#66d9ef>any</span> } <span style=color:#f92672>=</span> {};
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> { <span style=color:#a6e22e>_data</span>: <span style=color:#66d9ef>ref</span>(<span style=color:#a6e22e>data</span>), <span style=color:#a6e22e>loading</span>: <span style=color:#66d9ef>false</span> };
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>mounted() {</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>_data</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>JSON</span>.<span style=color:#a6e22e>parse</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>item</span>.<span style=color:#a6e22e>data</span>);
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>watch</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>item</span>(<span style=color:#a6e22e>value</span>: <span style=color:#66d9ef>any</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>_data</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>JSON</span>.<span style=color:#a6e22e>parse</span>(<span style=color:#a6e22e>value</span>.<span style=color:#a6e22e>data</span>);
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>  },
</span></span></code></pre></div><p>レビューしてもらったら、それよりもパラメーターをリアクティブにした方がよいのではないかと教えてもらって次のようにした。本当は setter は不要なんだけど、なぜか初期化のタイミングで setter が呼ばれるので設けた。私の作ったコンポーネントの設計が悪いせいかもしれない。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span>  <span style=color:#a6e22e>setup</span>(<span style=color:#a6e22e>props</span>, <span style=color:#a6e22e>context</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>_item</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>toRef</span>(<span style=color:#a6e22e>props</span>, <span style=color:#e6db74>&#39;item&#39;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> { <span style=color:#a6e22e>_item</span> };
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>computed</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>￼</span>   <span style=color:#a6e22e>_data</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>￼</span>     <span style=color:#66d9ef>get</span>()<span style=color:#f92672>:</span> { [<span style=color:#a6e22e>key</span>: <span style=color:#66d9ef>string</span>]<span style=color:#f92672>:</span> <span style=color:#66d9ef>any</span> } {
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>￼</span>       <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>JSON</span>.<span style=color:#a6e22e>parse</span>(<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>_item</span>.<span style=color:#a6e22e>data</span>);
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>￼</span>     },
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>￼</span>     <span style=color:#66d9ef>set</span>(<span style=color:#a6e22e>value</span>: <span style=color:#66d9ef>any</span>) {
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>￼</span>       <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>$emit</span>(<span style=color:#e6db74>&#39;update:_data&#39;</span>, <span style=color:#a6e22e>value</span>);
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>￼</span>     },
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>  },
</span></span></code></pre></div><p>これは vue2 の <strong>Options API</strong> と呼ばれる記法で、vue3 だと <strong>Composition API</strong> を使って次のような書き方ができるというのも教えてもらった。getter だけなら Composition API でもよさそうだけど、setter もあるとこのコードはまったく簡潔じゃないなと思って Options API を使うことにした。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span>  <span style=color:#a6e22e>setup</span>(<span style=color:#a6e22e>props</span>, <span style=color:#a6e22e>context</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>_item</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>toRef</span>(<span style=color:#a6e22e>props</span>, <span style=color:#e6db74>&#39;item&#39;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>_data</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>computed</span>({
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>get</span><span style=color:#f92672>:</span> () <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>JSON</span>.<span style=color:#a6e22e>parse</span>(<span style=color:#a6e22e>_item</span>.<span style=color:#a6e22e>value</span>.<span style=color:#a6e22e>data</span>),
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>set</span><span style=color:#f92672>:</span> (<span style=color:#a6e22e>value</span>: <span style=color:#66d9ef>any</span>) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>$emit</span>(<span style=color:#e6db74>&#39;update:_data&#39;</span>, <span style=color:#a6e22e>value</span>),
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> { <span style=color:#a6e22e>_item</span>, <span style=color:#a6e22e>_data</span> };
</span></span><span style=display:flex><span>  },
</span></span></code></pre></div></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2022/0831/>コワーキングのオンラインイベントに参加した</a></h1><div class=post-meta><time class=post-date>2022-08-31 (Wed.) ::</time></div><span class=post-tags>#<a href=/diary/tags/vue.js/>vue.js</a>&nbsp;
#<a href=/diary/tags/coworking/>coworking</a>&nbsp;
#<a href=/diary/tags/community/>community</a>&nbsp;
#<a href=/diary/tags/event/>event</a>&nbsp;</span><div class=post-content><p>0時に寝て6時に起きた。</p><h2 id=バッチ処理一覧と手動実行>バッチ処理一覧と手動実行</h2><p>2週間前からフロントエンドの画面作りを始めた。2つ作らないといけない画面があってそのうちの1つを作るのに1週間ちょっとかかった。最初に作る画面で次の順番で作業を進めた。</p><ol><li>web api のエンドポイントの整備</li><li>ページング処理</li><li>検索フォームのコンポーネント作り</li><li>v-data-table の slot 埋め込み</li><li>モーダルダイアログと更新処理</li></ol><p>やりたいところに関係する vuejs, next, vuetify の機能を調べたり、イベントの伝搬の仕組みを調べたりしながら作成した。一度理解したら簡単なので2つ目の画面は半日で完成して pr を出して、もうそのまま本番環境にデプロイした。1つ目の画面の方が要件が複雑で2つ目の方が簡単だったというのもあるけど、どちらもストーリーポイント5が割り当てられているチケットの作業工数は1週間強と4時間といったものになった。なんというか、ストーリーポイントは中長期でみれば、このような人間が成長して一定期間内に消化できるポイントが増えることを計測する狙いもあるけれど、短期でみたらまったくプロジェクトマネジメントには役に立たない。</p><p>最近フロントエンド開発者がチームに参加して、コードを読んだらだいぶひどいみたいなことを言ってた。開発リーダーもフロントエンドは基本的に動いたら OK とか答えてた。だから品質が悪い。</p><h2 id=コワーキングのオンラインイベント>コワーキングのオンラインイベント</h2><p>先日 <a href=/diary/posts/2022/0618/#カフーツさん訪問>カフーツさんのイベント</a> のイベントに参加した。それがきっかけとなり、いとうさんが手掛けている <a href=https://note.com/kanzan10to9/membership>Beyond the Coworking 〜移働の時代〜</a> という note のメンバーシップという有償コミュニティのようなものに入ってみた。記事を読むだけなら1,000円/月で、それ以上の付加価値サービス向けに2,000円/月という料金設定になっている。毎月 zoom でオンラインミーティングを行うというので参加してみた。いとうさんは少し前にコロナに感染して療養していたそうなので日程が急に決まったせいか、たまたま私しか参加者がいなかったので1on1みたいな感じで雑談した。コミュニティを運営するためのサービスとして何がいいかという話しをしたんだけど、たしかにこれとお勧めできるものがない。note も最近そういった機能を追加して sns になろうとしているように垣間見える。</p><ul><li>note のコミュニティ機能とメンバーシップ<ul><li>試しに掲示板を使ってみているが、メンバーはほとんど書き込まない<ul><li>いとうさんと私しか、ほとんど書き込みしていない</li><li>但し、メンバーに質問していると掲示板をみてはいるという</li></ul></li><li>掲示板はストックのサービスだからリアルタイムに返信をもらうことをそもそも期待していない</li><li>リアルタイム性の高いサービスならチャットツールがよいのではないか？<ul><li>slack, discord, ms teams など</li></ul></li><li>他のツールもどうか？<ul><li>note の掲示板, notion, trello など</li></ul></li></ul></li></ul><p>他にもコワーキングスペースをうまく運営するためにはコワーキングスペースマネージャーが必要だといとうさんは考えている。コミュニティマネージャーはコミュニティ形成を目的とするが、コワーキングスペースマネージャーは似て非なるものだという。あれもこれもできないといけないという話しをしてたら、基本的にスーパーマンを要求するポジションになるみたいw、とはいえ、求められる能力として3つをあげると次のような話しをされていた。</p><ul><li>利用者と話しができる<ul><li>利用者の居場所になるには、利用者の業界や業務をある程度は理解して話せないといけない</li><li>コワーキングだから協調のためにお互いの相互理解が必要になる</li></ul></li><li>人の紹介ができる<ul><li>コワーキングだから協調のために利用者同士、または自身の人脈からマッチする人を紹介できないといけない</li></ul></li><li>仕事の斡旋ができる<ul><li>ビジネスなので仕事を依頼したい人、仕事を受けたい人、仕事 (お金) がまわらないと継続できない</li></ul></li></ul><p>カフーツさんはうちのオフィスから一駅、自転車で10分の距離にオフィス兼コワーキングスペースがある。<a href=https://note.com/t2y1979/n/n84deed5fd934>1人でお仕事をしていると相談相手がいないことの弊害</a> がある。身近に信頼できる相談相手がいることは重要だと思う。今後もビジネス寄りのコミュニティやコワーキングの在り方を学んでいこうと思う。</p></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2022/0830/>雰囲気だけで画面を作れた</a></h1><div class=post-meta><time class=post-date>2022-08-30 (Tue.) ::</time></div><span class=post-tags>#<a href=/diary/tags/vue.js/>vue.js</a>&nbsp;</span><div class=post-content><p>0時に寝て6時に起きた。</p><h2 id=slots-で-v-data-table-のカラムを書き換える>slots で v-data-table のカラムを書き換える</h2><p>昨日の続き。v-html で v-dta-table のカラム書き換えしてたら slots でやれと言われた続き。次のようなテンプレートのコードでカスタムカラムを配置するためのコンポーネントを作れば既存の vuejs の仕組みで保守もしやすそうに思う。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;my-wrapping-data-table&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;template</span> <span style=color:#960050;background-color:#1e0010>#[`item.data`]=&#34;{</span> <span style=color:#960050;background-color:#1e0010>item</span> <span style=color:#960050;background-color:#1e0010>}&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;my-custom-cell-layout</span> <span style=color:#a6e22e>:item=</span><span style=color:#e6db74>&#34;item&#34;</span> <span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;/template&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/my-wrapping-data-table&gt;</span>
</span></span></code></pre></div><p>vuejs のテンプレートのこの構文はどういう評価をされるのかが理解できない。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;template</span> <span style=color:#960050;background-color:#1e0010>#[`item.data`]=&#34;{</span> <span style=color:#960050;background-color:#1e0010>item</span> <span style=color:#960050;background-color:#1e0010>}&#34;</span><span style=color:#f92672>&gt;</span>
</span></span></code></pre></div><p>そしたら同僚がそれは次の構文のシンタックスシュガーだと教えてもらった。いずれにしても dsl 万歳って感じで私からは訳がわからない。雰囲気でテンプレート書いて動けばいいんだけど。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;template</span> <span style=color:#960050;background-color:#1e0010>v-slot:`item.data`=&#34;row&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;my-custom-cell-layout</span> <span style=color:#a6e22e>:item=</span><span style=color:#e6db74>&#34;row.item&#34;</span> <span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/template&gt;</span>
</span></span></code></pre></div><p>その後、要素の更新処理のモーダルダイアログ画面も作って1週間以上に渡って開発していた画面を一通り作り終えた。vuejs のことわかってない素人でも雰囲気だけで動く画面は作れた (pr のときにほとんどレビューで指摘を受けなかったので大半は間違ってはないのだろう) 。簡単と言えば簡単ではある。ちなみに私が作ったものが初のページング可能な一覧画面になる。検索フォームもページングに連動してクエリを実行できるようにすべてフルスクラッチでコンポーネントを作った。</p></div></article><article class="post on-list"><h1 class=post-title><a href=/diary/posts/2022/0829/>v-html は使わなくてもよい</a></h1><div class=post-meta><time class=post-date>2022-08-29 (Mon.) ::</time></div><span class=post-tags>#<a href=/diary/tags/vue.js/>vue.js</a>&nbsp;
#<a href=/diary/tags/security/>security</a>&nbsp;</span><div class=post-content><p>0時に寝て7時に起きた。また日曜日は寝てた。</p><h2 id=任意のカラムの書き換え>任意のカラムの書き換え</h2><p>v-data-table の、あるセルが複雑なデータをもっていて、単純にその値を表示するのではなく、一定の構造化やレイアウトを調整した状態で表示したい。セル内の構造を書き換える方法を私は知らなかったので <a href=https://v2.vuejs.org/v2/api/#v-html>v-html</a> という api を使って書き換えればよいのだと思った。しかし、これは間違いだった。間違いの訂正は翌日にやるとして仮に v-html を使うとしても xss の懸念があるのでスクリプトをエスケープしてあげないといけない。<a href=https://github.com/vuejs/vue/issues/6333>Sanitize v-html #6333</a> でも議論されていて vue3 はデフォルトでエスケープする仕組みが入るのかな？vue2 だと <a href=https://www.npmjs.com/package/sanitize-html>sanitize-html</a> を使って次のようにラップすればいいと書いてあった。実際に動かしてみるとスクリプトを実行できたので v-html は危険だというのはわかった。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;div</span> <span style=color:#a6e22e>v-html=</span><span style=color:#e6db74>&#34;$sanitize(value)&#34;</span> <span style=color:#f92672>/&gt;</span>
</span></span></code></pre></div><p>この仕組みを作って pr でレビューしてもらっていたら、カラムの構造を書き換えたいだけなら <a href=https://v2.vuejs.org/v2/guide/components-slots.html>slots</a> を使えば普通にできると教えてもらった。また明日へ。</p></div></article><div class=pagination><div class=pagination__buttons><a href=/diary/tags/vue.js/page/2/ class="button next"><span class=button__text>過去の日記</span>
<span class=button__icon>→</span></a></div></div></div></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>© 2021 Tetsuya Morimoto</span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script type=text/javascript src=/diary/bundle.min.js></script></div></body></html>